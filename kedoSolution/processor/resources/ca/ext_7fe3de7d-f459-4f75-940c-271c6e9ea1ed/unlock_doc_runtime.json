{
  "scripts": "let baseUrl;\nlet login;\nlet password;\nlet myHeaders;\nfunction getConnectionInfo() {\n    const connectionsArray = Namespace.params.data.list_of_connected_platforms ? JSON.parse(Namespace.params.data.list_of_connected_platforms) : undefined;\n    if (!connectionsArray) {\n        return new Error(`Не найдено записей подключения`);\n    }\n    const currentConnection = connectionsArray.length > 1 ? connectionsArray.find((item) => {\n        return item.name === Context.data.connection_name;\n    }) : connectionsArray[0];\n    if (!currentConnection) {\n        return new Error(`Не найдено подключение c именем ${Context.data.connection_name}`);\n    }\n    baseUrl = currentConnection.url;\n    login = currentConnection.login;\n    password = currentConnection.password;\n    myHeaders = {\n        Authorization: `Basic ${btoa(login + ':' + password)}`,\n    };\n    return null;\n}\nasync function action() {\n    if (Context.data.is_alternative) {\n        if (Context.data.staff) {\n            const refItem = new RefItem('kedo', 'staff', Context.data.staff.id);\n            const staff = await refItem.fetch();\n            const docs = await Namespace.params.fields.awaiting_docs_table_1c.app.search().where((f, g) => g.and(f.__deletedAt.eq(null), f.__status.eq(Namespace.params.fields.awaiting_docs_table_1c.app.fields.__status.variants.received))).size(10000).all();\n            const staff_docs = docs.filter(doc => {\n                if (doc.data.personal_guid_1c) {\n                    const staff_id_1c = JSON.parse(doc.data.personal_guid_1c);\n                    if (staff_id_1c[0] == staff.data.id_1c || staff_id_1c[0] == staff.data.individual_id_1c) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n            staff_docs.forEach(doc => doc.data.status_1c = Context.data.polnoe_imya_statusa);\n            await Promise.all(staff_docs.map(doc => doc.save()));\n        }\n        else {\n            const app = await Namespace.params.fields.awaiting_docs_table_1c.app.search().where((f, g) => g.and(f.__deletedAt.eq(null), f.doc_id_1c.eq(Context.data.doc_id))).first();\n            if (!!app) {\n                app.data.status_1c = Context.data.polnoe_imya_statusa;\n                await app.save();\n            }\n            else {\n                Context.data.error = `Couldnt find the awaiting doc app with 1c id of ${Context.data.doc_id}`;\n            }\n        }\n        return;\n    }\n    const error = getConnectionInfo();\n    if (error != null) {\n        Context.data.error = error.message;\n        return;\n    }\n    const statusApp = await Namespace.params.fields.statuses_app.app.search().where((f, g) => g.and(f.__deletedAt.eq(null), f.full_name.eq(Context.data.polnoe_imya_statusa))).first();\n    if (!!statusApp) {\n        const guid = statusApp.data.guid;\n        const url = \"InformationRegister_EM_ПечатныеФормыДокументов?$format=json&$skip=999999&$inlinecount=allpages\";\n        await makeRequest('GET', url);\n        const response = JSON.parse(Context.data.response);\n        const count = parseInt(response[\"odata.count\"]);\n        Context.data.debug = count + ' ';\n        let iter = 0;\n        const batch = 50;\n        while (iter * batch < count) {\n            const docURL = `InformationRegister_EM_ПечатныеФормыДокументов?$format=json&$top=${batch}&$skip=${batch * iter}`;\n            await makeRequest('GET', docURL);\n            const response = JSON.parse(Context.data.response);\n            const foundDoc = response.value.find((item) => {\n                return item[\"Документ\"] === Context.data.doc_id;\n            });\n            Context.data.debug += `iter ${iter} `;\n            if (!!foundDoc) {\n                Context.data.debug += 'found ';\n                const changeURL = `${foundDoc[\"СтатусДокумента@navigationLinkUrl\"].split('/')[0]}?$format=json`;\n                const body = Context.data.delete_printing_file ? {\n                    \"СтатусДокумента_Key\": statusApp.data.guid,\n                    \"ХранилищеПечатнойФормы\": \"\"\n                } : {\n                    \"СтатусДокумента_Key\": statusApp.data.guid\n                };\n                const stringBody = JSON.stringify(body);\n                await makeRequest('PATCH', changeURL, stringBody);\n                break;\n            }\n            iter++;\n        }\n    }\n}\nasync function makeRequest(method, url, body) {\n    const requestOptions = {\n        method: method,\n        headers: myHeaders,\n    };\n    if (!!body) {\n        requestOptions.body = body;\n    }\n    const resUrl = baseUrl + '/' + url;\n    try {\n        const response = await fetch(`${encodeURI(resUrl)}`, requestOptions);\n        if (!response.ok) {\n            Context.data.error += ` staff data res.status error; resUrl - ${resUrl} `;\n            throw new Error(`res error ${resUrl}`);\n        }\n        Context.data.response = JSON.stringify(await response.json());\n    }\n    catch (err) {\n        Context.data.error += ` try/catch error ${err}; resUrl - ${resUrl} `;\n        throw new Error(err);\n    }\n}\n(async function () {\n    action();\n});\n",
  "execution": [
    {
      "code": "sync",
      "name": "Синхронное"
    }
  ],
  "allowGlobal": false,
  "checkInterval": ""
}
