{"scripts":"class MyRole {\n    constructor(group, type, code) {\n        this.code = code;\n        this.group = group;\n        this.type = type;\n    }\n    ;\n    getUsers() {\n        if (this.type == \"group\") {\n            return this.group.users();\n        }\n        else if (this.type == \"orgstruct\") {\n            return System.users.search().where(i =\u003e i.osIds.has(this.group)).size(10000).all();\n        }\n        else\n            return new Promise(() =\u003e this.group);\n    }\n    json() {\n        return {\n            code: this.code,\n            type: this.type\n        };\n    }\n}\n;\nconst uselessNsCodes = [\n    \"admin\",\n    \"messages\",\n    \"company\",\n    \"support\",\n    \"files\",\n    \"tasks\"\n];\nlet docCodes = [\n    \"Авансовые отчеты;avansovyi_otchet\",\n    \"Служебные задания;service_assignments\",\n    \"Служебные записки на командировку;trip_requests\",\n    \"Приказы на командировку;order_for_a_business_trip\",\n    \"Согласия на обработку ПДн ребенка;child_personal_data_consent\",\n    \"Заявления на присвоение категории;application_category_assignment\",\n    \"Доп. соглашения на ИО;execution_responsibilities_additional_agreement\",\n    \"Приказы на перевод;order_for_transfer\",\n    \"Заявления на увольнение;letter_of_resignation\",\n    \"Документы для Госключа;goskey_files\",\n    \"Доп. соглашения на перевод;additional_transfer_agreement\",\n    \"Приказы на ИО;order_execution_responsibilities\",\n    \"Служебные записки на ИО;memo_execution_responsibilities\",\n    \"Согласия на перевод;transfer_approve\",\n    \"Документы 1С;docs_1c\",\n    \"Трудовые договоры;labor_contract\",\n    \"Приказы о изменении паспортных данных;passport_data_change_order\",\n    \"Соглашения об ЭВ;electronic_interaction_agreement\",\n    \"Прочие документы трудоустройства;additional_agreement_to_the_contract\",\n    \"Согласия на ИО;execution_responsibilities_consent\",\n    \"Документы ЛНА;docs_lna\",\n    \"Заявки на перевод;transfer_application\",\n    \"Заявления на трудоустройство;job_application\",\n    \"Доп. соглашения;additional_agreement\",\n    \"Приказы о приеме;admission_order\",\n    \"Приказы на увольнение;dismissal_order\",\n    \"Приказы ЛНА;orders_lna\",\n    \"Согласия на обработку персональных данных;consent_processing_personal_data\",\n    \"Отзывы заявлений на увольнение;recall_dismissal\",\n    \"Заявления на изменение паспортных данных;passport_data_application\",\n    \"Личные документы;personal_documents\",\n    \"Заявления о предоставлении сведений о трудовой деятельности;information_about_labor_activity\",\n    \"На выплату пособия;benefit_application\",\n    \"На материальную помощь;application_for_financial_assistance\",\n    \"Расчетные листы;setlement_sheet\",\n    \"Прочие документы;other_documents\",\n    \"На оплачиваемый отпуск;paid_leave\",\n    \"На материальную помощь;order_financial_assistance\",\n    \"На командировку;memo_business_trip\",\n    \"На перечисление ЗП на р/с;application_for_the_transfer_of_salary_to_the_current_account\",\n    \"На отпуск без сохранения оплаты;leave_without_pay\",\n    \"На отпуск без сохранения оплаты;application_for_leave_without_pay\",\n    \"Совмещения;combination\",\n    \"Справки;certificate\",\n    \"На командировку;order_for_business_trip\",\n    \"На оплачиваемый отпуск;paid_leave_order\",\n    \"В свободной форме;free_from\",\n    \"Прочие документы;prochie_dokumenty\",\n    \"Графики отпусков;vacation_schedule\",\n    \"Приказы на отпуск;vacation_orders\",\n    \"Предложение в график отпусков;offer_vacation_schedule\",\n    \"Заявления на отпуск;vacation_docs\",\n    \"Отсрочка от мобилизации;mobilization\",\n    \"Приказы на работу в нерабочее время;overtimeWorkOrders\",\n    \"Приказы на сверхурочную работу;overtimeOrders\",\n    \"Уведомления о праве отказаться;overtimeWorkNotifications\",\n    \"Служебные записки на работу в нерабочее время;overtime_requests\",\n    \"Согласия на работу в нерабочее время;overtimeWorkConsent\",\n    \"Распоряжения о вызове на работу в нерабочее время;overtime_order\",\n    \"Сотрудники;staff\",\n    \"Заявки на перевод;transfer_application\",\n    \"Заявки на ИО;execution_duties\",\n    \"Заявки на присвоение категории;category_assignment\",\n    \"Заявки на изменение персональных данных;employees_personal_data\",\n    \"Заявки на медосмотр;medical_request\",\n    \"Документы ЛНА;docs_lna\",\n    \"Медосмотры;medical_examination\",\n    \"Отпуска/отсутствия;vacations\",\n    \"Работа в нерабочее время;overtime_work\",\n    \"Командировки;businesstrip_requests\",\n    \"Подразделения;structural_subdivision\"\n];\nconst defaultGroups = [\n    {\n        name: \"Отдел кадров\",\n        fieldCode: \"hr_department\"\n    },\n    {\n        name: \"Бухгалтерия\",\n        fieldCode: \"accounting\"\n    },\n    {\n        name: \"Внутренние сотрудники организации\",\n        fieldCode: \"inner_org_users\"\n    },\n    {\n        name: \"Внешние сотрудники организации\",\n        fieldCode: \"external_org_users\"\n    },\n    {\n        name: \"Подписанты\",\n        fieldCode: \"signatories\"\n    },\n    {\n        name: \"Ответственные за КЭДО\",\n        fieldCode: \"special_access_new\"\n    },\n];\nasync function createGroupNew() {\n    async function saveData(group, organization) {\n        const newRole = new MyRole(group, \"group\", group.id);\n        let accessSettings;\n        const accessSettingsExists = allAccessSettings.length \u003e 0 \u0026\u0026 allAccessSettings.find(setting =\u003e setting.data.organization.id === organization.id);\n        if (accessSettingsExists) {\n            accessSettings = allAccessSettings.find(setting =\u003e setting.data.organization.id === organization.id);\n            Context.data.debug += `accessSettings ${accessSettings.data.__name} exists` + \"\\n\";\n        }\n        else {\n            accessSettings = Context.fields.access_settings.app.create();\n            accessSettings.data.organization = organization;\n            accessSettings.data.__name = `Доступы ${organization.data.__name}`;\n        }\n        if (accessSettings.fields[groupObj.fieldCode]) {\n            accessSettings.data[groupObj.fieldCode] = [newRole];\n        }\n        ;\n        await accessSettings.save();\n        if (!organization.data.org_groups) {\n            organization.data.org_groups = [];\n        }\n        ;\n        if (organization.data.org_groups.map(gr =\u003e gr.code).indexOf(newRole.code) == -1) {\n            organization.data.org_groups.push(newRole);\n            organization.data.access_settings_organization = accessSettings;\n            await organization.save();\n        }\n        ;\n    }\n    ;\n    const maxIterations = defaultGroups.length;\n    const groupObj = defaultGroups[Context.data.iteration];\n    const allStaff = await Context.fields.staff.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ext_user.neq(null))).size(10000).all();\n    const groups = await System.userGroups.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.namespace.eq(\"kedo\"))).size(10000).all();\n    const organizations = await Context.fields.staff.app.fields.organization.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allAccessSettings = await Context.fields.access_settings.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.organization.neq(null))).size(10000).all();\n    const promises = [];\n    for (let org of organizations) {\n        const newGroupName = `${groupObj.name}: ${org.data.__name}`;\n        let newGroup;\n        if (groups.find(gr =\u003e gr.data.__name === newGroupName)) {\n            newGroup = groups.find(gr =\u003e gr.data.__name === newGroupName);\n            Context.data.debug += `group ${newGroup.data.__name} exists` + \"\\n\";\n        }\n        else {\n            newGroup = System.userGroups.create();\n            newGroup.data.__name = newGroupName;\n            newGroup.data.namespace = \"kedo\";\n            newGroup.data.description = org.id;\n        }\n        ;\n        const orgGroupMembers = org.data[groupObj.fieldCode];\n        if (orgGroupMembers \u0026\u0026 orgGroupMembers.length \u003e 0) {\n            const staffIds = allStaff.filter(s =\u003e orgGroupMembers.map(m =\u003e m.id).indexOf(s.id) != -1).map(s =\u003e s.data.ext_user.id);\n            newGroup.data.subOrgunitIds = staffIds;\n        }\n        ;\n        promises.push(new Promise(async function (resolve, reject) {\n            await newGroup.save();\n            resolve(await saveData(newGroup, org));\n        }));\n    }\n    ;\n    await Promise.all(promises);\n    if (Context.data.iteration == maxIterations - 1) {\n        Context.data.all_objects_processed = true;\n        Context.data.iteration = 0;\n    }\n    else {\n        Context.data.iteration++;\n    }\n}\n;\nasync function fillAccountingAndHrGroups() {\n    const organizations = await Context.fields.org_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    let hrUsers = [];\n    let accountingUsers = [];\n    let specialUsers = [];\n    const accountingGroup = await System.userGroups.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.code.eq(\"dfede5be-5011-4ec9-b535-8c9ca3fc4d19\"))).first();\n    const hrGroup = await System.userGroups.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.code.eq(\"abdecf4b-b6ba-419f-bac7-c1455d2a6159\"))).first();\n    const specialAccessGroup = await System.userGroups.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.code.eq(\"0798a43a-8ed9-4b30-8dfe-e16559fb7695\"))).first();\n    const existingHrUsersIds = await hrGroup.users(0, 500).then(users =\u003e users.map(u =\u003e u.id));\n    const existingAccountingUsersIds = await accountingGroup.users(0, 500).then(users =\u003e users.map(u =\u003e u.id));\n    const existingSpecialUsersIds = await specialAccessGroup.users(0, 500).then(users =\u003e users.map(u =\u003e u.id));\n    for (let org of organizations) {\n        try {\n            if ((!org.data.hr_department || org.data.hr_department.length \u003c 1) \u0026\u0026 (!org.data.accounting || org.data.accounting.length \u003c 1) \u0026\u0026 (!org.data.special_access_new || org.data.special_access_new.length \u003c 1)) {\n                Context.data.debug += `no hr, accounting, or special users for ${org.data.__name}`;\n                continue;\n            }\n            ;\n            const hrStaff = await org.fields.hr_department.fetchAll();\n            const filteredHr = hrStaff.filter(s =\u003e s.data.ext_user \u0026\u0026 existingHrUsersIds.indexOf(s.data.ext_user.id) === -1);\n            hrUsers.push(...filteredHr.map(s =\u003e s.data.ext_user));\n            const accountingStaff = await org.fields.accounting.fetchAll();\n            const filteredStaff = accountingStaff.filter(s =\u003e s.data.ext_user \u0026\u0026 existingAccountingUsersIds.indexOf(s.data.ext_user.id) === -1);\n            accountingUsers.push(...filteredStaff.map(s =\u003e s.data.ext_user));\n            const specialStaff = await org.fields.special_access_new.fetchAll();\n            const filteredSpecials = specialStaff.filter(s =\u003e s.data.ext_user \u0026\u0026 existingSpecialUsersIds.indexOf(s.data.ext_user.id) === -1);\n            specialUsers.push(...filteredSpecials.map(s =\u003e s.data.ext_user));\n        }\n        catch (_a) {\n            continue;\n        }\n        ;\n    }\n    ;\n    const filteredHr = Array.from(new Set(hrUsers));\n    const filteredAccounting = Array.from(new Set(hrUsers));\n    const filteredSpecials = Array.from(new Set(specialUsers));\n    await hrGroup.addItem(...filteredHr);\n    await accountingGroup.addItem(...filteredAccounting);\n    await specialAccessGroup.addItem(...filteredSpecials);\n    await accountingGroup.save();\n    await hrGroup.save();\n    await specialAccessGroup.save();\n}\n;\nasync function getSolutions() {\n    const tokenSetting = await Namespace.app.settings.search().where(f =\u003e f.code.eq(\"api_key\")).first();\n    if (!tokenSetting) {\n        throw new Error(\"Проверьте заполненность настроек Домен и Api-токен для методов в модуле в приложении Меню настроек.\");\n    }\n    ;\n    const token = tokenSetting.data.value;\n    const domen = System.getBaseUrl();\n    Context.data.domen = domen;\n    Context.data.token = token;\n    const fullUrl = `${domen}/pub/v1/scheme/namespaces`;\n    const response = await fetch(fullUrl, {\n        headers: {\n            Authorization: `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        throw new Error(JSON.stringify({\n            func: \"getSolutions\",\n            err: await response.text()\n        }));\n    }\n    ;\n    const responseJson = await response.json();\n    if (responseJson.result.result.length \u003c 1) {\n        throw new Error(\"Не найдено разделов\");\n    }\n    ;\n    let allNamespaces = responseJson.result.result.map((solution) =\u003e solution.code);\n    allNamespaces = allNamespaces.filter((ns) =\u003e {\n        return !ns.startsWith(\"ext_\") \u0026\u0026 !ns.startsWith(\"_\") \u0026\u0026 uselessNsCodes.indexOf(ns) == -1;\n    });\n    Context.data.max_iteration = allNamespaces.length;\n    Context.data.ns_codes = JSON.stringify(allNamespaces);\n}\n;\nasync function getAllApps() {\n    const namespaces = JSON.parse(Context.data.ns_codes);\n    const childProcessJson = Context.data.child_process_json ? JSON.parse(Context.data.child_process_json) : [];\n    const currentNs = namespaces[Context.data.iteration];\n    let allDocs = Context.data.app_codes ? JSON.parse(Context.data.app_codes) : [];\n    const appsUrl = `${Context.data.domen}/pub/v1/scheme/namespaces/${currentNs}/apps`;\n    const response = await fetch(appsUrl, {\n        headers: {\n            Authorization: `Bearer ${Context.data.token}`\n        }\n    });\n    if (!response.ok) {\n        Context.data.debug += ` ${JSON.stringify({ url: appsUrl, func: \"getAllApps\", err: await response.text() })} `;\n        return;\n    }\n    ;\n    const responseJson = await response.json();\n    const apps = responseJson.result.result;\n    if (apps.length \u003c 1) {\n        Context.data.debug += `ns ${currentNs} Не найдено приложений`;\n    }\n    ;\n    const appCodes = apps.map((app) =\u003e {\n        const appCode = app.code;\n        const appObj = `${app.namespace};${appCode}`;\n        return appObj;\n    });\n    const childProcessData = apps.map((app) =\u003e {\n        const appCode = app.code;\n        const ns = app.namespace;\n        const name = app.name;\n        return {\n            name,\n            path: `${ns};${appCode}`\n        };\n    });\n    childProcessJson.push(...childProcessData);\n    allDocs.push(...appCodes);\n    Context.data.app_codes = JSON.stringify(allDocs);\n    Context.data.child_process_json = JSON.stringify(childProcessJson);\n    if (Context.data.iteration === Context.data.max_iteration - 1) {\n        Context.data.all_apps_processed = true;\n        Context.data.iteration = 0;\n    }\n    else {\n        Context.data.iteration++;\n    }\n}\n;\nasync function getAllDocs() {\n    Context.data.pause_process = false;\n    let childProcessJson = JSON.parse(Context.data.child_process_json);\n    const allCodes = JSON.parse(Context.data.app_codes);\n    const chunk = allCodes.slice(Context.data.from, Context.data.from + Context.data.max_chunk_size);\n    let allDocs = Context.data.all_docs ? JSON.parse(Context.data.all_docs) : [];\n    if (!chunk || chunk.length === 0) {\n        Context.data.all_namespacess_processed = true;\n        return;\n    }\n    ;\n    let promises = [];\n    for (let app of chunk) {\n        const [currentNs, appCode] = app.split(\";\");\n        const fullUrl = `${Context.data.domen}/pub/v1/scheme/namespaces/${currentNs}/apps/${appCode}`;\n        promises.push(fetch(fullUrl, {\n            headers: {\n                Authorization: `Bearer ${Context.data.token}`\n            }\n        }).then(async (resp) =\u003e {\n            if (!resp.ok) {\n                const respText = await resp.text();\n                if (respText.includes(\"too many\")) {\n                    Context.data.pause_process = true;\n                    Context.data.timeout = new TTime().add(new Duration(30, \"seconds\"));\n                }\n                ;\n                Context.data.debug += ` ${JSON.stringify({ url: fullUrl, func: \"getAllDocs\", error: respText })} `;\n                return;\n            }\n            ;\n            return resp.json();\n        }).catch(err =\u003e {\n            Context.data.debug += ` error at getAllDocs check apps cycle: ${err.message} `;\n            return \"\";\n        }));\n    }\n    ;\n    const jsonData = await Promise.all(promises).then(items =\u003e items.filter(item =\u003e item));\n    if (Context.data.pause_process) {\n        return;\n    }\n    ;\n    let docs = [];\n    for (let data of jsonData) {\n        const appCode = data.application.code;\n        if (!data.application.fields.find((field) =\u003e field.code === \"access_group\")) {\n            childProcessJson = childProcessJson.filter(app =\u003e {\n                const itemCode = app.path.split(\";\")[1];\n                return appCode !== itemCode;\n            });\n            continue;\n        }\n        ;\n        const fullCode = docCodes.map(obj =\u003e obj.split(\";\")[1]).indexOf(appCode) === -1 ? appCode + \"_extended\" : appCode;\n        const appObj = `${data.application.name};${fullCode}`;\n        if (docCodes.indexOf(appObj) === -1) {\n            docCodes.push(appObj);\n        }\n        ;\n        docs.push(appObj);\n    }\n    ;\n    allDocs.push(...docs.filter(doc =\u003e doc));\n    Context.data.child_process_json = JSON.stringify(childProcessJson);\n    Context.data.all_docs = JSON.stringify(allDocs);\n    if (chunk.length \u003c Context.data.max_chunk_size) {\n        Context.data.all_namespacess_processed = true;\n        await formMetaData();\n    }\n    else {\n        Context.data.debug += ` processed codes: ${JSON.stringify(chunk)} `;\n        Context.data.from += Context.data.max_chunk_size;\n    }\n    ;\n}\n;\nasync function formMetaData() {\n    const docs = JSON.parse(Context.data.all_docs);\n    const organizations = await Context.fields.org_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    let chunks = [];\n    for (let org of organizations) {\n        if (org.data.access_settings_organization) {\n            chunks.push({\n                organizationId: org.id,\n                accessSettingsId: org.data.access_settings_organization.id,\n                docs\n            });\n        }\n        ;\n    }\n    ;\n    Context.data.max_iteration = chunks.length;\n    Context.data.chunks = chunks;\n}\n;\nasync function createAllGroups() {\n    const groups = await System.userGroups.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const metaData = Context.data.chunks ? Context.data.chunks[Context.data.iteration] : undefined;\n    if (metaData) {\n        const org = await Context.fields.org_app.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.eq(metaData.organizationId))).first();\n        let promises = [];\n        for (let docObj of metaData.docs) {\n            const docName = docObj.split(\";\")[0];\n            const groupExists = groups.find(gr =\u003e gr.data.__name === `Доступы для ${docName} ${org.data.__name}`);\n            if (!groupExists) {\n                const newGroup = System.userGroups.create();\n                newGroup.data.__name = `Доступы для ${docName} ${org.data.__name}`;\n                newGroup.data.namespace = \"kedo\";\n                newGroup.data.subOrgunitIds = org.data.org_groups \u0026\u0026 org.data.org_groups.length \u003e 0 ? groups.filter(group =\u003e org.data.org_groups.map(gr =\u003e gr.code).indexOf(group.id) != -1).map(gr =\u003e gr.id) : undefined;\n                newGroup.data.description = org.id;\n                promises.push(newGroup.save());\n                if (promises.length \u003e= Context.data.max_chunk_size) {\n                    await Promise.all(promises);\n                    promises = [];\n                }\n            }\n            ;\n        }\n        ;\n        await Promise.all(promises);\n    }\n    ;\n    if (Context.data.iteration == Context.data.max_iteration - 1) {\n        Context.data.all_groups_created = true;\n        Context.data.iteration = 0;\n    }\n    else {\n        Context.data.iteration++;\n    }\n    ;\n}\n;\nasync function fillOrgRights() {\n    const chunk = Context.data.chunks[Context.data.iteration];\n    const orgId = chunk.organizationId;\n    const accessSettingsId = chunk.accessSettingsId;\n    const docs = chunk.docs;\n    const groups = await System.userGroups.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const org = await Context.fields.org_app.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.eq(orgId))).first();\n    const orgRights = await Context.fields.access_settings.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.eq(accessSettingsId))).first();\n    if (!orgRights) {\n        Context.data.iteration++;\n        return;\n    }\n    ;\n    for (let doc of docs) {\n        let [docName, docCode] = doc.split(\";\");\n        if (!org || !orgRights.fields[docCode]) {\n            Context.data.debug += `no field code ${docCode} at ${orgRights.data.__name}`;\n            continue;\n        }\n        ;\n        const group = groups.find(gr =\u003e gr.data.__name === `Доступы для ${docName} ${org.data.__name}`);\n        if (group) {\n            const groupRole = new MyRole(group, \"group\", group.data.__id);\n            if (!orgRights.data[docCode]) {\n                orgRights.data[docCode] = [groupRole];\n                Context.data.debug += `field ${docCode} assigned to ${orgRights.data.__name}`;\n            }\n            else {\n                Context.data.debug += `field ${docCode} at ${orgRights.data.__name} already filled`;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    await orgRights.save();\n    if (Context.data.iteration \u003e= Context.data.max_iteration - 1) {\n        Context.data.all_objects_processed = true;\n        Context.data.iteration = 0;\n    }\n    else {\n        Context.data.iteration++;\n    }\n    ;\n}\n;\nasync function setMissingFields() {\n    const allOrgs = await Context.fields.org_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allOrgRights = await Context.fields.access_settings.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allGroups = await System.userGroups.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    for (let orgRights of allOrgRights) {\n        const org = allOrgs.find(o =\u003e o.id === orgRights.data.organization.id);\n        const newRightsFields = [];\n        for (let field of docCodes) {\n            const [appCode, appName] = [field.split(\";\")[1], field.split(\";\")[0]];\n            if (!orgRights.data[appCode]) {\n                const group = allGroups.find(group =\u003e group.data.__name === `Доступы для ${appName} ${org.data.__name}`);\n                if (group) {\n                    const newRole = new MyRole(group, \"group\", group.id);\n                    orgRights.data[appCode] = [newRole];\n                    newRightsFields.push(appName);\n                }\n                ;\n            }\n            ;\n        }\n        ;\n        await orgRights.save().then(_ =\u003e Context.data.debug += `${orgRights.data.__name} processed, new fields: ${newRightsFields.join(\", \")} `);\n    }\n    ;\n}\n;\n","gatewayPairs":{},"hasTranslations":false}
