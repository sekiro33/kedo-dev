{"scripts":"function isActualData(employee, employeeId, position, transferDate) {\n    if (employee \u0026\u0026 employee.data.employment_table) {\n        const row = employee.data.employment_table.find((item) =\u003e item.id_1c \u0026\u0026 item.id_1c === employeeId);\n        if (row \u0026\u0026 row.admission_date_position) {\n            if (row.admission_date_position.after(transferDate)) {\n                Context.data.error_stack += ` ${employee.data.__name} ${position.data.__name} ${transferDate.format()} в строчке ${row.admission_date_position.format()} - устаревшая информация `;\n                Context.data.debug += ` ${employee.data.__name} ${position.data.__name} ${transferDate.format()} в строчке ${row.admission_date_position.format()} устаревшая информация `;\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction deletePreviousPosition(employee, employmentRow, typeFromData, employeeId) {\n    if (typeFromData \u0026\u0026 employee.data.employment_table \u0026\u0026 employmentRow.type_employment.name === 'Основное место работы') {\n        let mainWorkTypes = employee.data.employment_table.filter((item) =\u003e item.type_employment.name === 'Основное место работы');\n        if (mainWorkTypes \u0026\u0026 mainWorkTypes.length \u003e 1) {\n            let rowToDelete = mainWorkTypes.find((item) =\u003e item.id_1c !== employeeId);\n            if (rowToDelete) {\n                try {\n                    employee.data.employment_table.delete(employee.data.employment_table.indexOf(rowToDelete));\n                    employee.data.id_1c = employmentRow.id_1c;\n                }\n                catch (e) {\n                    Context.data.error_stack += ` Не удалось удалить предыдущее основное место работы `;\n                }\n            }\n        }\n    }\n}\nasync function handleData() {\n    if (!Context.data.staff || !Context.data.position) {\n        return;\n    }\n    let employee = await Context.data.staff.fetch();\n    let pos = Context.data.position;\n    let posApp = await pos.fetch();\n    let org = Context.data.organization;\n    let subdivision = Context.data.subdivision;\n    let typeWorkRelation = Context.data.type_work_relation;\n    let transferDate = Context.data.transfer_date;\n    let id_1c = Context.data.id_1c;\n    let rate = Context.data.rate;\n    let typeFromData = Context.data.type_from_data;\n    let existingPositions = Context.data.existing_positions;\n    let mainWorkCategory = Context.fields.staff.app.fields.employment_table.fields.type_employment.variants.main_workplace;\n    let externalWorkCategory = Context.fields.staff.app.fields.employment_table.fields.type_employment.variants.external_combination;\n    let internalWorkCategory = Context.fields.staff.app.fields.employment_table.fields.type_employment.variants.internal_combination;\n    if (!isActualData(employee, id_1c, posApp, transferDate)) {\n        return;\n    }\n    if (typeWorkRelation \u0026\u0026 (typeWorkRelation === mainWorkCategory.name)) {\n        employee.data.employment_type = mainWorkCategory;\n        employee.data.id_1c = id_1c;\n    }\n    let employment_row;\n    if (existingPositions) {\n        Context.data.debug += ` существует позиция `;\n        employment_row = employee.data.employment_table.find((item) =\u003e id_1c \u0026\u0026 item.id_1c \u0026\u0026 item.id_1c === id_1c);\n        if (!employment_row) {\n            Context.data.debug += ` не нашли строку в таблице  `;\n            employment_row = employee.data.employment_table.insert();\n        }\n    }\n    else {\n        employment_row = employee.data.employment_table.insert();\n    }\n    if (!employment_row \u0026\u0026 pos \u0026\u0026 pos.id) {\n        Context.data.error_stack += \" Не нашли строку с позицией \" + posApp.data.__name;\n        return;\n    }\n    employment_row.id_1c = id_1c;\n    if (org) {\n        employment_row.organization = org;\n    }\n    if (pos) {\n        employment_row.position = pos;\n    }\n    if (subdivision) {\n        employment_row.subdivision = subdivision;\n    }\n    if (typeFromData \u0026\u0026 typeWorkRelation !== undefined) {\n        if (typeWorkRelation === mainWorkCategory.name) {\n            employment_row.type_employment = mainWorkCategory;\n        }\n        else if (typeWorkRelation === externalWorkCategory.name) {\n            employment_row.type_employment = externalWorkCategory;\n        }\n        else if (typeWorkRelation === internalWorkCategory.name) {\n            employment_row.type_employment = internalWorkCategory;\n        }\n    }\n    Context.data.debug += ` employmentRow.type_employment ${!!employment_row.type_employment} `;\n    employment_row.admission_date_position = transferDate;\n    try {\n        employment_row.rate = rate;\n    }\n    catch (e) {\n        employment_row.rate = 1;\n    }\n    if (employment_row \u0026\u0026 employment_row.type_employment \u0026\u0026 employment_row.type_employment.name === mainWorkCategory.name) {\n        if (!!pos) {\n            employee.data.position = pos;\n        }\n        if (!!subdivision) {\n            employee.data.structural_subdivision = subdivision;\n        }\n        if (!!org) {\n            employee.data.organization = org;\n            const orgApp = await org.fetch();\n            employee.data.entity = orgApp.data.entity;\n        }\n        employee.data.employment_type = mainWorkCategory;\n        employee.data.id_1c = id_1c;\n    }\n    deletePreviousPosition(employee, employment_row, typeFromData, id_1c);\n    await employee.save();\n}\nasync function getDate() {\n    if (!Context.data.transfer_row) {\n        return;\n    }\n    let data = JSON.parse(Context.data.transfer_row);\n    if (data.transfer_date) {\n        Context.data.transfer_date = data.transfer_date;\n    }\n}\n","gatewayPairs":{},"hasTranslations":false}
