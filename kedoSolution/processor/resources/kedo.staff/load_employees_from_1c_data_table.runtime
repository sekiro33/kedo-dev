{"scripts":"const chunkSize = 100;\nconst loopSize = 50;\nconst littleChunkSize = 20;\nconst posChunkSize = 1;\nconst posloopSize = 10;\nasync function updateFiring() {\n    if (!Context.data.firing_data) {\n        Context.data.loop_end = true;\n        Context.data.debug += ` loop end `;\n        return;\n    }\n    ;\n    const data = JSON.parse(Context.data.firing_data);\n    const iter_count = data.length - 1;\n    if (Context.data.iterator \u003e= iter_count) {\n        Context.data.loop_end = true;\n        Context.data.firing_date = undefined;\n        Context.data.iterator = -1;\n        Context.data.debug += ` loop end `;\n        return;\n    }\n    Context.data.iterator++;\n    if (Context.data.iterator % loopSize === 0 \u0026\u0026 Context.data.iterator !== 0) {\n        Context.data.is_pause = true;\n    }\n    else {\n        Context.data.is_pause = false;\n    }\n    Context.data.parttime = false;\n    const employeeIds = data.map((item) =\u003e item.ind_ref);\n    const employees = await Namespace.app.staff.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n    Context.data.firing_position_ref = data[Context.data.iterator].ref;\n    const currentEmployee = employees.find(employee =\u003e employee.data.id_1c === data[Context.data.iterator].ref);\n    if (!currentEmployee) {\n        let currentEmployee_fl = employees.find(employee =\u003e {\n            const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n            if (ids.indexOf(data[Context.data.iterator].ind_ref) !== -1 || employee.data.individual_id_1c === data[Context.data.iterator].ind_ref) {\n                return true;\n            }\n        });\n        if (currentEmployee_fl) {\n            Context.data.firing_position_ref = data[Context.data.iterator].ref;\n            Context.data.parttime = true;\n            Context.data.current_employee = currentEmployee_fl;\n        }\n        else {\n            return;\n        }\n    }\n    else {\n        Context.data.current_employee = currentEmployee;\n    }\n    ;\n    try {\n        const date = new Datetime(data[Context.data.iterator].date);\n        Context.data.debug += ` ${data[Context.data.iterator].date} `;\n        Context.data.debug += ` ${new TDate(date.year, date.month, date.day)} `;\n        Context.data.firing_date = new TDate(date.year, date.month, date.day);\n    }\n    catch (e) {\n        Context.data.debug += \"Couldn't parse a date\";\n        Context.data.firing_date = undefined;\n        return;\n    }\n}\nasync function loadAcceptDate() {\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.table_name.like(\"InformationRegister_КадроваяИсторияСотрудников\"), f.__deletedAt.eq(null)))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .size(10000)\n        .all();\n    if (tables.length === 0)\n        return;\n    const sortedApps = tables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const statusEmployeeInfo = parseData(sortedApps, \"InformationRegister_КадроваяИсторияСотрудников\");\n    const mappedData = statusEmployeeInfo.filter((item) =\u003e !!item.data[\"Record\"]).map((item) =\u003e item.data[\"Record\"]).flat().filter((item) =\u003e item[\"Active\"]);\n    const acceptData = mappedData.filter((item) =\u003e item[\"ВидСобытия\"] === \"НачальныеДанные\" || item[\"ВидСобытия\"] === \"Прием\");\n    const firingData = mappedData.filter((item) =\u003e item[\"ВидСобытия\"] === \"Увольнение\");\n    const parsedFiringData = [];\n    for (let item of firingData) {\n        const ref = item[\"Сотрудник\"];\n        const ind_ref = item['ФизическоеЛицо'];\n        const date = item[\"Period\"];\n        parsedFiringData.push({\n            ref: ref,\n            ind_ref: ind_ref,\n            date: date\n        });\n    }\n    const stringFiringData = JSON.stringify(parsedFiringData);\n    Context.data.firing_data = stringFiringData;\n    const employees = await Context.fields.staff.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    let promises = [];\n    for (let item of acceptData) {\n        let foundEmployee = employees.find(employee =\u003e {\n            const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n            if (ids.indexOf(item[\"ФизическоеЛицо\"]) !== -1 || employee.data.individual_id_1c === item[\"ФизическоеЛицо\"]) {\n                return true;\n            }\n        });\n        if (!foundEmployee || !item[\"Period\"])\n            continue;\n        const startDatetime = new Datetime(item[\"Period\"]);\n        const startDate = new TDate(startDatetime.year, startDatetime.month, startDatetime.day);\n        if (!foundEmployee.data.employment_table)\n            continue;\n        for (let i = 0; i \u003c foundEmployee.data.employment_table.length; i++) {\n            const currentRow = foundEmployee.data.employment_table[i];\n            if (currentRow.id_1c === item[\"Сотрудник\"]) {\n                if (currentRow.admission_date_position \u0026\u0026 currentRow.admission_date_position.after(startDate)) {\n                    Context.data.error_stack += ` ${foundEmployee.data.__name} outdated information`;\n                    continue;\n                }\n                currentRow.admission_date_position = startDate;\n            }\n        }\n        if (item[\"Сотрудник\"] === foundEmployee.data.id_1c \u0026\u0026 (!foundEmployee.data.work_start || (foundEmployee.data.work_start \u0026\u0026 foundEmployee.data.work_start.after(startDate)))) {\n            foundEmployee.data.work_start = startDate;\n        }\n        promises.push(foundEmployee.save());\n    }\n    try {\n        await Promise.all(promises);\n    }\n    catch (e) {\n        Context.data.error_stack += \" Couldn't save work start dates \";\n    }\n    promises = [];\n    for (let i = 0; i \u003c employees.length; i++) {\n        const currentEmployee = employees[i];\n        if (!currentEmployee.data.employment_table || currentEmployee.data.employment_table.length === 0) {\n            continue;\n        }\n        if (!currentEmployee.data.work_start)\n            continue;\n        let oldestDate = currentEmployee.data.work_start;\n        for (let i = 0; i \u003c currentEmployee.data.employment_table.length; i++) {\n            const row = currentEmployee.data.employment_table[i];\n            if (row.admission_date_position \u0026\u0026 row.admission_date_position.before(oldestDate)) {\n                oldestDate = row.admission_date_position;\n            }\n        }\n        for (let i = 0; i \u003c currentEmployee.data.employment_table.length; i++) {\n            const row = currentEmployee.data.employment_table[i];\n            row.admission_date_organization = oldestDate;\n        }\n        promises.push(currentEmployee.save());\n        if (promises.length \u003e littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    const staffTables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .where((f, g) =\u003e g.or(f.table_name.eq(\"Catalog_Сотрудники\"), f.table_name.eq(\"Catalog_ФизическиеЛица\")))\n        .size(10000)\n        .all();\n    if (staffTables.length === 0) {\n        Context.data.debug += ` не нашли данных о персональной информации `;\n        return;\n    }\n    const staffSortedApps = staffTables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const externalEmployees = parseData(staffSortedApps, \"Catalog_Сотрудники\");\n    Context.data.debug += ` external_employees.length ${externalEmployees.length} `;\n    for (let employeeData of externalEmployees) {\n        let currentEmployee = employees.find((item) =\u003e item.data.individual_id_1c === employeeData.data[\"ФизическоеЛицо\"]);\n        if (currentEmployee) {\n            Context.data.debug += ` нашли сотрудника `;\n            Context.data.debug += ` ${JSON.stringify(employeeData.data[\"ТекущиеКадровыеДанныеСотрудника\"])} `;\n            if (employeeData.data[\"ТекущиеКадровыеДанныеСотрудника\"] \u0026\u0026 employeeData.data[\"ТекущиеКадровыеДанныеСотрудника\"].length \u003e 0) {\n                Context.data.debug += ` нашли данные по дате приёма `;\n                let workStartDatetime = new Datetime(employeeData.data[\"ТекущиеКадровыеДанныеСотрудника\"][0][\"ДатаПриема\"]);\n                let workStartDate = new TDate(workStartDatetime.year, workStartDatetime.month, workStartDatetime.day);\n                if (employeeData.data[\"Ref\"] === currentEmployee.data.id_1c) {\n                    currentEmployee.data.work_start = workStartDate;\n                    if (currentEmployee.data.employment_table) {\n                        for (let row of currentEmployee.data.employment_table) {\n                            row.admission_date_organization = workStartDate;\n                        }\n                    }\n                }\n                else {\n                    if (currentEmployee.data.employment_table) {\n                        for (let row of currentEmployee.data.employment_table) {\n                            if (row.id_1c === employeeData.data[\"Ref\"]) {\n                                row.admission_date_organization = workStartDate;\n                            }\n                        }\n                    }\n                }\n                if (currentEmployee.data.employment_table) {\n                    for (let row of currentEmployee.data.employment_table) {\n                        if (row.id_1c === employeeData.data[\"Ref\"]) {\n                            row.number_employment_contract = employeeData.data[\"ТекущиеКадровыеДанныеСотрудника\"][0][\"ТрудовойДоговорНомер\"];\n                            try {\n                                const emp_datetime = new Datetime(employeeData.data[\"ТекущиеКадровыеДанныеСотрудника\"][0][\"ТрудовойДоговорДата\"].split(\"T\")[0]);\n                                row.date_employment_contract_as_date = new TDate(emp_datetime.year, emp_datetime.month, emp_datetime.day);\n                            }\n                            catch (e) {\n                                Context.data.error_stack += ` Ошибка преобразования даты ТД `;\n                            }\n                        }\n                    }\n                }\n            }\n            promises.push(currentEmployee.save());\n            if (promises.length \u003e littleChunkSize) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n    }\n    for (let app of staffTables) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n    promises = [];\n    for (let app of tables) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function getWorkSchedules() {\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.table_name.eq(\"InformationRegister_ГрафикРаботыСотрудников\"), f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    const workSchedules = await Namespace.app.work_schedules.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    const employees = await Context.fields.staff.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    if (tables.length === 0 || workSchedules.length === 0)\n        return;\n    const sortedApps = tables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return bDate - aDate;\n    });\n    const currentTable = sortedApps[0];\n    const currentTableParsedData = JSON.parse(currentTable.data.table_data);\n    const data = currentTableParsedData.filter((item) =\u003e !!item.data[\"Record\"]).map((item) =\u003e item.data[\"Record\"][0]);\n    let promises = [];\n    for (let i = 0; i \u003c employees.length; i++) {\n        const currentEmployee = employees[i];\n        for (let row of currentEmployee.data.employment_table) {\n            const employeeRef = row.id_1c;\n            if (!employeeRef)\n                continue;\n            const foundSchedule = data.find((item) =\u003e item[\"Сотрудник\"] === employeeRef);\n            if (!foundSchedule)\n                continue;\n            const foundScheduleId = foundSchedule[\"ГрафикРаботы\"];\n            const employeesSchedule = workSchedules.find((item) =\u003e item.data.id_1c === foundScheduleId);\n            if (!!foundSchedule) {\n            }\n            if (!employeesSchedule)\n                continue;\n            if (row.id_1c === currentEmployee.data.id_1c) {\n                currentEmployee.data.work_schedules = employeesSchedule;\n            }\n            row.work_schedules = employeesSchedule;\n            promises.push(currentEmployee.save());\n            if (promises.length \u003e littleChunkSize) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n    }\n    await Promise.all(promises);\n}\nasync function createPersons() {\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .where((f, g) =\u003e g.or(f.table_name.eq(\"Catalog_Сотрудники\"), f.table_name.eq(\"Catalog_ФизическиеЛица\")))\n        .size(10000)\n        .all();\n    if (tables.length === 0) {\n        return;\n    }\n    const sorted_apps = tables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const tablesPersDocs = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .where((f, g) =\u003e g.or(f.table_name.eq(\"InformationRegister_КадроваяИсторияСотрудников\")))\n        .size(10000)\n        .all();\n    let persDocs = undefined;\n    if (tablesPersDocs \u0026\u0026 tablesPersDocs.length \u003e 0) {\n        const sortedAppPersDoc = tablesPersDocs.sort((a, b) =\u003e {\n            const aDate = a.data.__createdAt.asDate();\n            const bDate = b.data.__createdAt.asDate();\n            return aDate - bDate;\n        });\n        persDocs = parseData(sortedAppPersDoc, \"InformationRegister_КадроваяИсторияСотрудников\");\n    }\n    const externalEmployees = parseData(sorted_apps, \"Catalog_Сотрудники\");\n    const externalPersonalData = parseData(sorted_apps, \"Catalog_ФизическиеЛица\");\n    if (externalPersonalData.length === 0)\n        return;\n    Context.data.created_staffs = [];\n    await createBaseEmployees(externalEmployees, externalPersonalData, persDocs);\n}\nconst parseData = (data, tableName) =\u003e {\n    const result = [];\n    data.forEach(item =\u003e {\n        if (item.data.table_name === tableName \u0026\u0026 !!item.data.table_data) {\n            result.push(...JSON.parse(item.data.table_data));\n        }\n    });\n    return result;\n};\nasync function addPassportData() {\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.table_name.eq(\"InformationRegister_ДокументыФизическихЛиц\")))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .size(10000)\n        .all();\n    if (tables.length === 0) {\n        return;\n    }\n    const sortedApps = tables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const baseArray = [];\n    const externalDocData = baseArray.concat(...(sortedApps.filter(item =\u003e item.data.table_name === \"InformationRegister_ДокументыФизическихЛиц\" \u0026\u0026 !!item.data.table_data).map(item =\u003e JSON.parse(item.data.table_data))));\n    await addDocumentData(externalDocData);\n    let promises = [];\n    for (let app of tables) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function addResponsibleEmployees() {\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .where((f, g) =\u003e g.or(f.table_name.eq(\"InformationRegister_СведенияОбОтветственныхЛицах\")))\n        .size(10000)\n        .all();\n    if (tables.length === 0) {\n        return;\n    }\n    const sortedApps = tables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const headData = parseData(sortedApps, \"InformationRegister_СведенияОбОтветственныхЛицах\");\n    await fillResponsibleEmployees(headData);\n    let promises = [];\n    for (let app of tables) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function fillResponsibleEmployees(headData) {\n    const parsedHeadData = headData.map((data) =\u003e {\n        return data.data[\"Record\"][0];\n    });\n    const allEmployees = await Context.fields.staff.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n    if (parsedHeadData.length !== 0) {\n        loadHeadData(parsedHeadData, allEmployees);\n    }\n    ;\n}\nasync function addWorkTypes() {\n    Context.data.loop_end = false;\n    Context.data.iterator++;\n    if (Context.data.iterator % posloopSize === 0 \u0026\u0026 Context.data.iterator !== 0) {\n        Context.data.is_pause = true;\n    }\n    else {\n        Context.data.is_pause = false;\n    }\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .where((f, g) =\u003e g.or(f.table_name.eq(\"InformationRegister_ВидыЗанятостиСотрудников\")))\n        .size(posChunkSize)\n        .all();\n    if (tables.length === 0) {\n        Context.data.loop_end = true;\n        return;\n    }\n    const sortedApps = tables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const typeData = parseData(sortedApps, \"InformationRegister_ВидыЗанятостиСотрудников\");\n    await addTypeData(typeData);\n    let promises = [];\n    for (let app of tables) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function addTypeData(types) {\n    let promises = [];\n    const filteredTypeData = types.filter((item) =\u003e {\n        return !!item.data[\"Record\"];\n    }).map((data) =\u003e {\n        return data.data[\"Record\"];\n    }).flat().filter((item) =\u003e {\n        return item[\"ВидЗанятости\"] !== \"Совмещена\" \u0026\u0026 item[\"Active\"];\n    });\n    const personsIds = filteredTypeData.map((item) =\u003e {\n        return item[\"ФизическоеЛицо\"];\n    });\n    const allEmployees = await Context.fields.staff.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n    const allNeededEmployees = allEmployees.filter(employee =\u003e {\n        let found = false;\n        const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n        if (personsIds \u0026\u0026 personsIds.indexOf(employee.data.individual_id_1c) !== -1) {\n            found = true;\n        }\n        if (!found \u0026\u0026 ids) {\n            for (let id of ids) {\n                if (personsIds \u0026\u0026 personsIds.indexOf(id) !== -1) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n        return found;\n    });\n    const mainWorkCategory = Context.fields.staff.app.fields.employment_table.fields.type_employment.variants.main_workplace;\n    const innerWorkCategory = Context.fields.staff.app.fields.employment_table.fields.type_employment.variants.internal_combination;\n    const outerWorkCategory = Context.fields.staff.app.fields.employment_table.fields.type_employment.variants.external_combination;\n    for (let employee of allNeededEmployees) {\n        const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n        let allEmployments = filteredTypeData.filter((item) =\u003e !!item[\"ФизическоеЛицо\"]).filter((item) =\u003e {\n            return item[\"ФизическоеЛицо\"] === employee.data.individual_id_1c || (!!ids \u0026\u0026 ids.indexOf(item[\"ФизическоеЛицо\"]) !== -1);\n        });\n        for (let i = 0; i \u003c allEmployments.length; i++) {\n            const currentEmployment = allEmployments[i];\n            if (employee.data.employment_table) {\n                let row = employee.data.employment_table.find(item =\u003e item.id_1c === currentEmployment[\"Сотрудник\"]);\n                if (!row) {\n                    let newRow = employee.data.employment_table.insert();\n                    newRow.id_1c = currentEmployment[\"Сотрудник\"];\n                    switch (currentEmployment[\"ВидЗанятости\"]) {\n                        case \"ОсновноеМестоРаботы\":\n                            newRow.type_employment = mainWorkCategory;\n                            break;\n                        case \"ВнутреннееСовместительство\":\n                            newRow.type_employment = innerWorkCategory;\n                            break;\n                        case \"Совместительство\":\n                            newRow.type_employment = outerWorkCategory;\n                            break;\n                    }\n                    promises.push(employee.save());\n                    if (promises.length \u003e= littleChunkSize) {\n                        await Promise.all(promises);\n                        promises = [];\n                    }\n                }\n            }\n        }\n    }\n    await Promise.all(promises);\n}\nasync function addPositionData() {\n    Context.data.loop_end = false;\n    Context.data.iterator++;\n    if (Context.data.iterator % posloopSize === 0 \u0026\u0026 Context.data.iterator !== 0) {\n        Context.data.is_pause = true;\n    }\n    else {\n        Context.data.is_pause = false;\n    }\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .where((f, g) =\u003e g.or(f.table_name.eq(\"InformationRegister_ЗанятостьПозицийШтатногоРасписания\")))\n        .size(10000)\n        .all();\n    if (tables.length === 0) {\n        Context.data.loop_end = true;\n        return;\n    }\n    const sortedApps = tables.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const positionsData = parseData(sortedApps, \"InformationRegister_ЗанятостьПозицийШтатногоРасписания\");\n    await addWorkData(positionsData);\n    let promises = [];\n    for (let app of tables) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nfunction isActualData(employee, employee_id, position, transfer_date) {\n    if (employee) {\n        if (employee.data.employment_table) {\n            const row = employee.data.employment_table.find((item) =\u003e item.id_1c \u0026\u0026 item.id_1c === employee_id);\n            if (row \u0026\u0026 row.admission_date_position) {\n                if (row.admission_date_position.after(transfer_date)) {\n                    Context.data.error_stack += ` ${employee.data.__name} ${position.data.__name} ${transfer_date.format()} в строчке ${row.admission_date_position.format()} - устаревшая информация `;\n                    Context.data.debug += ` ${employee.data.__name} ${position.data.__name} ${transfer_date.format()} в строчке ${row.admission_date_position.format()} устаревшая информация `;\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\nasync function loadHeadData(parsedHeadData, allEmployees) {\n    let promises = [];\n    const orgs = await Namespace.app.organization.search()\n        .where(f =\u003e f.__deletedAt.eq(null))\n        .size(10000).all();\n    for (let i = 0; i \u003c parsedHeadData.length; i++) {\n        const currentOrg = orgs.find(item =\u003e item.data.ref_key === parsedHeadData[i][\"Организация\"]);\n        if (!currentOrg)\n            continue;\n        if (!currentOrg.data.position_head) {\n            const head = allEmployees.find(emp =\u003e emp.data.individual_id_1c === parsedHeadData[i][\"Руководитель\"]);\n            if (head) {\n                currentOrg.data.position_head = head.data.position;\n            }\n        }\n        if (!currentOrg.data.signatories || currentOrg.data.signatories.length === 0) {\n            const head = allEmployees.find(emp =\u003e emp.data.individual_id_1c === parsedHeadData[i][\"Руководитель\"]);\n            if (head) {\n                currentOrg.data.signatories = [head];\n            }\n        }\n        const head = allEmployees.find(emp =\u003e emp.data.individual_id_1c === parsedHeadData[i][\"Руководитель\"]);\n        if (head) {\n            if (currentOrg.data.entity \u0026\u0026 head.data.ext_user) {\n                const orgApp = await currentOrg.data.entity.fetch();\n                orgApp.data._director = head.data.ext_user;\n                await orgApp.save();\n            }\n        }\n        const hr = allEmployees.find(emp =\u003e emp.data.individual_id_1c === parsedHeadData[i][\"РуководительКадровойСлужбы\"]);\n        if (hr) {\n            if (!currentOrg.data.position_hr) {\n                currentOrg.data.position_hr = hr.data.position;\n            }\n            if (!currentOrg.data.hr_department || currentOrg.data.hr_department.length === 0) {\n                currentOrg.data.hr_department = [hr];\n            }\n        }\n        if (!currentOrg.data.accounting || currentOrg.data.accounting.length === 0) {\n            const accounting = allEmployees.find(emp =\u003e emp.data.individual_id_1c === parsedHeadData[i][\"ГлавныйБухгалтер\"]);\n            if (accounting) {\n                currentOrg.data.accounting = [accounting];\n            }\n        }\n        if (!currentOrg.data.matching_finance || currentOrg.data.matching_finance.length === 0) {\n            const finance = allEmployees.find(emp =\u003e emp.data.individual_id_1c === parsedHeadData[i][\"Кассир\"]);\n            if (finance) {\n                currentOrg.data.matching_finance = [finance];\n            }\n        }\n        promises.push(currentOrg.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nfunction addTransferData(transferSendData, transfers) {\n    let dateNow = new TDate();\n    if (transferSendData.transferDate.after(dateNow)) {\n        let transfer = {\n            employeeIndividualId: transferSendData.employee.data.individual_id_1c,\n            typeWorkRelation: !!transferSendData.typeWorkRelation ? transferSendData.typeWorkRelation.name : \"\",\n            subdivisionId: transferSendData.subdivisionApp.data.ref_key,\n            orgId: transferSendData.orgApp.data.ref_key,\n            id_1c: transferSendData.employeeId,\n            typeFromData: transferSendData.typeFromData,\n            transferDate: transferSendData.transferDate.format(),\n            rate: transferSendData.rate,\n            posId: transferSendData.posId,\n            existingPositions: transferSendData.existingPositions,\n        };\n        transfers.push(transfer);\n        return true;\n    }\n    return false;\n}\nasync function deletePreviousPosition(employee, employmentRow, typeFromData, employeeId) {\n    if (typeFromData \u0026\u0026 employee.data.employment_table \u0026\u0026 employmentRow.type_employment.name === 'Основное место работы') {\n        let mainWorkTypes = employee.data.employment_table.filter((item) =\u003e item.type_employment.name === 'Основное место работы');\n        if (mainWorkTypes \u0026\u0026 mainWorkTypes.length \u003e 1) {\n            let rowToDelete = mainWorkTypes.find((item) =\u003e item.id_1c !== employeeId);\n            if (rowToDelete) {\n                try {\n                    employee.data.employment_table.delete(employee.data.employment_table.indexOf(rowToDelete));\n                    employee.data.id_1c = employmentRow.id_1c;\n                    await employee.setStatus(employee.fields.__status.variants.new);\n                    await employee.save();\n                }\n                catch (e) {\n                    Context.data.error_stack += ` Не удалось удалить предыдущее основное место работы `;\n                }\n            }\n        }\n    }\n}\nasync function findFixedTermOrTemporaryTransferData(positions) {\n    const fixedtermData = positions.filter((item) =\u003e {\n        return !!item.data[\"Record\"];\n    }).map((data) =\u003e {\n        return data.data[\"Record\"];\n    }).flat().filter((item) =\u003e {\n        return item[\"ВидЗанятостиПозиции\"] !== \"Совмещена\" \u0026\u0026 item[\"Active\"] \u0026\u0026 (!(item[\"ПланируемаяДатаЗавершения\"].includes(\"0001\")) || (!item[\"ДействуетДо\"].includes(\"0001\")));\n    });\n    let mappedFixedTermData = [];\n    let i = -1;\n    for (let item of fixedtermData) {\n        i++;\n        let endDate = item[\"ПланируемаяДатаЗавершения\"];\n        if (!endDate || (endDate \u0026\u0026 endDate.includes(\"0001\"))) {\n            endDate = item[\"ДействуетДо\"];\n        }\n        const employee = await Namespace.app.staff.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.individual_id_1c.eq(item[\"ФизическоеЛицо\"]))).first();\n        if (employee \u0026\u0026 employee.data.employment_table) {\n            let row = employee.data.employment_table.find((elem) =\u003e elem.id_1c === item[\"Сотрудник\"]);\n            if (row \u0026\u0026 row.position) {\n                let posApp = await row.position.fetch();\n                let elem = {\n                    employeeIndividualId: employee.data.individual_id_1c,\n                    employeeId: row.id_1c,\n                    endDate: endDate,\n                    prevPositionId: posApp.data.ref_key,\n                    prevPositionDate: row.admission_date_position.format(),\n                    isMainWorktype: row.type_employment.name === \"Основное место работы\" ? true : false,\n                };\n                mappedFixedTermData.push(elem);\n            }\n        }\n    }\n    ;\n    return mappedFixedTermData;\n}\nfunction returnTransferDataElement(mappedFixedTermData, updatedTransferData) {\n    let updatedTransferDataElement;\n    let temporary = mappedFixedTermData.find(item =\u003e item.employeeId === updatedTransferData.employeeId);\n    if (temporary) {\n        updatedTransferDataElement = {\n            employeeId: updatedTransferData.employeeId,\n            employeeIndividualId: updatedTransferData.employeeIndividualId,\n            isTemporaryTransfer: true,\n            endTransferDate: updatedTransferData.endTransferDate,\n            newPositionId: updatedTransferData.newPositionId,\n            employmentDirectoryId: updatedTransferData.employmentDirectoryId\n        };\n    }\n    else {\n        updatedTransferDataElement = {\n            employeeId: updatedTransferData.employeeId,\n            employeeIndividualId: updatedTransferData.employeeIndividualId,\n            isTemporaryTransfer: false,\n            newPositionId: updatedTransferData.newPositionId,\n            employmentDirectoryId: updatedTransferData.employmentDirectoryId\n        };\n    }\n    ;\n    return updatedTransferDataElement;\n}\nasync function addWorkData(positions) {\n    var _a;\n    let updatedTransferData = [];\n    let transfers = [];\n    const filteredPosData = positions.filter((item) =\u003e {\n        return !!item.data[\"Record\"];\n    }).map((data) =\u003e {\n        return data.data[\"Record\"];\n    }).flat().filter((item) =\u003e {\n        return item[\"ВидЗанятостиПозиции\"] !== \"Совмещена\" \u0026\u0026 item[\"Active\"];\n    });\n    const personsIds = filteredPosData.map((item) =\u003e {\n        return item[\"ФизическоеЛицо\"];\n    });\n    let mappedFixedTermData = await findFixedTermOrTemporaryTransferData(positions);\n    Context.data.fixedterm_data = JSON.stringify(mappedFixedTermData);\n    const allPositions = await Namespace.app.position.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allEmployees = await Context.fields.staff.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n    let promises = [];\n    if (personsIds.length === 0) {\n        Context.data.debug += ` personsIds.length === 0 `;\n        return;\n    }\n    const mainWorkCategory = Context.fields.staff.app.fields.employment_table.fields.type_employment.variants.main_workplace;\n    const allNeededEmployees = allEmployees.filter(employee =\u003e {\n        let found = false;\n        const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n        if (personsIds \u0026\u0026 personsIds.indexOf(employee.data.individual_id_1c) !== -1) {\n            found = true;\n        }\n        if (!found \u0026\u0026 ids) {\n            for (let id of ids) {\n                if (personsIds \u0026\u0026 personsIds.indexOf(id) !== -1) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n        return found;\n    });\n    for (let employee of allNeededEmployees) {\n        Context.data.debug += employee.data.__name;\n        const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n        let allEmploymentsAndTransfers = filteredPosData.filter((item) =\u003e !!item[\"ФизическоеЛицо\"]).filter((item) =\u003e {\n            return item[\"ФизическоеЛицо\"] === employee.data.individual_id_1c || (!!ids \u0026\u0026 ids.indexOf(item[\"ФизическоеЛицо\"]) !== -1);\n        });\n        const existingPositions = (_a = employee.data.employment_table) === null || _a === void 0 ? void 0 : _a.map(item =\u003e {\n            if (item.position \u0026\u0026 item.position.id)\n                return item.position.id;\n        });\n        let rate = 0;\n        for (let i = 0; i \u003c allEmploymentsAndTransfers.length; i++) {\n            const currentEmployment = allEmploymentsAndTransfers[i];\n            if (currentEmployment[\"ВидЗанятостиПозиции\"] !== 'Занята') {\n                continue;\n            }\n            const employeeId = currentEmployment[\"Сотрудник\"];\n            try {\n                rate += currentEmployment[\"КоличествоСтавок\"];\n            }\n            catch (e) {\n                rate += 1;\n            }\n            let pos = undefined;\n            if (currentEmployment) {\n                pos = allPositions.find(item =\u003e item.data.ref_key === currentEmployment[\"ПозицияШтатногоРасписания\"]);\n            }\n            if (!pos) {\n                Context.data.debug += ' Не загружена позиция для ' + employee.data.__name;\n                continue;\n            }\n            const org = pos.data.organization;\n            let orgApp = await org.fetch();\n            Context.data.debug += ` ${pos.data.__name} ${currentEmployment[\"Period\"]} ${orgApp.data.__name} `;\n            const subdivision = pos.data.subdivision;\n            let typeWorkRelation;\n            let subdivisionApp = await subdivision.fetch();\n            let posApp = await pos.fetch();\n            let historyDatetime = new Datetime(currentEmployment[\"Period\"]);\n            let historyDate = new TDate(historyDatetime.year, historyDatetime.month, historyDatetime.day);\n            let employmentRow;\n            if (existingPositions) {\n                Context.data.debug += ` существует позиция `;\n                employmentRow = employee.data.employment_table.find((item) =\u003e employeeId \u0026\u0026 item.id_1c \u0026\u0026 item.id_1c === employeeId);\n                if (employmentRow \u0026\u0026 employmentRow.admission_date_position \u0026\u0026 employmentRow.admission_date_position.after(historyDate)) {\n                    Context.data.error_stack += ` ${employee.data.__name} ${currentEmployment[\"ПозицияШтатногоРасписания\"]} ${historyDate.format()} в строке ${employmentRow.admission_date_position.format()} - устаревшая информация `;\n                    Context.data.debug += ` ${employee.data.__name} ${currentEmployment[\"ПозицияШтатногоРасписания\"]} ${historyDate.format()} в строке ${employmentRow.admission_date_position.format()} - устаревшая информация `;\n                    continue;\n                }\n                if (!employmentRow) {\n                    Context.data.debug += ` не нашли строку в таблице  `;\n                    employmentRow = employee.data.employment_table.insert();\n                }\n            }\n            else {\n                employmentRow = employee.data.employment_table.insert();\n            }\n            if (!employmentRow \u0026\u0026 pos \u0026\u0026 pos.id) {\n                Context.data.error_stack += \" Не нашли строку с позицией \" + pos.id;\n                continue;\n            }\n            let empRow = employee.data.employment_table.find(item =\u003e item.id_1c === employeeId);\n            let employmentDirectory = undefined;\n            if (empRow) {\n                employmentDirectory = empRow.employment_placement_app;\n            }\n            ;\n            let updatedTransferDataInfo = {\n                employeeId: employeeId,\n                employeeIndividualId: employee.data.individual_id_1c,\n                endTransferDate: historyDate.format(),\n                newPositionId: currentEmployment[\"ПозицияШтатногоРасписания\"],\n                employmentDirectoryId: employmentDirectory ? employmentDirectory.id : undefined,\n                isTemporaryTransfer: false\n            };\n            typeWorkRelation = employmentRow.type_employment;\n            if (!typeWorkRelation) {\n                typeWorkRelation = mainWorkCategory;\n            }\n            let typeFromData = false;\n            if (!employmentRow.position) {\n                typeFromData = true;\n            }\n            if (!typeFromData) {\n                let updatedTransferDataElement = returnTransferDataElement(mappedFixedTermData, updatedTransferDataInfo);\n                updatedTransferData.push(updatedTransferDataElement);\n            }\n            let transferSendData = {\n                employee: employee,\n                transferDate: historyDate,\n                subdivisionApp: subdivisionApp,\n                orgApp: orgApp,\n                posId: currentEmployment[\"ПозицияШтатногоРасписания\"],\n                typeWorkRelation: typeWorkRelation,\n                employeeId: employeeId,\n                typeFromData: typeFromData,\n                rate: currentEmployment[\"КоличествоСтавок\"],\n                existingPositions: !!existingPositions\n            };\n            let isTransferData = addTransferData(transferSendData, transfers);\n            if (isTransferData) {\n                let updatedTransferDataElement = returnTransferDataElement(mappedFixedTermData, updatedTransferDataInfo);\n                updatedTransferData.push(updatedTransferDataElement);\n                continue;\n            }\n            if (!isActualData(employee, employeeId, posApp, historyDate)) {\n                return;\n            }\n            try {\n                if (typeWorkRelation \u0026\u0026 typeWorkRelation.name === mainWorkCategory.name) {\n                    employee.data.employment_type = mainWorkCategory;\n                    employee.data.id_1c = employeeId;\n                }\n            }\n            catch (e) {\n                Context.data.value_3 = `${employee.data.__name}`;\n            }\n            employmentRow.id_1c = employeeId;\n            if (org) {\n                employmentRow.organization = org;\n            }\n            if (pos) {\n                employmentRow.position = pos;\n            }\n            if (subdivision) {\n                employmentRow.subdivision = subdivision;\n            }\n            Context.data.debug += ` employmentRow.type_employment ${!!employmentRow.type_employment} `;\n            employmentRow.admission_date_position = historyDate;\n            try {\n                employmentRow.rate = currentEmployment[\"КоличествоСтавок\"];\n            }\n            catch (e) {\n                employmentRow.rate = 1;\n            }\n            try {\n                if (employmentRow \u0026\u0026 employmentRow.type_employment \u0026\u0026 employmentRow.type_employment.name === mainWorkCategory.name) {\n                    if (pos) {\n                        employee.data.position = pos;\n                    }\n                    if (subdivision) {\n                        employee.data.structural_subdivision = subdivision;\n                    }\n                    if (org) {\n                        employee.data.organization = org;\n                        const orgApp = await org.fetch();\n                        employee.data.entity = orgApp.data.entity;\n                    }\n                    employee.data.employment_type = mainWorkCategory;\n                    employee.data.id_1c = employeeId;\n                }\n            }\n            catch (e) {\n                Context.data.value_3 = `${employee.data.__name}`;\n            }\n            try {\n                await deletePreviousPosition(employee, employmentRow, typeFromData, employeeId);\n            }\n            catch (e) {\n                Context.data.value_3 = `${employee.data.__name}`;\n            }\n        }\n        employee.data.rate = rate;\n        promises.push(employee.save());\n        if (Context.data.created_staffs.indexOf(employee) !== -1) {\n            Context.data.created_staffs.push(employee);\n        }\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    if (transfers.length \u003e 0) {\n        Context.data.transfers = JSON.stringify(transfers);\n    }\n    if (updatedTransferData.length \u003e 0) {\n        Context.data.data_for_update_positions = JSON.stringify(updatedTransferData);\n    }\n    await Promise.all(promises);\n    promises = [];\n}\nasync function addDocumentData(documents) {\n    const filteredData = documents.filter((item) =\u003e {\n        return !!item.data[\"Record\"] \u0026\u0026 item.data[\"Record\"][0][\"Представление\"].includes(\"Паспорт\");\n    }).map((item) =\u003e item.data[\"Record\"][0]);\n    let personsIds = filteredData.map((item) =\u003e {\n        return item[\"Физлицо\"];\n    });\n    if (personsIds.length == 0) {\n        return;\n    }\n    let allEmployees;\n    try {\n        allEmployees = await Namespace.app.staff.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.individual_id_1c.in(personsIds))).size(10000).all();\n    }\n    catch (e) {\n        personsIds = personsIds.map((item) =\u003e {\n            return item[\"data\"];\n        });\n        if (personsIds.length == 0) {\n            return;\n        }\n        Context.data.debug += ` ${JSON.stringify(personsIds)} `;\n        allEmployees = await Namespace.app.staff.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.individual_id_1c.in(personsIds))).size(10000).all();\n    }\n    let promises = [];\n    for (let employee of allEmployees) {\n        let found = false;\n        const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n        for (let id of ids) {\n            if (personsIds.indexOf(id) !== -1 || personsIds.indexOf(employee.data.individual_id_1c)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            continue;\n        }\n        let docDataTable = filteredData.filter((item) =\u003e !!item[\"Физлицо\"]).filter((item) =\u003e {\n            const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n            return item[\"Физлицо\"] === employee.data.individual_id_1c || ids.indexOf(item[\"Физлицо\"]) !== -1;\n        });\n        if (!docDataTable || docDataTable.length == 0) {\n            docDataTable = docDataTable = filteredData.filter((item) =\u003e !!item[\"Физлицо\"][\"data\"]).filter((item) =\u003e {\n                const ids = employee.data.ref_eq_table.map((elem) =\u003e elem.individual_ref);\n                return item[\"Физлицо\"][\"data\"] === employee.data.individual_id_1c || ids.indexOf(item[\"Физлицо\"][\"data\"]) !== -1;\n            });\n            Context.data.debug += ` ${JSON.stringify(docDataTable)} `;\n            if (!docDataTable || docDataTable.length == 0) {\n                continue;\n            }\n        }\n        ;\n        const sortedPassports = docDataTable.sort((a, b) =\u003e {\n            const aDate = new Date(a[\"Period\"]);\n            const bDate = new Date(b[\"Period\"]);\n            return bDate - aDate;\n        });\n        const docData = sortedPassports[0];\n        const [issueYear, issueMonth, issueDay] = docData[\"ДатаВыдачи\"].split(\"T\")[0].split(\"-\").map((item) =\u003e parseInt(item));\n        const passport = {\n            isRf: docData[\"Представление\"].includes(\"Паспорт гражданина РФ\") || docData[\"Представление\"].includes(\"Паспорт гражданина Российской Федерации\"),\n            passportSeries: docData[\"Серия\"].replace(/\\s/g, ''),\n            passportNumber: docData[\"Номер\"],\n            passportDepCode: docData[\"КодПодразделения\"],\n            passportIssueDate: new TDate(issueYear, issueMonth, issueDay),\n            passportIssuer: docData[\"КемВыдан\"],\n        };\n        if (employee.data.date_of_issue \u0026\u0026 passport.passportIssueDate) {\n            if (employee.data.date_of_issue.after(passport.passportIssueDate)) {\n                Context.data.error_stack += ` ${employee.data.__name} outdated information `;\n                Context.data.debug += ` ${employee.data.__name} outdated information `;\n                continue;\n            }\n        }\n        employee.data.passport_series = passport.passportSeries;\n        employee.data.russian_passport = passport.isRf;\n        employee.data.passport_number = passport.passportNumber;\n        employee.data.passport_department_code = passport.passportDepCode.length === 6 ? passport.passportDepCode.slice(0, 3) + \"-\" + passport.passportDepCode.slice(3) : passport.passportDepCode.replace(\" \", \"\");\n        employee.data.date_of_issue = passport.passportIssueDate;\n        employee.data.issued_by = passport.passportIssuer;\n        promises.push(employee.save());\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function createBaseEmployees(employees, persons, types = undefined) {\n    var _a, _b, _c, _d;\n    let mappedData;\n    let acceptData;\n    let fireData;\n    if (types) {\n        mappedData = types.filter((item) =\u003e !!item.data[\"Record\"]).map((item) =\u003e item.data[\"Record\"]).flat().filter((item) =\u003e item[\"Active\"] \u0026\u0026 item[\"КоличествоСтавок\"] === 1);\n        acceptData = mappedData.filter((item) =\u003e item[\"ВидСобытия\"] === \"НачальныеДанные\" || item[\"ВидСобытия\"] === \"Прием\" || item[\"ВидСобытия\"] === \"Перемещение\");\n        fireData = mappedData.filter((item) =\u003e item[\"ВидСобытия\"] === \"Увольнение\");\n    }\n    const personsIds = persons.filter((item) =\u003e !!item.data[\"ИНН\"]).map((item) =\u003e item.data[\"ИНН\"]);\n    if (personsIds.length == 0) {\n        return;\n    }\n    const allEmployees = await Context.fields.staff.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.inn.in(personsIds))).size(10000).all();\n    const defaultCategory = await Namespace.app.employees_categories.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.code.eq(\"default\"))).first();\n    let promises = [];\n    const processedIds = [];\n    for (let i = persons.length - 1; i \u003e= 0; i--) {\n        const person = persons[i].data;\n        if (types) {\n            let found_accept_data = acceptData.filter((elem) =\u003e elem[\"ФизическоеЛицо\"] === person[\"Ref\"]);\n            let found_fire_data = fireData.filter((elem) =\u003e elem[\"ФизическоеЛицо\"] === person[\"Ref\"]);\n            if (found_accept_data \u0026\u0026 found_accept_data.length \u003e 0 \u0026\u0026 found_fire_data \u0026\u0026 found_fire_data.length \u003e 0) {\n                Context.data.debug += ` in 1 `;\n                let last_accept_date = new TDate(1, 1, 1);\n                let last_fire_date = new TDate(1, 1, 1);\n                for (let found_data of found_accept_data) {\n                    Context.data.debug += ` a ${found_data[\"Period\"]} `;\n                    let datetime = new Datetime(found_data[\"Period\"]);\n                    let date = new TDate(datetime.year, datetime.month, datetime.day);\n                    if (date \u0026\u0026 date.after(last_accept_date)) {\n                        last_accept_date = date;\n                    }\n                }\n                for (let found_data of found_fire_data) {\n                    Context.data.debug += ` f ${found_data[\"Period\"]} `;\n                    let datetime = new Datetime(found_data[\"Period\"]);\n                    let date = new TDate(datetime.year, datetime.month, datetime.day);\n                    if (date \u0026\u0026 date.after(last_fire_date)) {\n                        last_fire_date = date;\n                    }\n                }\n                Context.data.debug += ` fdate ${last_fire_date.day}.${last_fire_date.month}.${last_fire_date.year} `;\n                Context.data.debug += ` fdate ${last_accept_date.day}.${last_accept_date.month}.${last_accept_date.year} `;\n                if (last_fire_date.after(last_accept_date)) {\n                    Context.data.error_stack += ` ${person['Description']} не был загружен, так как он принят и уволен по основному месту работы `;\n                    continue;\n                }\n            }\n        }\n        const isProcessed = !!(processedIds.find((inn) =\u003e inn === person[\"ИНН\"]));\n        if (isProcessed)\n            continue;\n        let createNew = false;\n        let employeeId = \"\";\n        let employeeCode = \"\";\n        if (person[\"ИНН\"] === \"\") {\n            continue;\n        }\n        let currentEmployee = allEmployees.find(e =\u003e e.data.inn === person[\"ИНН\"]);\n        if (!currentEmployee) {\n            const currentEmployee = (_a = employees.find((item) =\u003e person.Ref === item.data[\"ФизическоеЛицо\"])) === null || _a === void 0 ? void 0 : _a.data;\n            if (!currentEmployee) {\n                Context.data.error_stack += `для физического лица ${person[\"Description\"]} ${person[\"ИНН\"]} не найден сотрудник`;\n            }\n            else {\n                employeeId = currentEmployee[\"Ref\"];\n                employeeCode = currentEmployee[\"Code\"];\n            }\n            createNew = true;\n        }\n        else {\n            Context.data.debug += ` ${person[\"ИНН\"]} found ${currentEmployee.data.id_1c}`;\n            employeeId = currentEmployee.data.id_1c;\n            employeeCode = currentEmployee.data.personal_number;\n        }\n        const addressField = (_b = person[\"КонтактнаяИнформация\"]) === null || _b === void 0 ? void 0 : _b.find((info) =\u003e info[\"Тип\"] === \"Адрес\");\n        let addressObj = {};\n        if (!!addressField) {\n            if (addressField[\"Значение\"] !== \"\") {\n                addressObj = addressField[\"Значение\"] ? JSON.parse(addressField[\"Значение\"]) : {};\n            }\n            else {\n                const extractAddressInfo = (input) =\u003e {\n                    const regex = /(?:г(?:ор(?:од)?)?)?\\s*(?:п\\.?|пос\\.?|посёлок|поселок|с\\.?|село|пгт|дер\\.?|д\\.?)?\\s*([^\\d,]+),\\s*ул\\.?\\s*([^\\d,]+),\\s*д(?:ом)?\\.?\\s*(\\d+),\\s*кв\\.?\\s*(\\d+)/;\n                    const match = input.match(regex);\n                    if (match) {\n                        const cityIndex = 1;\n                        const streetIndex = 2;\n                        const houseIndex = 3;\n                        const apartmentIndex = 4;\n                        const city = match[cityIndex].trim();\n                        const street = match[streetIndex].trim();\n                        const house = match[houseIndex].trim();\n                        const apartment = match[apartmentIndex].trim();\n                        const result = {\n                            \"city\": city,\n                            \"street\": street,\n                            \"houseNumber\": house,\n                            \"apartments\": [{ \"number\": apartment }],\n                        };\n                        return result;\n                    }\n                    else {\n                        return new Object;\n                    }\n                };\n                addressObj = extractAddressInfo(addressField[\"Представление\"]);\n            }\n        }\n        const email = (_c = person[\"КонтактнаяИнформация\"]) === null || _c === void 0 ? void 0 : _c.find((info) =\u003e info[\"Тип\"] === \"АдресЭлектроннойПочты\");\n        const phoneNumber = (_d = person[\"КонтактнаяИнформация\"]) === null || _d === void 0 ? void 0 : _d.find((info) =\u003e { var _a; return info[\"Тип\"] === \"Телефон\" \u0026\u0026 ((_a = info[\"Представление\"]) === null || _a === void 0 ? void 0 : _a.length) \u003e= 11; });\n        let birthYear = undefined;\n        let birthMonth = undefined;\n        let birthDay = undefined;\n        try {\n            [birthYear, birthMonth, birthDay] = person[\"ДатаРождения\"].split(\"T\")[0].split(\"-\").map((item) =\u003e parseInt(item));\n        }\n        catch (e) {\n            Context.data.error_stack += \"Couldn't parse date \" + person[\"ДатаРождения\"];\n        }\n        const singleEmployeeData = {\n            id: employeeId,\n            code: employeeCode,\n            individual_id: person[\"Ref\"],\n            name: {\n                firstname: person[\"Имя\"],\n                lastname: person[\"Фамилия\"],\n                middlename: person[\"Отчество\"],\n            },\n            firstname: person[\"Имя\"],\n            lastname: person[\"Фамилия\"],\n            middlename: person[\"Отчество\"],\n            email: email ? {\n                email: email[\"Представление\"],\n                type: EmailType.Work,\n            } : undefined,\n            phoneNumber: phoneNumber ? {\n                tel: formatPhoneNumber(phoneNumber[\"Представление\"]),\n                type: PhoneType.Work,\n            } : undefined,\n            sex: person[\"Пол\"] === \"Мужской\" ? true : false,\n            marriage: false,\n            city: (addressObj === null || addressObj === void 0 ? void 0 : addressObj.city) || (addressObj === null || addressObj === void 0 ? void 0 : addressObj.locality) || (addressObj === null || addressObj === void 0 ? void 0 : addressObj.area),\n            street: (addressObj === null || addressObj === void 0 ? void 0 : addressObj.street) || undefined,\n            home: addressObj === null || addressObj === void 0 ? void 0 : addressObj.houseNumber,\n            apartment: (addressObj === null || addressObj === void 0 ? void 0 : addressObj.apartments) \u0026\u0026 addressObj.apartments.length \u003e 0 ? addressObj.apartments[0].number : undefined,\n            housing: (addressObj === null || addressObj === void 0 ? void 0 : addressObj.buildings) \u0026\u0026 addressObj.buildings.length \u003e 0 ? addressObj.buildings[0].number : undefined,\n            snils: person[\"СтраховойНомерПФР\"],\n            inn: person[\"ИНН\"],\n        };\n        if (birthDay \u0026\u0026 birthMonth \u0026\u0026 birthYear) {\n            singleEmployeeData.birthDate = new TDate(birthYear, birthMonth, birthDay);\n        }\n        if (createNew || !currentEmployee) {\n            currentEmployee = Context.fields.staff.app.create();\n            currentEmployee.data.id_1c = singleEmployeeData.id;\n            currentEmployee.data.user_already_exists = false;\n            currentEmployee.data.personal_number = singleEmployeeData.code;\n            currentEmployee.data.individual_id_1c = singleEmployeeData.individual_id;\n            let row = currentEmployee.data.ref_eq_table.insert();\n            row.individual_ref = singleEmployeeData.individual_id;\n            if (!!defaultCategory) {\n                const newRow = currentEmployee.data.categories_table.insert();\n                newRow.staff_categories = defaultCategory;\n                currentEmployee.data.staff_categories = [defaultCategory];\n            }\n        }\n        const individualIds = currentEmployee.data.ref_eq_table.map((item) =\u003e item.individual_ref);\n        if (individualIds.indexOf(singleEmployeeData.individual_id) === -1) {\n            let row = currentEmployee.data.ref_eq_table.insert();\n            row.individual_ref = singleEmployeeData.individual_id;\n        }\n        if (!!singleEmployeeData.name) {\n            currentEmployee.data.full_name = singleEmployeeData.name;\n        }\n        if (!!singleEmployeeData.firstname) {\n            currentEmployee.data.name = singleEmployeeData.firstname;\n        }\n        if (!!singleEmployeeData.lastname) {\n            currentEmployee.data.surname = singleEmployeeData.lastname;\n        }\n        if (!!singleEmployeeData.middlename) {\n            currentEmployee.data.middlename = singleEmployeeData.middlename;\n        }\n        if (!!singleEmployeeData.email) {\n            currentEmployee.data.email = singleEmployeeData.email;\n        }\n        if (!!singleEmployeeData.phoneNumber) {\n            currentEmployee.data.phone = singleEmployeeData.phoneNumber;\n        }\n        if (singleEmployeeData.sex === true) {\n            currentEmployee.data.sex = singleEmployeeData.sex;\n        }\n        else {\n            currentEmployee.data.sex = false;\n        }\n        if (!!singleEmployeeData.birthDate) {\n            currentEmployee.data.date_of_birth = singleEmployeeData.birthDate;\n        }\n        if (!!singleEmployeeData.city) {\n            currentEmployee.data.city = singleEmployeeData.city;\n        }\n        if (!!singleEmployeeData.street) {\n            currentEmployee.data.street = singleEmployeeData.street;\n        }\n        if (!!singleEmployeeData.home) {\n            currentEmployee.data.home = singleEmployeeData.home;\n        }\n        if (!!singleEmployeeData.apartment) {\n            currentEmployee.data.apartment = singleEmployeeData.apartment;\n        }\n        if (!!singleEmployeeData.housing) {\n            currentEmployee.data.housing = singleEmployeeData.housing;\n        }\n        if (!!singleEmployeeData.snils) {\n            currentEmployee.data.snils = singleEmployeeData.snils;\n        }\n        if (!!singleEmployeeData.inn) {\n            if (!currentEmployee.data.inn) {\n                currentEmployee.data.inn = singleEmployeeData.inn;\n            }\n        }\n        const address = `\n                ${singleEmployeeData.city ? singleEmployeeData.city : \"\"}\n                ${singleEmployeeData.street ? \", ул. \" + singleEmployeeData.street : \"\"}\n                ${singleEmployeeData.home ? \", д. \" + singleEmployeeData.home : \"\"}\n                ${singleEmployeeData.housing ? \", корп. \" + singleEmployeeData.housing : \"\"}\n                ${singleEmployeeData.apartment ? \", кв. \" + singleEmployeeData.apartment : \"\"}\n            `;\n        currentEmployee.data.address = address;\n        currentEmployee.data.registration_address = address;\n        Context.data.created_staffs.push(currentEmployee);\n        promises.push(currentEmployee.save());\n        if (currentEmployee.data.inn) {\n            processedIds.push(currentEmployee.data.inn);\n        }\n        if (promises.length \u003e= littleChunkSize) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function loadAdditionalOrgData() {\n    const searchData = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.table_name.eq(\"InformationRegister_СведенияОбОтветственныхЛицах\")))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .size(10000).all();\n    if (!searchData || searchData.length === 0) {\n        return;\n    }\n    const sortedApps = searchData.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const data = parseData(sortedApps, \"InformationRegister_СведенияОбОтветственныхЛицах\");\n    const personIds = [];\n    const orgIds = [];\n    for (let i = 0; i \u003c data.length; i++) {\n        const id = data[i].data.Record[0];\n    }\n}\nclass MyRole {\n    constructor(group, type, code) {\n        this.code = code;\n        this.group = group;\n        this.type = type;\n    }\n    getUsers() {\n        if (this.type == \"group\") {\n            return this.group.users();\n        }\n        else if (this.type == \"orgstruct\") {\n            return System.users.search().where(i =\u003e i.osIds.has(this.group)).size(10000).all();\n        }\n        else\n            return new Promise(() =\u003e this.group);\n    }\n    json() {\n        return {\n            code: this.code,\n            type: this.type\n        };\n    }\n}\nasync function splitStaff() {\n    Context.data.new_staff_exists = true;\n    const staffs = await Context.fields.created_staffs.fetchAll();\n    Context.data.debug += ` ${staffs.length} `;\n    const allOrgs = await Namespace.app.organization.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allOrgRights = await Namespace.app.access_settings_organization.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    let staffMeta = [];\n    let accessSettingsIds = [];\n    for (let staff of staffs) {\n        let isArray = false;\n        if (staff.data.employment_table \u0026\u0026 staff.data.employment_table.length \u003e 1) {\n            isArray = true;\n            const staffOrgsIds = staff.data.employment_table.map(row =\u003e row.organization.id);\n            const staffOrgs = allOrgs.filter(org =\u003e staffOrgsIds.indexOf(org.id) != -1 \u0026\u0026 org.data.access_settings_organization);\n            accessSettingsIds = staffOrgs.map(org =\u003e org.data.access_settings_organization.id);\n        }\n        let org = allOrgs.find(o =\u003e { var _a; return o.id === ((_a = staff.data.organization) === null || _a === void 0 ? void 0 : _a.id); });\n        if (!org) {\n            if (staff.data.employment_table \u0026\u0026 staff.data.employment_table.length \u003e 0) {\n                const staffOrgsIds = staff.data.employment_table.map(row =\u003e row.organization.id);\n                if (staffOrgsIds \u0026\u0026 staffOrgsIds.length \u003e 0) {\n                    org = allOrgs.find(o =\u003e o.id === staffOrgsIds[0]);\n                }\n            }\n        }\n        ;\n        if (!org) {\n            Context.data.debug += ` no org `;\n            continue;\n        }\n        const orgRights = allOrgRights.find(right =\u003e { var _a; return right.id === ((_a = org.data.access_settings_organization) === null || _a === void 0 ? void 0 : _a.id); });\n        if (!orgRights) {\n            Context.data.debug += ` no orgRights `;\n            continue;\n        }\n        ;\n        const rightsField = orgRights.data.staff;\n        if (!rightsField || rightsField.length \u003c 1) {\n            Context.data.debug += ` no rightsField `;\n            continue;\n        }\n        ;\n        staffMeta.push({\n            staffId: staff.id,\n            orgRightsIds: isArray ? accessSettingsIds : orgRights.id,\n            isArray\n        });\n    }\n    ;\n    let chunks = [];\n    for (let i = 0; i \u003c staffMeta.length; i += chunkSize) {\n        const chunk = staffMeta.slice(i, i = chunkSize);\n        chunks.push(chunk);\n    }\n    ;\n    Context.data.max_iteration = chunks.length;\n    Context.data.chunks = chunks;\n    if (chunks.length == 0) {\n        Context.data.debug += ` no new staff `;\n        Context.data.new_staff_exists = false;\n    }\n    ;\n}\nasync function set_access_groups() {\n    const staffs = await Context.fields.created_staffs.fetchAll();\n    const access_groups = await Namespace.app.access_settings_organization.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(1000).all();\n    const userGroups = await System.userGroups.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const chunk = Context.data.chunks[Context.data.iteration];\n    const promises = [];\n    for (const item of chunk) {\n        try {\n            const staff = staffs.find(s =\u003e s.id === item.staffId);\n            let accessRoles = [];\n            if (item.isArray) {\n                accessRoles = access_groups.filter(gr =\u003e item.orgRightsIds.indexOf(gr.id) !== -1).map(access =\u003e {\n                    const userGroup = userGroups.find(group =\u003e group.id === access.data.staff[0].code);\n                    return new MyRole(userGroup, \"group\", userGroup.id);\n                });\n            }\n            else {\n                const access_group = access_groups.find(gr =\u003e gr.id === item.orgRightsIds);\n                const roleGroup = userGroups.find(f =\u003e f.data.__id == access_group.data.staff[0].code);\n                const newRole = new MyRole(roleGroup, \"group\", roleGroup.id);\n                accessRoles.push(newRole);\n            }\n            Context.data.debug += ` добавили группы ${accessRoles.length} `;\n            staff.data.access_group = accessRoles;\n            promises.push(staff.save());\n        }\n        catch (e) {\n            Context.data.error_stack += ` Не смогли добавить группы поступа ${e.message} `;\n        }\n    }\n    ;\n    await Promise.all(promises);\n    if (Context.data.iteration === Context.data.max_iteration - 1) {\n        Context.data.all_staff_processed = true;\n    }\n    else {\n        Context.data.iteration++;\n    }\n}\n;\nasync function fillVarsForFixedterm() {\n    if (!Context.data.fixedterm_data) {\n        Context.data.loop_end = true;\n        return;\n    }\n    const data = JSON.parse(Context.data.fixedterm_data);\n    Context.data.iterator++;\n    if (Context.data.iterator % loopSize === 0 \u0026\u0026 Context.data.iterator !== 0) {\n        Context.data.is_pause = true;\n    }\n    else {\n        Context.data.is_pause = false;\n    }\n    if (Context.data.iterator \u003e= data.length) {\n        Context.data.loop_end = true;\n        return;\n    }\n    let endDate = new Datetime(data[Context.data.iterator].endDate);\n    let prevPosDate = new Datetime(data[Context.data.iterator].prevPositionDate);\n    const employee = await Namespace.app.staff.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.individual_id_1c.eq(data[Context.data.iterator].employeeIndividualId))).first();\n    const position = await Namespace.app.position.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ref_key.eq(data[Context.data.iterator].prevPositionId))).first();\n    Context.data.current_employee = employee;\n    Context.data.end_transfer_date = new TDate(endDate.year, endDate.month, endDate.day);\n    Context.data.employee_id = data[Context.data.iterator].employeeId;\n    Context.data.prev_position = position;\n    Context.data.prev_position_date = new TDate(prevPosDate.year, prevPosDate.month, prevPosDate.day);\n    Context.data.is_main_worktype = data[Context.data.iterator].isMainWorktype;\n}\nasync function fillPositionTransitions() {\n    if (!Context.data.data_for_update_positions) {\n        Context.data.debug += ` ${!Context.data.data_for_update_positions} `;\n        Context.data.loop_end = true;\n        return;\n    }\n    Context.data.iterator++;\n    let updatedTransferData = JSON.parse(Context.data.data_for_update_positions);\n    Context.data.max_iteration = updatedTransferData.length;\n    Context.data.debug += ` updatedTransferData.length ${updatedTransferData.length} `;\n    if (Context.data.iterator \u003e= Context.data.max_iteration) {\n        Context.data.loop_end = true;\n        return;\n    }\n    if (Context.data.iterator % loopSize === 0 \u0026\u0026 Context.data.iterator !== 0) {\n        Context.data.is_pause = true;\n    }\n    else {\n        Context.data.is_pause = false;\n    }\n    let employee = await Namespace.app.staff.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.individual_id_1c.eq(updatedTransferData[Context.data.iterator].employeeIndividualId))).first();\n    let pos = await Namespace.app.position.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ref_key.eq(updatedTransferData[Context.data.iterator].newPositionId))).first();\n    let empDir = await Namespace.app.employment_directory.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.eq(updatedTransferData[Context.data.iterator].employmentDirectoryId))).first();\n    Context.data.current_employee = employee;\n    Context.data.new_position = pos;\n    Context.data.employment_directory = empDir;\n    Context.data.is_temporary = updatedTransferData[Context.data.iterator].isTemporaryTransfer;\n    Context.data.end_transfer_date = undefined;\n    if (updatedTransferData[Context.data.iterator].hasOwnProperty(\"endTransferDate\")) {\n        let datetime = new Datetime(updatedTransferData[Context.data.iterator].endTransferDate);\n        Context.data.end_transfer_date = new TDate(datetime.year, datetime.month, datetime.day);\n    }\n}\nasync function clearVars() {\n    Context.data.loop_end = false;\n    Context.data.current_employee = undefined;\n    Context.data.firing_date = undefined;\n    Context.data.is_pause = false;\n    Context.data.iterator = -1;\n    Context.data.end_transfer_date = undefined;\n}\nfunction formatPhoneNumber(phoneNumber, plus = true) {\n    const startsWith = plus ? '+7' : '8';\n    let phone = phoneNumber.replace(/[^0-9]/g, '');\n    if (phone.startsWith('7') \u0026\u0026 plus) {\n        phone = phone.substring(1);\n    }\n    if (phone.startsWith('8')) {\n        phone = phone.substring(1);\n    }\n    return phone.replace(/(\\d{3})(\\d{3})(\\d{2})(\\d{2})/g, `${startsWith}$1$2$3$4`);\n}\n","gatewayPairs":{},"hasTranslations":false}
