{"scripts":"const CHUNK_SIZE = 20;\nasync function get_kedo_settings() {\n    const settings = await Namespace.app.settings.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const integration_1c = settings.find(f =\u003e f.data.code == 'integration_1c');\n    Context.data.integration_1c = integration_1c ? integration_1c.data.status : false;\n    const alternative_integration_1c = settings.find(f =\u003e f.data.code == 'use_alternative_integration');\n    Context.data.alternative_integration_1c = alternative_integration_1c ? alternative_integration_1c.data.status : false;\n}\nasync function get_staffs_by_organization() {\n    const employment_placement = await Namespace.app.employment_directory.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__status.eq(Namespace.app.employment_directory.fields.__status.variants.actual), f.organization.link(Context.data.organization)))\n        .size(10000)\n        .all();\n    const staff_ids = [...new Set(employment_placement\n            .filter(f =\u003e f.data.staff != undefined)\n            .map(f =\u003e f.data.staff.id))];\n    const staffs = await Context.fields.staffs.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__status.eq(Context.fields.staffs.app.fields.__status.variants.signed_documents), f.individual_id_1c.neq(null), f.__id.in(staff_ids)))\n        .size(staff_ids.length)\n        .all();\n    Context.data.staffs_pack = staffs.slice(Context.data.from, Context.data.from + 100);\n    Context.data.from += 100;\n    Context.data.payslip_counter += Context.data.staffs_pack.length;\n}\nasync function get_staffs_by_subdivisions() {\n    if (!Context.data.subdivisions || Context.data.subdivisions.length == 0) {\n        throw new Error('Подразделения не выбраны');\n    }\n    const subdivision_ids = Context.data.subdivisions.map(f =\u003e f.id);\n    const subdivisions = await Context.fields.subdivisions.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.in(subdivision_ids)))\n        .size(subdivision_ids.length)\n        .all();\n    Context.data.staffs = [];\n    let positionsApp = [];\n    subdivisions.forEach(s =\u003e {\n        var _a;\n        positionsApp.push(...(_a = s.data.positions) !== null \u0026\u0026 _a !== void 0 ? _a : []);\n    });\n    let staffs = [];\n    for (let i = 0; i \u003c positionsApp.length; i += CHUNK_SIZE) {\n        const chunk = positionsApp.slice(i, i + CHUNK_SIZE);\n        await Promise.all(chunk.map(f =\u003e f.fetch()))\n            .then((pos) =\u003e pos.forEach(p =\u003e {\n            var _a, _b, _c;\n            staffs.push(...(_a = p.data.staff) !== null \u0026\u0026 _a !== void 0 ? _a : [], ...(_b = p.data.staff_external_combination) !== null \u0026\u0026 _b !== void 0 ? _b : [], ...(_c = p.data.staff_internal_combination) !== null \u0026\u0026 _c !== void 0 ? _c : []);\n        }));\n    }\n    Context.data.staffs = staffs;\n}\nasync function get_staffs_pack() {\n    const pack = await Promise.all(Context.data.staffs.slice(Context.data.from, 100).map(f =\u003e f.fetch()));\n    Context.data.staffs_pack = pack.filter(f =\u003e f.data.individual_id_1c);\n    Context.data.from += 100;\n    Context.data.payslip_counter += Context.data.staffs_pack.length;\n}\nasync function check_staff_list() {\n    return Context.data.staffs_pack.length \u003e 0 ? true : false;\n}\n","gatewayPairs":{},"hasTranslations":false}
