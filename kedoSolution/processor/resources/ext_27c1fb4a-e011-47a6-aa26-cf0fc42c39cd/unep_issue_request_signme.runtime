{"scripts":"class SignMeLogger {\n    async logData(response, body) {\n        let requestEndpoint = \"\";\n        let provider;\n        if (response.url.includes(\"sign/cer/\")) {\n            requestEndpoint = \"cer\";\n        }\n        else {\n            requestEndpoint = response.url.split(\"/\").slice(-1)[0];\n        }\n        ;\n        let responseJson = {};\n        let responseText = await response.text();\n        ;\n        Context.data.stage = requestEndpoint;\n        try {\n            switch (requestEndpoint) {\n                case \"precheck\":\n                    responseJson = JSON.parse(responseText);\n                    if (Object.keys(responseJson).length \u003e 0) {\n                        let rootObj = responseJson.phone || responseJson.email || responseJson.inn || responseJson.snils;\n                        Context.data.request_exists = true;\n                        Context.data.debug = JSON.stringify(rootObj);\n                        if (rootObj.created \u0026\u0026 rootObj.approved \u0026\u0026 !rootObj.rejected) {\n                            Context.data.debug += \" issue exists\";\n                            const user = await Context.data.user.fetch();\n                            const now = new TDate();\n                            let existsField = Object.keys(responseJson)[0];\n                            let existsValue = JSON.parse(Context.data.json_obj).precheckDataObj[existsField];\n                            const issueId = rootObj.id.toString();\n                            Context.data.request_id = issueId;\n                            const issueExists = await System.signs.digitalSigns.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.issueID.eq(issueId))).first();\n                            Context.data.debug += ` ${issueId}, issueExists = ${issueExists}`;\n                            if (!issueExists) {\n                                Context.data.debug += \" creating issue in system..\";\n                                provider = await System.signs.providers.search().where(f =\u003e f.code.eq(\"SignMe\")).first();\n                                await System.signs.digitalSigns.createDraft(Context.data.request_id, provider);\n                                const newdigitalSignApp = Namespace.params.fields.digital_signs_list.app.create();\n                                newdigitalSignApp.data.country = Context.data.country;\n                                newdigitalSignApp.data.email = Context.data.email[0].email;\n                                newdigitalSignApp.data.external_id = Context.data.request_id;\n                                newdigitalSignApp.data.__name = `${user.data.__name} (${now.format(\"DD.MM.YY\")})`;\n                                newdigitalSignApp.data.name = user.data.__name;\n                                newdigitalSignApp.data.status = \"Создана\";\n                                newdigitalSignApp.data.inn = Context.data.inn;\n                                newdigitalSignApp.data.user = user;\n                                await newdigitalSignApp.save();\n                            }\n                            ;\n                            Context.data.response = `Найдена подтвержденнная заявка в системе, совпадение по полю ${existsField}: ${existsValue}`;\n                        }\n                        else if (!rootObj.created \u0026\u0026 !rootObj.approved \u0026\u0026 !rootObj.rejected) {\n                            let existsField = Object.keys(responseJson)[0];\n                            let existsValue = JSON.parse(Context.data.json_obj).precheckDataObj[existsField];\n                            Context.data.request_id = rootObj.id;\n                            Context.data.response = `Найдена неподтвержденнная заявка в системе, совпадение по полю ${existsField}: ${existsValue}, идентификатор заявки: ${rootObj.id}. На данном этапе заявки вы можете изменить её данные.`;\n                        }\n                        else if (rootObj.rejected) {\n                            let rejectComment = rootObj.reject_comment;\n                            Context.data.response = `Заявка отклонена, причина: ${rejectComment}`;\n                        }\n                        ;\n                    }\n                    ;\n                    break;\n                case \"api\":\n                    if (responseText.includes(\"error\")) {\n                        Context.data.error = responseText;\n                        Context.data.error_exists = true;\n                        return;\n                    }\n                    ;\n                    responseJson = JSON.parse(responseText);\n                    provider = await System.signs.providers.search().where(f =\u003e f.code.eq(\"SignMe\")).first();\n                    let requestId = responseJson.id.toString();\n                    await System.signs.digitalSigns.createDraft(requestId, provider);\n                    let requestBase64 = responseJson.pdf;\n                    let requestBuffer = base64ToArrayBuffer(requestBase64);\n                    let requestFile = await Context.fields.release_statement.create(\"Заявка на выпуск сертификата.pdf\", requestBuffer);\n                    Context.data.release_statement = requestFile;\n                    Context.data.request_id = requestId;\n                    break;\n                case \"photo\":\n                    if (!response.ok) {\n                        responseJson = JSON.parse(responseText).error;\n                        let errorCode = responseJson.code;\n                        let errorMessage = \"\";\n                        let docType;\n                        switch (errorCode) {\n                            case 1:\n                            case \"1\":\n                                errorMessage = `HHTP 500: Ошибка сервера, у нас сохранились логи, запишите точное время для поиска ошибки. (Точное время выполнения запроса: ${new Datetime().format(\"DD.MM.YY HH:MM:SS\")})`;\n                                break;\n                            case 2:\n                            case \"2\":\n                                errorMessage = `HTTP 400: Неправильный json: ${body}`;\n                                break;\n                            case 3:\n                            case \"3\":\n                                errorMessage = `HTTP 403: Неверный API-ключ.`;\n                                break;\n                            case 4:\n                            case \"4\":\n                                let userSnils = Context.data.snils;\n                                errorMessage = `HTTP 404: Пользователь со СНИЛС ${userSnils} не найден.`;\n                                break;\n                            case 6:\n                            case \"6\":\n                                docType = JSON.parse(body).doctype;\n                                errorMessage = `Неправильный тип документа: ${docType}, разрешенные виды документов - между 1 и 17.`;\n                                break;\n                            case 7:\n                            case \"7\":\n                                docType = JSON.parse(body).doctype;\n                                errorMessage = `Проверьте base64 содержимое файла ${docType}`;\n                                break;\n                            case 8:\n                            case \"8\":\n                                let fileName = JSON.parse(body).name;\n                                errorMessage = `Неправильное имя файла: ${fileName}`;\n                                break;\n                        }\n                        ;\n                        Context.data.error = errorMessage;\n                        Context.data.error_exists = true;\n                    }\n                    ;\n                case \"activate\":\n                    if (responseText.includes(\"1\")) {\n                        Context.data.request_confirmed = true;\n                        let currentDigitalSign = await System.signs.digitalSigns.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.issueID.eq(Context.data.request_id), f.__createdBy.eq(Context.data.user))).first();\n                    }\n                    ;\n                    break;\n                case \"comstaff\":\n                    if (responseText.includes(\"error\")) {\n                        Context.data.error = responseText;\n                        return;\n                    }\n                    ;\n                    let userId = responseText;\n                    Context.data.staff_id = userId;\n                    break;\n                case \"userinfo\":\n                    if (responseText.includes(\"error\")) {\n                        Context.data.error_exists = true;\n                        Context.data.error = responseText;\n                        return;\n                    }\n                    ;\n                    responseJson = JSON.parse(responseText);\n                    const certData = responseJson.keys.map((key) =\u003e {\n                        return {\n                            id: key.id.toString(),\n                            valid: key.date\n                        };\n                    });\n                    Context.data.certs_json = JSON.stringify(certData);\n                    break;\n                case \"keys\":\n                    responseJson = JSON.parse(responseText);\n                    if (responseJson.error) {\n                        Context.data.error_exists = true;\n                        Context.data.error = responseJson.error;\n                        return;\n                    }\n                    ;\n                    let certificateId = responseJson[0].id;\n                    Context.data.certificate_id = certificateId;\n                    break;\n                case \"cer\":\n                    if (!response.ok) {\n                        Context.data.error_exists = true;\n                        return;\n                    }\n                    ;\n                    responseJson = JSON.parse(responseText);\n                    provider = await System.signs.providers.search().where(f =\u003e f.code.eq(\"SignMe\")).first();\n                    let user = await Context.data.user.fetch();\n                    const certsData = JSON.parse(Context.data.certs_json);\n                    const now = new TDate();\n                    for (let key of Object.keys(responseJson)) {\n                        const certItem = certsData.find((cert) =\u003e cert.id === key);\n                        const newdigitalSignApp = await Namespace.params.fields.digital_signs_list.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.external_id.eq(certItem.id))).first();\n                        let certBase64 = responseJson[key];\n                        const certFile = await Context.fields.passport_main_page.create(`${user.data.__name} (${now.format(\"DD.MM.YY\")})`, base64ToArrayBuffer(certBase64));\n                        if (newdigitalSignApp) {\n                            newdigitalSignApp.data.valid_to = new Datetime(certItem.valid);\n                            newdigitalSignApp.data.cert_file = certFile;\n                            newdigitalSignApp.data.serial_number = certItem.id;\n                            await newdigitalSignApp.save();\n                        }\n                        let certArrayBuffer = base64ToArrayBuffer(certBase64);\n                        const issueExists = !!await System.signs.digitalSigns.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.issueID.eq(Context.data.request_id), f.__createdBy.eq(Context.data.user))).first();\n                        if (!issueExists) {\n                            let newIssue = await System.signs.digitalSigns.createDraft(Context.data.request_id, provider);\n                            await newIssue.setPublicKey(certArrayBuffer);\n                            await newIssue.setStatus(\"released\");\n                        }\n                        let newCert = await Context.fields.certs.create(`${user.data.__name}.cer`, certArrayBuffer);\n                        Context.data.certs ? Context.data.certs.push(newCert) : Context.data.certs = [newCert];\n                    }\n                    ;\n                    break;\n            }\n            ;\n        }\n        catch (_a) {\n            throw new Error(responseText);\n        }\n    }\n    ;\n}\n;\nclass SignMeProvider {\n    constructor(logger) {\n        this.method = \"POST\";\n        this.contentType = \"application/json\";\n        this.headers = {\n            \"Content-Type\": this.contentType\n        };\n        this.baseUrl = Namespace.params.data.sign_me_server_address;\n        this.paths = {\n            precheckPath: `${this.baseUrl}/register/precheck`,\n            registerPath: `${this.baseUrl}/register/api`,\n            activatePath: `${this.baseUrl}/register/activate`,\n            comstaffPath: `${this.baseUrl}/register/comstaff`,\n            userInfoPath: `${this.baseUrl}/register/userinfo`,\n            certsInfoPath: `${this.baseUrl}/certapi/keys`,\n            sendDocsPath: `${this.baseUrl}/photo`,\n            getCertsPath: `${this.baseUrl}/sign/cer/`\n        };\n        this.logger = logger;\n    }\n    ;\n    async makeRequest(path, body) {\n        Context.data.error_exists = false;\n        Context.data.error = \"\";\n        let response;\n        let headers = this.headers;\n        let method = this.method;\n        if (path.includes(\"cer\")) {\n            headers = {};\n        }\n        try {\n            response = await fetch(path, {\n                headers,\n                method,\n                body\n            });\n            if (path.includes(\"photo\")) {\n                await this.logger.logData(response, body);\n            }\n            else {\n                await this.logger.logData(response);\n            }\n            ;\n        }\n        catch (err) {\n            Context.data.error = err.message;\n            Context.data.error_exists = true;\n        }\n        ;\n    }\n    ;\n    async precheck() {\n        let path = this.paths.precheckPath;\n        let body = JSON.stringify(JSON.parse(Context.data.json_obj).precheckDataObj);\n        await this.makeRequest(path, body);\n    }\n    ;\n    async register() {\n        let path = this.paths.registerPath;\n        if (Context.data.data_changed) {\n            await serializeData();\n            Context.data.data_changed = false;\n        }\n        ;\n        let body = JSON.stringify(JSON.parse(Context.data.json_obj).registerDataObj);\n        await this.makeRequest(path, body);\n    }\n    ;\n    async activate() {\n        let path = this.paths.activatePath;\n        let activateBody = {\n            api_key,\n            uid: Context.data.request_id,\n            noemail: true\n        };\n        let body = JSON.stringify(activateBody);\n        await this.makeRequest(path, body);\n    }\n    ;\n    async sendDocs() {\n        let path = this.paths.sendDocsPath;\n        let documentsObj = JSON.parse(Context.data.json_obj).documentsDataObj;\n        let body;\n        for (let document of documentsObj) {\n            body = JSON.stringify(document);\n            await this.makeRequest(path, body);\n        }\n        ;\n    }\n    ;\n    async createUser() {\n        let path = this.paths.comstaffPath;\n        let data = new FormData();\n        data.append(\"user_ph\", Context.data.phone[0].tel);\n        data.append(\"key\", Context.data.api_key);\n        await this.makeRequest(path, data);\n    }\n    ;\n    async getCertsInfo() {\n        let path = this.paths.userInfoPath;\n        let body = JSON.stringify({\n            key: api_key,\n            phone: Context.data.phone[0].tel,\n            id: Context.data.request_id\n        });\n        await this.makeRequest(path, body);\n        path = this.paths.getCertsPath;\n        let data = new FormData();\n        data.append(\"user_ph\", Context.data.phone[0].tel);\n        data.append(\"key\", Context.data.api_key);\n        await this.makeRequest(path, data);\n    }\n    ;\n}\n;\nconst numberToDocTypeReference = {\n    \"1\": \"passport_main_page\",\n    \"2\": \"passport_living_page\",\n    \"3\": \"snils_file\",\n    \"4\": \"release_statement\"\n};\nconst signMeLogger = new SignMeLogger();\nconst signMeProvider = new SignMeProvider(signMeLogger);\nconst api_key = Context.data.api_key;\nconst ogrn = Context.data.ogrn;\nconst method = \"POST\";\nconst headers = {\n    \"Content-Type\": \"application/json\"\n};\nconst blankFileBase64 = \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAAMSURBVBhXY/j//z8ABf4C/qc1gYQAAAAASUVORK5CYII=\";\n;\n;\n;\nlet documentsDataObj = [];\nlet certsRequestData = new FormData();\nlet cecrtificateBase64;\nlet certRequestDataObj;\nlet precheckDataObj;\nlet registerDataObj;\nlet staffDataObj;\nlet user;\nlet responseData;\nasync function serializeData() {\n    Context.data.error = \"\";\n    Context.data.error_exists = false;\n    try {\n        let inn = Context.data.inn;\n        let name = Context.data.name;\n        let surname = Context.data.surname;\n        let lastname = Context.data.lastname;\n        let email = Context.data.email[0].email;\n        let phone = Context.data.phone[0].tel;\n        let gender = Context.data.gender.code.toUpperCase();\n        ;\n        let bdate = Context.data.birth_date.format(\"YYYY-MM-DD\");\n        let pn = Context.data.passport_number;\n        let ps = Context.data.passport_series;\n        let pdate = Context.data.passport_date.format(\"YYYY-MM-DD\");\n        let pcode = Context.data.passport_code;\n        let issued = Context.data.issued_by;\n        let snils = Context.data.snils;\n        let country = \"ru\";\n        let region = Context.data.region;\n        let city = Context.data.city;\n        let jsonObj = {};\n        for (let key of Object.keys(numberToDocTypeReference)) {\n            let contextKey = numberToDocTypeReference[key];\n            let fileName;\n            let fileBase64;\n            if (!Context.data[contextKey]) {\n                fileName = \"blank.png\";\n                fileBase64 = blankFileBase64;\n            }\n            else {\n                fileName = await Context.data[contextKey].fetch().then((f) =\u003e f.data.__name);\n                let downloadUrl = await Context.data[contextKey].getDownloadUrl();\n                let currentDocBuffer = await fetch(downloadUrl).then(async (r) =\u003e await r.arrayBuffer());\n                fileBase64 = arrayBufferToBase64(currentDocBuffer);\n            }\n            let currentDocObj = {\n                api_key,\n                utype: \"1\",\n                uid: snils,\n                doctype: key,\n                file: fileBase64,\n                name: fileName\n            };\n            documentsDataObj.push(currentDocObj);\n        }\n        ;\n        registerDataObj = {\n            api_key,\n            inn,\n            name,\n            surname,\n            lastname,\n            email,\n            phone,\n            gender,\n            bdate,\n            pn,\n            ps,\n            pdate,\n            pcode,\n            issued,\n            snils,\n            country,\n            region,\n            city,\n            regtype: Context.data.data_changed ? \"3\" : \"2\",\n            delivery: \"0\",\n            ca: \"NKEP12\",\n            noemail: \"1\"\n        };\n        precheckDataObj = {\n            api_key,\n            phone,\n            snils,\n            email,\n            inn\n        };\n        certRequestDataObj = {\n            api_key,\n            snils\n        };\n        staffDataObj = {\n            key: api_key,\n            cogrn: ogrn,\n            phone\n        };\n        certsRequestData.append(\"key\", api_key);\n        certsRequestData.append(\"user_ph\", registerDataObj.phone);\n        jsonObj = {\n            registerDataObj,\n            precheckDataObj,\n            certRequestDataObj,\n            staffDataObj,\n            documentsDataObj\n        };\n        Context.data.json_obj = JSON.stringify(jsonObj);\n    }\n    catch (err) {\n        Context.data.error_exists = true;\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nfunction base64ToArrayBuffer(base64) {\n    let binary_string = atob(base64);\n    let len = binary_string.length;\n    let bytes = new Uint8Array(len);\n    for (var i = 0; i \u003c len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    let bytes = new Uint8Array(buffer);\n    let len = bytes.byteLength;\n    for (let i = 0; i \u003c len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    ;\n    return btoa(binary);\n}\n;\nasync function precheck() {\n    try {\n        await signMeProvider.precheck();\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function register() {\n    try {\n        await signMeProvider.register();\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function sendPhotos() {\n    try {\n        await signMeProvider.sendDocs();\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function activate() {\n    try {\n        await signMeProvider.activate();\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function getCerts() {\n    try {\n        await signMeProvider.getCertsInfo();\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\n","gatewayPairs":{},"hasTranslations":false}
