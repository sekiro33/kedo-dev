{"scripts":"const statusReference = {\n    \"unknown\": \"Неизвестен\",\n    \"preparing\": \"Создана\",\n    \"validating\": \"На проверке\",\n    \"correction\": \"На исправлении\",\n    \"approved\": \"Данные проверены\",\n    \"releasing\": \"Выпуск сертификата\",\n    \"released\": \"Выпущена\"\n};\nconst triggerWords = [\n    \"inn\",\n    \"email\",\n    \"firstname\",\n    \"lastname\",\n    \"middlename\",\n    \"passport.number\",\n    \"passport.series\",\n    \"passport\"\n];\nconst readableErrors = {\n    \"inn\": \"ошибка в ИНН\",\n    \"email\": \"ошибка в электронной почте\",\n    \"firstname\": \"ошибка в имени, возможно использованы латинские символы\",\n    \"lastname\": \"ошибка в фамилии, возможно использованы латинские символы\",\n    \"middlename\": \"ошибка в отчестве, возможно использованы латинские символы\",\n    \"passport.number\": \"ошибка в номере документа\",\n    \"passport.series\": \"ошибка в серии документа\",\n    \"passportexpired\": \"ошибка в дате выдачи паспорта\",\n    \"filecorrupted\": \"файл паспорта повреждён\"\n};\nconst blankFileBase64 = \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAAMSURBVBhXY/j//z8ABf4C/qc1gYQAAAAASUVORK5CYII=\";\nconst stableData = {\n    certificateType: {\n        type: \"notQualified\",\n        nonExportable: false\n    },\n    personType: \"naturalPerson\",\n    cspType: \"asess\"\n};\nlet releaseStatementObj = {\n    requisitesToAddOrUpdate: []\n};\nlet userDataObj;\nlet certificateTemplateInfoObj;\nlet cspInfoObj;\nlet issueDataObj;\nlet passportInfoObj = {\n    requisitesToAddOrUpdate: []\n};\nlet releaseStatementInfo = {\n    requisitesToAddOrUpdate: []\n};\nlet fileDataObj = {\n    fileBuffer: new ArrayBuffer(0),\n    size: \"0\",\n    extension: \"\",\n    name: \"\"\n};\nlet confirmIssueDataObj = {\n    operationToConfirm: \"\",\n    parameters: {\n        snilsNumber: \"\",\n        birthDate: \"\"\n    }\n};\nlet dataObj;\nfunction base64ToArrayBuffer(base64) {\n    let binaryString = atob(base64);\n    let bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i \u003c binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    ;\n    return bytes.buffer;\n}\n;\nclass KonturLogger {\n    constructor() {\n        this.baseUrl = Namespace.params.data.kontur_server_address;\n    }\n    async logData(response) {\n        try {\n            response = response;\n            let responseEndpoint = response.url.replace(`${this.baseUrl}/v1/issues`, \"\");\n            let responseJson;\n            let currentDoc = Context.data.current_doc;\n            let requestId = Context.data.request_id;\n            let responseStatus = \"\";\n            let fileName = \"\";\n            let currentIssue = undefined;\n            let currentSignItem;\n            let issueId = \"\";\n            let user = await Context.data.user.fetch();\n            let staff;\n            let organizationName = \"\";\n            staff = await Namespace.params.fields.staff_app.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ext_user.eq(user))).first();\n            if (staff) {\n                let organization = await staff.data.organization.fetch();\n                organizationName = organization.data.__name;\n                Context.data.organization_name = organizationName;\n            }\n            ;\n            switch (responseEndpoint) {\n                case \"\":\n                    responseJson = await response.json();\n                    issueId = responseJson.id;\n                    if (!Context.data.issue_created) {\n                        let digitalSignItem = Namespace.params.fields.digital_signs_list.app.create();\n                        let digitalSignItemExists = !!await Namespace.params.fields.digital_signs_list.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.external_id.eq(issueId))).first();\n                        if (!digitalSignItemExists) {\n                            digitalSignItem.data.name = `${Context.data.surname} ${Context.data.name} ${Context.data.lastname || \"\"}`;\n                            digitalSignItem.data.email = Context.data.email[0].email;\n                            digitalSignItem.data.country = Context.data.country;\n                            digitalSignItem.data.inn = Context.data.inn;\n                            digitalSignItem.data.external_id = issueId;\n                            digitalSignItem.data.user = user;\n                            digitalSignItem.data.status = statusReference[responseJson.status];\n                            digitalSignItem.data.__name = `${Context.data.surname} ${Context.data.name} ${Context.data.lastname || \"\"} (${new Datetime(responseJson.createdAt).format(\"DD.MM.YY HH:MM:SS\")})`;\n                            digitalSignItem.data.organization = organizationName;\n                            digitalSignItem.data.provider = 'Контур';\n                            await digitalSignItem.save();\n                        }\n                        let elmaKonturProvider = await System.signs.providers.search().where(f =\u003e f.code.eq(\"KonturNew\")).first();\n                        if (!elmaKonturProvider) {\n                            elmaKonturProvider = await System.signs.providers.createDraft(\"KonturNew\");\n                        }\n                        if (!elmaKonturProvider) {\n                            this.logError(\"sdk_error\", undefined, \"Не удалось найти провайдера Контур\");\n                        }\n                        ;\n                        let newIssue = await System.signs.digitalSigns.createDraft(issueId, elmaKonturProvider);\n                        Context.data.issue_created = true;\n                    }\n                    ;\n                    currentIssue = await System.signs.digitalSigns.search().where((f, g) =\u003e g.and(f.issueID.eq(issueId))).first();\n                    currentSignItem = await Namespace.params.fields.digital_signs_list.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.external_id.eq(issueId))).first();\n                    if (currentSignItem) {\n                        currentSignItem.data.status = statusReference[responseJson.status];\n                        await currentSignItem.save();\n                    }\n                    ;\n                    Context.data.request_id = issueId;\n                    break;\n                case `/${requestId}`:\n                    responseJson = await response.json();\n                    if (Context.data.request_exists \u0026\u0026 responseJson.certificateReleasedInfo) {\n                        const certificateJson = responseJson.certificateReleasedInfo;\n                        const certificateInfoObj = {\n                            validTo: new Datetime(certificateJson.validTo).format(\"DD.MM.YY\"),\n                            id: responseJson.id,\n                            createdAt: new Datetime(certificateJson.validFrom).format(\"DD.MM.YY\"),\n                            serialNumber: certificateJson.serialNumber\n                        };\n                        let certificatesInfo = JSON.parse(Context.data.response);\n                        if (certificatesInfo.certificateInfoObj) {\n                            certificatesInfo.certificateInfoObj.push(certificateInfoObj);\n                            Context.data.response = JSON.stringify(certificatesInfo);\n                        }\n                        else {\n                            Context.data.response = JSON.stringify({ certificateInfoObj: [certificateInfoObj] });\n                        }\n                        ;\n                        return;\n                    }\n                    ;\n                    let issueStatus = responseJson.status;\n                    currentIssue = await System.signs.digitalSigns.search().where(f =\u003e f.issueID.eq(requestId)).first();\n                    currentSignItem = await Namespace.params.fields.digital_signs_list.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.external_id.eq(Context.data.request_id))).first();\n                    if (currentSignItem) {\n                        currentSignItem.data.status = statusReference[responseJson.status];\n                        await currentSignItem.save();\n                    }\n                    ;\n                    let actualized = responseJson.actualized;\n                    Context.data.issue_status = responseJson.status;\n                    Context.data.request_actualized = actualized;\n                    if (issueStatus == \"released\") {\n                        Context.data.cert_released = true;\n                        Context.data.response = JSON.stringify(responseJson);\n                        if (currentSignItem) {\n                            currentSignItem.data.serial_number = responseJson.certificateReleasedInfo.serialNumber;\n                            currentSignItem.data.valid_to = new Datetime(responseJson.certificateReleasedInfo.validTo);\n                            await currentSignItem.save();\n                        }\n                        ;\n                    }\n                    else if (issueStatus == \"correction\") {\n                        Context.data.error_exists = true;\n                        Context.data.error = responseJson.correctionInfo;\n                    }\n                    ;\n                    break;\n                case `/${requestId}/documents/${currentDoc}`:\n                    if (response.status == 204) {\n                        responseStatus = `Документ ${currentDoc} успешно загружен.`;\n                    }\n                    else {\n                        this.logError(\"data_error\", undefined, `Не удалось загрузить документ ${currentDoc}.`);\n                    }\n                    ;\n                    break;\n                case `/${requestId}/documents/${currentDoc}/pages`:\n                    if (response.status == 204) {\n                        responseStatus = `Страница документа ${currentDoc} успешно загружена.`;\n                    }\n                    else {\n                        this.logError(\"data_error\", undefined, `Не удалось загрузить страницу к документу ${currentDoc}.`);\n                    }\n                    ;\n                    break;\n                case `/${requestId}/templates/releaseStatement`:\n                    fileName = `Заявление на выпуск сертификата для ${Context.data.surname} ${Context.data.name} ${Context.data.lastname} ${new TDate().format(\"DD.MM.YYYY\")}.pdf`;\n                    let releaseStatement = await Context.fields.release_statement.create(fileName, await response.arrayBuffer());\n                    Context.data.release_statement = releaseStatement;\n                    break;\n                case `/${requestId}/documents/releaseStatement/sign`:\n                    Context.data.request_confirmed = true;\n                    break;\n                case `/${Context.data.current_issue_id}/download-certificate`:\n                    try {\n                        let certificate = await response.arrayBuffer();\n                        let elmaKonturProvider = await System.signs.providers.search().where(f =\u003e f.code.eq(\"KonturNew\")).first();\n                        if (!elmaKonturProvider) {\n                            elmaKonturProvider = await System.signs.providers.createDraft(\"KonturNew\");\n                        }\n                        let issueInformation = JSON.parse(Context.data.response).certificateInfoObj;\n                        if (!Context.data.request_id) {\n                            Context.data.debug += \"creating issue\";\n                            currentIssue = await System.signs.digitalSigns.createDraft(Context.data.current_issue_id, elmaKonturProvider);\n                        }\n                        else {\n                            Context.data.debug += \"creating issue\";\n                            currentIssue = await System.signs.digitalSigns.createDraft(Context.data.request_id, elmaKonturProvider);\n                        }\n                        ;\n                        currentSignItem = await Namespace.params.fields.digital_signs_list.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.external_id.eq(Context.data.request_id))).first();\n                        let issueId = currentIssue.data.issueID;\n                        if (issueInformation) {\n                            let issueObj = issueInformation.find((i) =\u003e i.id === issueId);\n                            let certFile;\n                            if (currentSignItem) {\n                                certFile = await Context.fields.passport_main_page.create(`${currentSignItem.data.name} (${issueObj.createdAt}).cer`, certificate);\n                                currentSignItem.data.cert_file = certFile;\n                            }\n                            else {\n                                currentSignItem = Namespace.params.fields.digital_signs_list.app.create();\n                                certFile = await Context.fields.passport_main_page.create(`${currentSignItem.data.name} (${issueObj.createdAt}).cer`, certificate);\n                                currentSignItem.data.name = `${Context.data.surname} ${Context.data.name} ${Context.data.lastname || \"\"}`;\n                                currentSignItem.data.email = Context.data.email[0].email;\n                                currentSignItem.data.country = Context.data.country;\n                                currentSignItem.data.inn = Context.data.inn;\n                                currentSignItem.data.external_id = issueId;\n                                currentSignItem.data.user = user;\n                                currentSignItem.data.status = statusReference.released;\n                                currentSignItem.data.__name = `${Context.data.surname} ${Context.data.name} ${Context.data.lastname || \"\"} (${issueObj.createdAt})`;\n                                currentSignItem.data.organization = organizationName;\n                                currentSignItem.data.provider = 'Контур';\n                                currentSignItem.data.cert_file = certFile;\n                                currentSignItem.data.valid_to = issueObj.validTo;\n                                currentSignItem.data.serial_number = issueObj.serialNumber;\n                            }\n                            ;\n                            await currentSignItem.save();\n                        }\n                        await currentIssue.setPublicKey(certificate);\n                        await currentIssue.setStatus(\"released\");\n                    }\n                    catch (err) {\n                        throw new Error(err.message);\n                    }\n                    ;\n            }\n            ;\n            if (response.url.includes(\"status\")) {\n                responseJson = (await response.json()).issues.filter((issue) =\u003e issue[\"cspType\"] === \"asess\" \u0026\u0026 issue[\"certificateState\"] === \"valid\");\n                if (responseJson.length \u003c 1) {\n                    return;\n                }\n                ;\n                let issueIds = responseJson.map((issue) =\u003e issue.id);\n                Context.data.response = JSON.stringify(issueIds);\n                Context.data.request_exists = true;\n            }\n            ;\n        }\n        catch (err) {\n            Context.data.error_exists = true;\n            throw new Error(err.message);\n        }\n    }\n    ;\n    async logError(_type, response, error) {\n        Context.data.error_exists = true;\n        let errorVariant = { name: Context.fields.error_type.variants[_type].name, code: _type };\n        Context.data.error_type = errorVariant;\n        if (!!response) {\n            if (response.url.includes(\"confirmation-requests\")) {\n                Context.data.error = await response.text();\n                throw new Error();\n            }\n            ;\n            switch (response.status) {\n                case 400:\n                    if (response.url.includes(\"sign\")) {\n                        Context.data.request_confirmed = false;\n                        let responseJson = await response.json();\n                        let errorCode = responseJson.error.code;\n                        switch (errorCode) {\n                            case \"ConfirmationInProgress\":\n                                Context.data.error_exists = false;\n                                break;\n                            case \"ConfirmationFailed\":\n                                let errorType = responseJson.error.details[0].code;\n                                if (errorType == \"ConfirmationRejected\") {\n                                    Context.data.confirmation_error_reason = \"Пользователь отказался от выпуска УНЭП.\";\n                                    Context.data.issue_data_can_be_changed = true;\n                                    break;\n                                }\n                                else if (errorType == \"UserNotFoundInEsia\") {\n                                    Context.data.confirmation_error_reason = \"У пользователя отсутствует подтвержденная учетная запись в ЕСИА.\";\n                                    break;\n                                }\n                                else if (errorType == \"ConfirmationExpired\") {\n                                    Context.data.confirmation_error_reason = \"Истекло время на подтверждение личности\";\n                                    break;\n                                }\n                                ;\n                                break;\n                        }\n                        ;\n                        return;\n                    }\n                    ;\n                    const responseJson = await response.json();\n                    const errorDetails = responseJson.error.details;\n                    Context.data.issue_data_can_be_changed = true;\n                    let errorString = \"\";\n                    for (let word of triggerWords) {\n                        for (let field of errorDetails) {\n                            if (field.target.toLowerCase().match(word)) {\n                                errorString += `${readableErrors[word] ? readableErrors[word] : readableErrors[field.code] || \"\"}, `;\n                            }\n                            ;\n                        }\n                        ;\n                    }\n                    ;\n                    errorString = errorString.replace(/,\\s$/, \".\");\n                    throw new Error(`Ошибка в данных: ${errorString}`);\n                case 401:\n                    throw new Error(\"Неверный api-ключ\");\n                case 403:\n                    throw new Error(\"Недостаточно прав на создание заявки\");\n                case 404:\n                    throw new Error(\"Заявка с данным идентификатором не найдена.\");\n                case 408:\n                    Context.data.connection_timed_out = true;\n                    throw new Error(\"Превышено время ожидания запроса.\");\n                case 409:\n                    throw new Error(\"Данная заявка в процессе актуализации.\");\n                case 429:\n                    throw new Error(\"Данные заявки изменялись слишком много раз, попробуйте заново.\");\n            }\n            ;\n        }\n        ;\n        throw new Error(error);\n    }\n    ;\n}\n;\nclass KonturProvider {\n    constructor(logger) {\n        this.baseUrl = `${Namespace.params.data.kontur_server_address}/v1/issues`;\n        this.apiToken = Context.data.api_key;\n        this.headers = {\n            \"X-KONTUR-APIKEY\": this.apiToken,\n            \"Content-Type\": \"application/json\"\n        };\n        this.apiPaths = {\n            create_issue: {\n                path: this.baseUrl,\n                method: \"POST\"\n            },\n            check_issue: {\n                path: `${this.baseUrl}/issueId`,\n                method: \"GET\",\n                getPath: function (id) {\n                    return this.path.replace(\"issueId\", id);\n                }\n            },\n            send_doc_info: {\n                path: `${this.baseUrl}/issueId/documents/docType`,\n                method: \"PUT\",\n                getPath(id, docType) {\n                    return this.path.replace(\"issueId\", id).replace(\"docType\", docType);\n                }\n            },\n            send_doc_page: {\n                path: `${this.baseUrl}/issueId/documents/docType/pages`,\n                method: \"POST\",\n                getPath: function (id, docType) {\n                    return this.path.replace(\"issueId\", id).replace(\"docType\", docType);\n                }\n            },\n            create_doc_template: {\n                path: `${this.baseUrl}/issueId/templates/templateType`,\n                method: \"POST\",\n                getPath: function (id, template) {\n                    return this.path.replace(\"issueId\", id).replace(\"templateType\", template);\n                }\n            },\n            send_to_confirmation: {\n                path: `${this.baseUrl}/issueId/confirmation-requests`,\n                method: \"POST\",\n                getPath: function (id) {\n                    return this.path.replace(\"issueId\", id);\n                }\n            },\n            confirm_release: {\n                path: `${this.baseUrl}/issueId/documents/releaseStatement/sign`,\n                method: \"POST\",\n                getPath: function (id) {\n                    return this.path.replace(\"issueId\", id);\n                }\n            },\n            validate_issue: {\n                path: `${this.baseUrl}/issueId/validate`,\n                method: \"POST\",\n                getPath: function (id) {\n                    return this.path.replace(\"issueId\", id);\n                }\n            },\n            get_certificate: {\n                path: `${this.baseUrl}/issueId/download-certificate`,\n                method: \"POST\",\n                getPath: function (id) {\n                    return this.path.replace(\"issueId\", id);\n                }\n            },\n            subject_identification: {\n                path: `${this.baseUrl}/issueId/subject-identification`,\n                method: \"PUT\",\n                getPath: function (id) {\n                    return this.path.replace(\"issueId\", id);\n                }\n            },\n            add_note: {\n                path: `${this.baseUrl}/issueId/note`,\n                method: \"POST\",\n                getPath: function (id) {\n                    return this.path.replace(\"issueId\", id);\n                }\n            }\n        };\n        this.logger = logger;\n    }\n    ;\n    async serializeFiles() {\n        let passportFile;\n        let passportFileLink;\n        let passportFileExtension;\n        let passportArrayBuffer;\n        let passportFileSize;\n        if (!!Context.data.passport_main_page) {\n            passportFile = await Context.data.passport_main_page.fetch();\n            passportFileLink = await passportFile.getDownloadUrl();\n            passportFileExtension = passportFile.data.__name.split(\".\").slice(-1)[0];\n            passportArrayBuffer = await fetch(passportFileLink).then(async (file) =\u003e await file.arrayBuffer());\n            passportFileSize = passportArrayBuffer.byteLength;\n        }\n        else {\n            passportArrayBuffer = base64ToArrayBuffer(blankFileBase64);\n            passportFile = await Context.fields.passport_main_page.create(\"blank.jpg\", passportArrayBuffer);\n            passportFileExtension = \"jpg\";\n            passportFileSize = 116;\n        }\n        this.fileDataObj = {\n            extension: passportFileExtension,\n            size: passportFileSize.toString(),\n            fileBuffer: passportArrayBuffer,\n            name: passportFile.data.__name\n        };\n    }\n    ;\n    actualize() {\n        Context.data.request_actualized = false;\n        Context.data.issue_data_can_be_changed = false;\n        Context.data.data_changed = false;\n        Context.data.error = \"\";\n        Context.data.repeat_confirmation = false;\n        Context.data.error_exists = false;\n        Context.data.create_new_issue = false;\n        Context.data.issue_created = false;\n    }\n    ;\n    async makeRequest(url, method) {\n        this.actualize();\n        let response = undefined;\n        try {\n            response = await fetch(url, {\n                method,\n                headers: this.headers,\n                body: this.body || undefined\n            });\n        }\n        catch (err) {\n            await this.logger.logError(\"sdk_error\", undefined, err.message);\n        }\n        ;\n        if (!response.ok) {\n            await this.logger.logError(\"data_error\", response);\n        }\n        ;\n        if (method !== \"PATCH\" \u0026\u0026 method !== \"DELETE\") {\n            await this.logger.logData(response);\n        }\n    }\n    ;\n    async checkCertificate() {\n        let issueData = JSON.parse(Context.data.json_obj).issueDataObj.subjectInfo;\n        let subjectInfoObj = {\n            \"subjectPhone\": issueData.phone,\n        };\n        let fieldsToCheck = [\"subjectPhone\"];\n        let pathObj = this.apiPaths.create_issue;\n        let [path, method] = [pathObj.path, \"GET\"];\n        for (let field of fieldsToCheck) {\n            await this.makeRequest(`${path}/?status=released\u0026${field}=${subjectInfoObj[field]}\u0026inn=${issueData.inn}`, method);\n            if (Context.data.request_exists) {\n                break;\n            }\n            ;\n        }\n        ;\n        let issueIds = JSON.parse(Context.data.response);\n        if (!issueIds) {\n            throw new Error(\"Ошибка в checkCertificate\");\n        }\n        if (Context.data.issue_for_new_subject) {\n            path = this.apiPaths.check_issue.getPath(Context.data.request_id);\n            await this.makeRequest(path, method);\n        }\n        else {\n            for (let issue of issueIds) {\n                path = this.apiPaths.check_issue.getPath(issue);\n                await this.makeRequest(path, method);\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    async getCertificates() {\n        let issueIds = JSON.parse(Context.data.response).certificateInfoObj;\n        if (!issueIds) {\n            issueIds = JSON.parse(Context.data.response);\n        }\n        let pathObj = this.apiPaths.get_certificate;\n        for (let issue of issueIds) {\n            Context.data.current_issue_id = issue.id ? issue.id : issue;\n            let [path, method] = [pathObj.getPath(issue.id ? issue.id : issue), pathObj.method];\n            await this.makeRequest(path, method);\n        }\n        ;\n    }\n    ;\n    async createIssue() {\n        let issueData = JSON.parse(Context.data.json_obj).issueDataObj;\n        this.body = JSON.stringify(issueData);\n        let pathObj = this.apiPaths.create_issue;\n        let [path, method] = [pathObj.path, pathObj.method];\n        await this.makeRequest(path, method);\n        let notePathObj = this.apiPaths.add_note;\n        [path, method] = [notePathObj.getPath(Context.data.request_id), pathObj.method];\n        const domenSetting = await Namespace.params.fields.settings_app.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.code.eq(\"domen\"))).first();\n        let domen = \"\";\n        if (domenSetting) {\n            domen = domenSetting.data.value;\n        }\n        ;\n        this.body = JSON.stringify({\n            content: `${Context.data.organization_name};${domen}`\n        });\n        await this.makeRequest(path, method);\n        this.body = \"\";\n    }\n    ;\n    async checkIssue() {\n        let pathObj = this.apiPaths.check_issue;\n        let [path, method] = [pathObj.getPath(Context.data.request_id), pathObj.method];\n        this.body = \"\";\n        await this.makeRequest(path, method);\n    }\n    ;\n    async createDocs() {\n        let passportInfo = JSON.parse(Context.data.json_obj).passportInfoObj;\n        let releaseStatementInfo = JSON.parse(Context.data.json_obj).releaseStatementInfo;\n        let requestId = Context.data.request_id;\n        let pathObj = this.apiPaths.send_doc_info;\n        let method = pathObj.method;\n        let path;\n        let docCode = Context.data.document_type.code;\n        if (docCode == \"passport\") {\n            path = pathObj.getPath(requestId, \"passport\");\n        }\n        else {\n            path = pathObj.getPath(requestId, \"otherIdentity\");\n        }\n        Context.data.current_doc = docCode;\n        this.body = JSON.stringify(passportInfo);\n        await this.makeRequest(path, method);\n        path = pathObj.getPath(requestId, \"releaseStatement\");\n        Context.data.current_doc = \"releaseStatement\";\n    }\n    ;\n    async sendPages() {\n        try {\n            await this.serializeFiles();\n        }\n        catch (err) {\n            this.logger.logError(\"data_error\", undefined, \"Не заполнено поле с файлом паспорта\");\n        }\n        let requestId = Context.data.request_id;\n        let pathObj = this.apiPaths.send_doc_page;\n        let method = pathObj.method;\n        let path;\n        let docCode = Context.data.document_type.code;\n        if (docCode == \"passport\") {\n            path = pathObj.getPath(requestId, \"passport\");\n        }\n        else {\n            path = pathObj.getPath(requestId, \"otherIdentity\");\n        }\n        let contentType = \"\";\n        let fileExt = this.fileDataObj.extension;\n        this.body = this.fileDataObj.fileBuffer;\n        if (fileExt === \"jpg\" || fileExt === \"jpeg\") {\n            contentType = \"image/jpeg\";\n        }\n        else if (fileExt === \"pdf\") {\n            contentType = \"application/pdf\";\n        }\n        else if (fileExt === \"png\") {\n            contentType = \"image/png\";\n        }\n        else if (fileExt === \"gif\") {\n            contentType = \"image/gif\";\n        }\n        else {\n            await this.logger.logError(\"data_error\", undefined, `Неподдерживаемый формат файла для документа ${this.fileDataObj.name}: .${this.fileDataObj.extension}`);\n        }\n        ;\n        this.headers[\"Content-Type\"] = contentType;\n        this.headers[\"Content-Length\"] = this.fileDataObj.size;\n        await this.makeRequest(path, method);\n    }\n    ;\n    async createTemplate() {\n        this.body = undefined;\n        let pathObj = this.apiPaths.create_doc_template;\n        let [path, method] = [pathObj.getPath(Context.data.request_id, \"releaseStatement\"), pathObj.method];\n        await this.makeRequest(path, method);\n        Context.data.connection_timed_out = false;\n    }\n    ;\n    async createConfirmationRequest() {\n        let snils = Context.data.snils;\n        snils = snils.replace(/-/g, \"\").replace(/\\s/g, \"\");\n        this.body = JSON.stringify({\n            operationToConfirm: \"signingReleaseStatementWithEsia\",\n            parameters: {\n                snilsNumber: snils,\n                birthDate: Context.data.birth_date.asDatetime(new TTime()).format()\n            }\n        });\n        let pathObj = this.apiPaths.send_to_confirmation;\n        let [path, method] = [pathObj.getPath(Context.data.request_id), pathObj.method];\n        await this.makeRequest(path, method);\n    }\n    ;\n    async changeIssueData() {\n        let issueData = JSON.parse(Context.data.json_obj).issueDataObj;\n        this.body = JSON.stringify(issueData);\n        let pathObjDocs = this.apiPaths.send_doc_info;\n        let path = \"\";\n        let method = \"DELETE\";\n        path = pathObjDocs.getPath(Context.data.request_id, \"passport\");\n        await this.makeRequest(path, method);\n        let pathObjPatch = this.apiPaths.check_issue;\n        path = pathObjPatch.getPath(Context.data.request_id);\n        method = \"PATCH\";\n        await this.makeRequest(path, method);\n    }\n    ;\n    async validateIssue() {\n        let pathObj = this.apiPaths.validate_issue;\n        let [path, method] = [pathObj.getPath(Context.data.request_id), pathObj.method];\n        await this.makeRequest(path, method);\n    }\n    ;\n    async sendIdentificationInfo() {\n        let pathObj = this.apiPaths.subject_identification;\n        let [path, method] = [pathObj.getPath(Context.data.request_id), pathObj.method];\n        this.body = JSON.stringify({\n            identifiedBy: Context.data.responsible_user.id,\n            identificationSubjectType: \"employee\"\n        });\n        await this.makeRequest(path, method);\n    }\n}\n;\nasync function serialize() {\n    try {\n        const personType = stableData.personType;\n        const inn = Context.data.inn;\n        const lastname = Context.data.surname.trim();\n        const firstname = Context.data.name.trim();\n        const middlename = Context.data.lastname ? Context.data.lastname.trim() : \"\";\n        const email = Context.data.email[0].email;\n        const phone = Context.data.phone[0].tel.slice(-10);\n        const series = Context.data.passport_series;\n        const passportNumber = Context.data.passport_number;\n        const issueDate = Context.data.passport_date.format(\"DD.MM.YYYY\");\n        const birthDate = Context.data.birth_date.format(\"DD.MM.YYYY\");\n        const birthPlace = `${Context.data.country} ${Context.data.region} ${Context.data.city}`;\n        const docCode = Context.data.document_type.code;\n        let issueOrganizationId = Context.data.passport_code;\n        if (issueOrganizationId.includes(\"-\")) {\n            issueOrganizationId = issueOrganizationId.replace(/-/g, \"\");\n        }\n        ;\n        if (docCode == \"passport\") {\n            passportInfoObj.requisitesToAddOrUpdate = [\n                { type: \"series\", value: series },\n                { type: \"number\", value: passportNumber },\n                { type: \"issueDate\", value: issueDate },\n                { type: \"birthDate\", value: birthDate },\n                { type: \"birthPlace\", value: birthPlace },\n                { type: \"issueOrganizationId\", value: issueOrganizationId },\n            ];\n        }\n        else {\n            let expirationDate = Context.data.identity_expiration ? Context.data.identity_expiration.format(\"DD.MM.YYYY\") : \"\";\n            let issuedBy = Context.data.issued_by;\n            passportInfoObj.requisitesToAddOrUpdate = [\n                { type: \"number\", value: passportNumber },\n                { type: \"issueDate\", value: issueDate },\n                { type: \"issueOrganization\", value: issuedBy }\n            ];\n            if (!!expirationDate) {\n                passportInfoObj.requisitesToAddOrUpdate.push({ type: \"validTo\", value: expirationDate });\n            }\n            ;\n            if (!!Context.data.passport_series) {\n                passportInfoObj.requisitesToAddOrUpdate.push({ type: \"series\", value: series });\n            }\n            ;\n        }\n        ;\n        certificateTemplateInfoObj = stableData.certificateType;\n        cspInfoObj = {\n            type: stableData.cspType\n        };\n        userDataObj = {\n            inn,\n            lastname,\n            firstname,\n            middlename,\n            email,\n            type: personType,\n            phone\n        };\n        issueDataObj = {\n            certificateTemplateInfo: certificateTemplateInfoObj,\n            subjectInfo: userDataObj,\n            cspInfo: cspInfoObj\n        };\n        Context.data.json_obj = JSON.stringify({ issueDataObj, passportInfoObj, releaseStatementInfo });\n    }\n    catch (err) {\n        await konturLogger.logError(\"sdk_error\", undefined, `Ошибка в данных: ${err.message}`);\n    }\n    ;\n}\n;\nconst konturLogger = new KonturLogger();\nconst konturProvider = new KonturProvider(konturLogger);\nasync function setUserData() {\n    const staff = await Namespace.params.fields.staff_app.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ext_user.eq(Context.data.user))).first();\n    if (staff) {\n        staff.data.passport_number = Context.data.passport_number;\n        staff.data.passport_department_code = Context.data.passport_code;\n        staff.data.passport_series = Context.data.passport_series;\n        staff.data.inn = Context.data.inn;\n        staff.data.date_of_issue = Context.data.passport_date;\n        staff.data.full_name = {\n            firstname: Context.data.name,\n            lastname: Context.data.surname,\n            middlename: Context.data.lastname || \"\"\n        };\n        staff.data.date_of_birth = Context.data.date_of_birth;\n        staff.data.phone.tel = Context.data.phone[0].tel;\n        staff.data.issued_by = Context.data.issued_by;\n        if (staff.data.email) {\n            staff.data.email.email = Context.data.email[0].email;\n        }\n        ;\n        if (Context.data.snils) {\n            staff.data.snils = Context.data.snils;\n        }\n        ;\n        await staff.save();\n    }\n    ;\n}\n;\nasync function checkCertificate() {\n    try {\n        await konturProvider.checkCertificate();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function getExistingCertificates() {\n    try {\n        await konturProvider.getCertificates();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function createIssue() {\n    try {\n        if (Context.data.create_new_issue) {\n            await serialize();\n        }\n        ;\n        await konturProvider.createIssue();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function checkIssue() {\n    try {\n        await konturProvider.checkIssue();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function sendDocs() {\n    try {\n        await konturProvider.createDocs();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function sendPages() {\n    try {\n        await konturProvider.sendPages();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function createReleaseStatementTemplate() {\n    try {\n        await konturProvider.createTemplate();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function createConfirmationRequest() {\n    try {\n        await konturProvider.createConfirmationRequest();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function patchIssueData() {\n    try {\n        Context.data.data_changed = true;\n        await serialize();\n        await konturProvider.changeIssueData();\n        await setUserData();\n        const staff = await Namespace.params.fields.staff_app.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ext_user.eq(Context.data.user))).first();\n        if (staff \u0026\u0026 staff.data.__status.code !== \"signed_documents\") {\n            await staff.setStatus(staff.fields.__status.variants.UNEP_release_confirmation);\n        }\n        ;\n    }\n    catch (err) {\n        Context.data.error = err.message;\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function validateIssue() {\n    try {\n        await konturProvider.validateIssue();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\nasync function confirmSubjectIdentification() {\n    try {\n        await konturProvider.sendIdentificationInfo();\n    }\n    catch (err) {\n        Context.data.error = err.message;\n    }\n    ;\n}\n;\n","gatewayPairs":{},"hasTranslations":false}
