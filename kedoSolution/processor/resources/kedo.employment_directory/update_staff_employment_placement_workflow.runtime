{"scripts":"const PACK_SIZE = 30;\nconst PROMISE_SIZE = 20;\nasync function updateStaffsEmployment() {\n    var _a;\n    const staffs_app = ((_a = Context.data.staffs) !== null \u0026\u0026 _a !== void 0 ? _a : []).splice(0, PACK_SIZE);\n    if (staffs_app.length == 0) {\n        Context.data.staffs = undefined;\n        return;\n    }\n    const staffs = await Context.fields.staffs.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.in(staffs_app.map(s =\u003e s.id))))\n        .size(staffs_app.length)\n        .all();\n    await Promise.all(staffs.map(s =\u003e dedublicateTable(s)));\n    await Promise.all(staffs.map(s =\u003e updateEmploymentTable(s)));\n}\nasync function updateStaffEmployment() {\n    if (!Context.data.staff) {\n        throw new Error(\"Context.data.staff is undefined. Не указан сотрудник.\");\n    }\n    const staff = await Context.data.staff.fetch();\n    await dedublicateTable(staff);\n    await updateEmploymentTable(staff);\n}\nasync function updateEmploymentTable(staff) {\n    const employment_table = staff.data.employment_table;\n    if (!employment_table || employment_table.length == 0) {\n        return;\n    }\n    const staff_employment = await Context.fields.employment_directory.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.staff.link(staff)))\n        .size(1000)\n        .all();\n    let promises = [];\n    for (const row of employment_table) {\n        let employment_app;\n        let employment_app_index = staff_employment.findIndex(f =\u003e { var _a; return f.id == ((_a = row.employment_placement_app) === null || _a === void 0 ? void 0 : _a.id); });\n        if (employment_app_index === -1) {\n            employment_app = Context.fields.employment_directory.app.create();\n        }\n        else {\n            employment_app = staff_employment[employment_app_index];\n            staff_employment.splice(employment_app_index, 1);\n        }\n        employment_app.data.staff = staff;\n        employment_app.data.position = row.position;\n        employment_app.data.type_employment = row.type_employment;\n        employment_app.data.subdivision = row.subdivision;\n        employment_app.data.organization = row.organization;\n        employment_app.data.id_1c = row.id_1c;\n        employment_app.data.admission_date_organization = row.admission_date_organization;\n        employment_app.data.admission_date_position = row.admission_date_position;\n        employment_app.data.date_by = row.date_by;\n        employment_app.data.staff_full_name = staff.data.__name;\n        promises.push(employment_app.save()\n            .then(() =\u003e {\n            row.employment_placement_app = employment_app;\n        }));\n        if (promises.length \u003e PROMISE_SIZE) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n    await Promise.all(staff_employment.map(f =\u003e f.setStatus(Context.fields.employment_directory.app.fields.__status.variants.not_valid)));\n    return staff.save();\n}\nasync function dedublicateTable(staff) {\n    function checkRow(row) {\n        let score = 0;\n        if (row.id_1c \u0026\u0026 row.id_1c.length !== 0) {\n            score++;\n        }\n        if (row.admission_date_organization) {\n            score++;\n        }\n        if (row.admission_date_position) {\n            score++;\n        }\n        if (row.organization) {\n            score++;\n        }\n        if (row.subdivision) {\n            score++;\n        }\n        if (row.position) {\n            score++;\n        }\n        if (row.type_employment) {\n            score++;\n        }\n        return score;\n    }\n    const employment_table = staff.data.employment_table;\n    if (!employment_table || employment_table.length == 0) {\n        return;\n    }\n    for (let i = employment_table.length - 1; i \u003e= 0; i--) {\n        const row = employment_table[i];\n        const duble_index = employment_table.findIndex((r, index) =\u003e { var _a, _b, _c, _d; return ((_a = r.position) === null || _a === void 0 ? void 0 : _a.id) == ((_b = row.position) === null || _b === void 0 ? void 0 : _b.id) \u0026\u0026 ((_c = r.type_employment) === null || _c === void 0 ? void 0 : _c.code) == ((_d = row.type_employment) === null || _d === void 0 ? void 0 : _d.code) \u0026\u0026 index !== i; });\n        if (duble_index !== -1) {\n            const duble = employment_table[duble_index];\n            const duble_score = checkRow(duble);\n            const current_row_score = checkRow(row);\n            if (duble_score \u003e current_row_score) {\n                employment_table.delete(i);\n            }\n            else {\n                employment_table.delete(duble_index);\n            }\n        }\n    }\n    return staff.save();\n}\nasync function resetIterationCounter() {\n    Context.data.iteration_count = 0;\n}\nasync function incIterationCount() {\n    var _a;\n    Context.data.iteration_count = ((_a = Context.data.iteration_count) !== null \u0026\u0026 _a !== void 0 ? _a : 0) + 1;\n}\n","gatewayPairs":{},"hasTranslations":false}
