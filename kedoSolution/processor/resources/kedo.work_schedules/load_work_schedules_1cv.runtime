{"scripts":"async function getSchedules() {\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.table_name.eq(\"Catalog_ГрафикиРаботыСотрудников\")))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(null), f.is_processed.eq(false)))\n        .size(10000)\n        .all();\n    if (tables.length \u003e 0) {\n        const sortedApps = tables.sort((a, b) =\u003e {\n            const aDate = a.data.__createdAt.asDate();\n            const bDate = b.data.__createdAt.asDate();\n            return aDate - bDate;\n        });\n        const baseArray = [];\n        const workSchedules = baseArray.concat(...(sortedApps.filter(item =\u003e item.data.table_name === \"Catalog_ГрафикиРаботыСотрудников\" \u0026\u0026 !!item.data.table_data).map(item =\u003e JSON.parse(item.data.table_data))));\n        let promises = [];\n        for (let i = 0; i \u003c workSchedules.length; i++) {\n            const existsingGraphs = await Namespace.app.work_schedules.search()\n                .where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n            const item = workSchedules[i].data;\n            let graph = existsingGraphs.find((graphItem) =\u003e graphItem.data.id_1c === item[\"Ref\"]);\n            if (!graph)\n                graph = Namespace.app.work_schedules.create();\n            graph.data.__name = item[\"Description\"];\n            graph.data.id_1c = item[\"Ref\"];\n            graph.data.working_hours_week = Number(item[\"ДлительностьРабочейНедели\"]);\n            graph.data.work_days = Number(item[\"РабочихДнейВНеделе\"]);\n            graph.data.day_offs = 7 - Number(item[\"РабочихДнейВНеделе\"]);\n            graph.data.utc = graph.fields.utc.variants[\"3\"];\n            let dateNow = new Date().toISOString();\n            let datetimeNow = new Datetime(dateNow);\n            if (datetimeNow) {\n                graph.data.start_date = new TDate(datetimeNow.year, 1, 1);\n                graph.data.year_string = String(datetimeNow.year);\n                graph.data.year = datetimeNow.year;\n            }\n            Context.data.debug = ` ${item[\"Description\"]} `;\n            await graph.save();\n        }\n        await Promise.all(promises);\n        promises = [];\n        for (let app of tables) {\n            app.data.is_processed = true;\n            promises.push(app.save());\n            if (promises.length \u003e= 20) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n        await Promise.all(promises);\n    }\n}\nasync function createSchedulesObject() {\n    let schedulesObject = {};\n    const existsingSchedules = await Namespace.app.work_schedules.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n    let haveIds = false;\n    for (let schedule of existsingSchedules) {\n        if (schedule.data.id_1c) {\n            schedulesObject[schedule.data.id_1c] = [];\n            haveIds = true;\n        }\n    }\n    if (haveIds) {\n        Context.data.schedules_object = JSON.stringify(schedulesObject);\n        Context.data.no_1C_schedules = false;\n    }\n    else {\n        Context.data.no_1C_schedules = true;\n    }\n}\nconst batchSize = 10;\nconst mainLoopMaxCount = 50;\nasync function fillSchedules() {\n    Context.data.wait = false;\n    Context.data.loop_counter += 1;\n    if (Context.data.loop_counter % mainLoopMaxCount === 0) {\n        Context.data.wait = true;\n    }\n    Context.data.continue = true;\n    const tables = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.table_name.eq(\"InformationRegister_ГрафикиРаботыПоВидамВремени\")))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .size(batchSize)\n        .all();\n    const types = await Namespace.app.posted_1c_data.search()\n        .where(f =\u003e f.__deletedAt.eq(null))\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.table_name.eq(\"Catalog_ВидыИспользованияРабочегоВремени\")))\n        .size(10000)\n        .all();\n    if (types.length === 0) {\n        Context.data.debug += ' no types ';\n        Context.data.continue = false;\n        return;\n    }\n    let mappedTypes = types.map((item) =\u003e JSON.parse(item.data.table_data)).flat().map((item) =\u003e item[\"data\"]);\n    if (tables.length === 0) {\n        Context.data.continue = false;\n        return;\n    }\n    let schedulesObject = JSON.parse(Context.data.schedules_object);\n    const existsingSchedules = await Namespace.app.work_schedules.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n    const mappedData = tables.map((item) =\u003e JSON.parse(item.data.table_data)).flat().map((item) =\u003e item[\"data\"][\"Record\"]).flat();\n    let now = new Datetime();\n    for (let obj of mappedData) {\n        for (let existingSchedule of existsingSchedules) {\n            if (existingSchedule.data.id_1c === obj[\"ГрафикРаботы\"][\"data\"] \u0026\u0026 obj[\"Дата\"].slice(0, 4) === String(now.year)) {\n                let dayType = mappedTypes.find((item) =\u003e item[\"Ref\"] === obj[\"ВидУчетаВремени\"]);\n                if (!dayType) {\n                    Context.data.debug += ` !dayType `;\n                    continue;\n                }\n                let day = {\n                    date: new Datetime(obj[\"Дата\"].split(\"T\")[0]).format(\"DD.MM.YYYY\"),\n                    dateForCalendar: obj[\"Дата\"].split(\"T\")[0],\n                    description: dayType[\"Description\"],\n                    isDayOff: dayType[\"Description\"] === \"Выходные дни\" || dayType[\"Description\"] === \"Дополнительные выходные дни (оплачиваемые)\" || dayType[\"Description\"] === \"Дополнительные выходные дни (неоплачиваемые)\" ? true : false,\n                    isHoliday: dayType[\"Description\"] === \"Праздники без повышенной оплаты\" || dayType[\"Description\"] === \"Праздники\" ? true : false,\n                    isPreDayOff: false\n                };\n                schedulesObject[existingSchedule.data.id_1c].push(day);\n                break;\n            }\n        }\n    }\n    Context.data.schedules_object = JSON.stringify(schedulesObject);\n    for (let table of tables) {\n        table.data.is_processed = true;\n        await table.save();\n    }\n}\nasync function addJSONToSchedules() {\n    const existsingSchedules = await Namespace.app.work_schedules.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n    let schedulesObject = JSON.parse(Context.data.schedules_object);\n    for (let id in schedulesObject) {\n        let arrayOfDays = schedulesObject[id];\n        let schedule = existsingSchedules.find((item) =\u003e item.data.id_1c === id);\n        if (schedule) {\n            Context.data.debug += ` added json to ${schedule.data.__name} `;\n            schedule.data.json_data = JSON.stringify(arrayOfDays);\n            await schedule.save();\n        }\n    }\n}\n","gatewayPairs":{},"hasTranslations":false}
