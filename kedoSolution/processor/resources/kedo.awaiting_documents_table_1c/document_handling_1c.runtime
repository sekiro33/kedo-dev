{"scripts":"const CHUNK_SIZE = 50;\nasync function add_error(app, error_text) {\n    var _a;\n    const errors_table = (_a = Context.data.errors_table) !== null \u0026\u0026 _a !== void 0 ? _a : Context.fields.errors_table.create();\n    const error_row = errors_table.insert();\n    error_row.integration_app = app;\n    error_row.error = error_text;\n    Context.data.errors_table = errors_table;\n}\nasync function prepare_data() {\n    const row = Context.data.print_forms_table[Context.data.table_counter];\n    Context.data.overdue_date = new Datetime().addDate(0, 0, 1);\n    Context.data.print_form = row.print_form;\n    Context.data.staff = row.staff;\n    Context.data.employment_placement = row.employment_placement;\n    Context.data.type_document_1c = row.type_document_1c;\n}\nasync function check_table_counter() {\n    if (Context.data.counter \u003e= 99) {\n        return 0;\n    }\n    if (Context.data.table_counter \u003c Context.data.print_forms_table.length) {\n        return 1;\n    }\n    return -1;\n}\nasync function change_integration_app_status() {\n    const row = Context.data.print_forms_table[Context.data.table_counter];\n    const integration_app = await row.integration_app.fetch();\n    integration_app.data.processed_elma = true;\n    await integration_app.save();\n}\nasync function getIntegrationAppsPack() {\n    var _a, _b;\n    const from = (_a = Context.data.from) !== null \u0026\u0026 _a !== void 0 ? _a : 0;\n    const size = (_b = Context.data.size) !== null \u0026\u0026 _b !== void 0 ? _b : 100;\n    const integration_apps = await Context.fields.awaiting_documents_table_1c.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.processed_elma.eq(false), f.document_creation_data.eq(null)))\n        .from(from)\n        .size(size)\n        .all();\n    Context.data.integration_apps = integration_apps.length \u003e 0 ? integration_apps : undefined;\n    Context.data.from = from + size;\n}\nasync function getStaffData(integration_apps) {\n    const staff_data = [];\n    let staff_id_1c = [];\n    integration_apps\n        .filter(f =\u003e f.data.id_1c != undefined \u0026\u0026 f.data.id_1c != null)\n        .map(f =\u003e f.data.id_1c)\n        .forEach(f =\u003e {\n        let ids = JSON.parse(f);\n        ids = ids.filter(id =\u003e id != null \u0026\u0026 id != undefined \u0026\u0026 id.trim() != \"\");\n        staff_id_1c = [...staff_id_1c, ...ids];\n    });\n    const employment_placements = await Namespace.app.employment_directory.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.id_1c.in(staff_id_1c), f.__status.eq(Namespace.app.employment_directory.fields.__status.variants.actual)))\n        .size(staff_id_1c.length)\n        .all();\n    const staff_ids = employment_placements\n        .filter(f =\u003e f.data.staff != undefined)\n        .map(f =\u003e f.data.staff.id);\n    const staffs = await Context.fields.staff.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.in(staff_ids), f.__status.eq(Context.fields.staff.app.fields.__status.variants.signed_documents)))\n        .size(staff_ids.length)\n        .all();\n    for (const staff of staffs) {\n        const employment_placement = employment_placements.find(f =\u003e { var _a; return ((_a = f.data.staff) === null || _a === void 0 ? void 0 : _a.id) == staff.id; });\n        staff_data.push({\n            staff: staff,\n            employment_placement: employment_placement,\n            id_1c: employment_placement === null || employment_placement === void 0 ? void 0 : employment_placement.data.id_1c,\n            individual_id_1c: staff.data.individual_id_1c,\n        });\n    }\n    return staff_data;\n}\nasync function concatTables() {\n    var _a;\n    const print_forms_table = (_a = Context.data.print_forms_table) !== null \u0026\u0026 _a !== void 0 ? _a : Context.fields.print_forms_table.create();\n    const buffer_table = Context.data.buffer_print_forms_table;\n    if (!buffer_table || buffer_table.length == 0) {\n        return;\n    }\n    const integration_app_ids = [...new Set(buffer_table\n            .filter(f =\u003e f.integration_app != undefined)\n            .map(f =\u003e f.integration_app.id))];\n    const integration_apps = await Context.fields.integration_apps.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.in(integration_app_ids)))\n        .size(integration_app_ids.length)\n        .all();\n    const staffs = await getStaffData(integration_apps);\n    for (const integration_app of integration_apps) {\n        if (!integration_app.data.id_1c) {\n            add_error(integration_app, `Отсутствуют идентификаторы сотрудников. App field \"id_1c\" is undefined`);\n            continue;\n        }\n        let staff_guid_1c = JSON.parse(integration_app.data.id_1c);\n        staff_guid_1c = staff_guid_1c.filter(f =\u003e f != null \u0026\u0026 f != undefined);\n        if (staff_guid_1c.length == 0) {\n            add_error(integration_app, 'Отсутствуют идентификаторы сотрудников. App field \"id_1c\" is empty');\n            continue;\n        }\n        const staff_data = staffs.find(f =\u003e f.id_1c == staff_guid_1c[0]);\n        if (!staff_data || !staff_data.staff || !staff_data.employment_placement) {\n            add_error(integration_app, 'Не найден сотрудник с данным идентификатором 1С или он не трудоустроен');\n            continue;\n        }\n        if (!staff_data.employment_placement.data.organization || staff_data.employment_placement.data.organization.id != Context.data.organization.id) {\n            add_error(integration_app, `По данному месту занятости (${staff_data.employment_placement.id}) не указана организация или не совпадает с организацией инициатора`);\n            continue;\n        }\n        const doc_types = await Context.fields.type_document_1c.app.search()\n            .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n            .size(1000)\n            .all();\n        const print_forms = buffer_table\n            .filter(f =\u003e { var _a; return ((_a = f.integration_app) === null || _a === void 0 ? void 0 : _a.id) == integration_app.id; })\n            .map(f =\u003e {\n            return {\n                print_form: f.print_form,\n                doc_type_1c: f.doc_type_1c\n            };\n        });\n        if (!print_forms || print_forms.length == 0) {\n            add_error(integration_app, 'Отсутствуют печатные формы. App field \"print_forms_table\" is undefined or empty');\n            continue;\n        }\n        for (const row of print_forms) {\n            const doc_type = doc_types.find(f =\u003e { var _a; return f.data.doc_type_id_1c == ((_a = row.doc_type_1c) === null || _a === void 0 ? void 0 : _a.id); });\n            const resultTableRow = print_forms_table.insert();\n            resultTableRow.print_form = row.print_form;\n            resultTableRow.staff = staff_data.staff;\n            resultTableRow.employment_placement = staff_data.employment_placement;\n            resultTableRow.integration_app = integration_app;\n            if (!doc_type) {\n                resultTableRow.type_document_1c = doc_types.find(f =\u003e f.data.app_code == 'other_documents');\n            }\n            else {\n                resultTableRow.type_document_1c = doc_type;\n            }\n        }\n    }\n    Context.data.print_forms_table = print_forms_table;\n}\nasync function checkPrintFormsTable() {\n    return Context.data.print_forms_table \u0026\u0026 Context.data.print_forms_table.length \u003e 0 ? true : false;\n}\nasync function reset_counter() {\n    Context.data.counter = 0;\n}\nasync function increment_counter() {\n    Context.data.counter += 1;\n}\nasync function increment_table_counter() {\n    Context.data.table_counter += 1;\n}\n","gatewayPairs":{},"hasTranslations":false}
