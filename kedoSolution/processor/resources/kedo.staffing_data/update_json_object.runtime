{"scripts":"async function parseJson() {\n    Context.data.max_nesting_fact = 0;\n    let countOfIterations = 20;\n    if (Context.data.maximum_nesting_in_staffing) {\n        countOfIterations = Context.data.maximum_nesting_in_staffing;\n    }\n    let count = 0;\n    class Element {\n        constructor(data) {\n            if (data.data.__name) {\n                this._description = data.data.__name;\n            }\n            else {\n                this._description = null;\n            }\n            if (data.data.ref_key) {\n                this._ref_key = data.data.ref_key;\n            }\n            else {\n                this._ref_key = null;\n            }\n            if (data.data.owner_key) {\n                this._owner_key = data.data.owner_key;\n            }\n            else {\n                this._owner_key = null;\n            }\n            if (data.data.parent_key) {\n                this._parent_key = data.data.parent_key;\n            }\n            else {\n                this._parent_key = null;\n            }\n            if (data.data.division_key) {\n                this._division_key = data.data.division_key;\n            }\n            else {\n                this._division_key = null;\n            }\n            if (data.data.position_key) {\n                this._position_key = data.data.position_key;\n            }\n            else {\n                this._position_key = null;\n            }\n            this._element_template = {\n                description: \"\",\n                ref_key: \"\",\n                owner_key: \"\",\n                parent_key: \"\",\n                division_key: \"\",\n                position_key: \"\",\n                children: null,\n            };\n        }\n        getElement() {\n            const element = Object.assign(this._element_template);\n            element.description = this._description;\n            element.ref_key = this._ref_key;\n            element.owner_key = this._owner_key;\n            element.parent_key = this._parent_key;\n            element.division_key = this._division_key;\n            element.position_key = this._position_key;\n            return element;\n        }\n    }\n    let positionsObj;\n    positionsObj = await Namespace.app.position.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    let resultObj = { children: null };\n    let lineOfElements = [];\n    async function checkElementParent(element) {\n        if (count \u003e countOfIterations) {\n            Context.data.error += 'Превышен лимит вложенности штатного расписания ';\n            return;\n        }\n        if (element.parent_key !== \"00000000-0000-0000-0000-000000000000\") {\n            let elementParentData;\n            try {\n                elementParentData = await Namespace.app.structural_subdivision.search()\n                    .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ref_key.eq(element.parent_key)))\n                    .first();\n            }\n            catch (err) {\n                Context.data.error += 'Ошибка при поиске приложения подразделения ';\n                throw new Error(err);\n            }\n            if (elementParentData) {\n                const elementClass = new Element(elementParentData);\n                const parentElement = elementClass.getElement();\n                lineOfElements.push(parentElement);\n                count++;\n                if (count \u003e Context.data.max_nesting_fact) {\n                    Context.data.max_nesting_fact = count;\n                }\n                await checkElementParent(parentElement);\n            }\n        }\n        else {\n            let elementOwnerData;\n            try {\n                elementOwnerData = await Namespace.app.organization.search()\n                    .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ref_key.eq(element.owner_key)))\n                    .first();\n            }\n            catch (err) {\n                Context.data.error += 'Ошибка при поиске приложения юридического лица ';\n                throw new Error(err);\n            }\n            if (elementOwnerData) {\n                const elementClass = new Element(elementOwnerData);\n                const ownerElement = elementClass.getElement();\n                lineOfElements.push(ownerElement);\n            }\n        }\n    }\n    async function createElementTree(data) {\n        lineOfElements = [];\n        const elementClass = new Element(data);\n        const element = elementClass.getElement();\n        lineOfElements.push(element);\n        count = 0;\n        await checkElementParent(element);\n    }\n    function commitBranchIteartion(targetObj, dataIndex) {\n        if (dataIndex === -1) {\n            return targetObj;\n        }\n        if (targetObj.children === null) {\n            const nextTargetObj = commitBranchIteartion(lineOfElements[dataIndex], dataIndex - 1);\n            targetObj.children = [];\n            targetObj.children.push(nextTargetObj);\n        }\n        else {\n            let ifFinded = false;\n            targetObj.children.forEach((item) =\u003e {\n                if (item.ref_key === lineOfElements[dataIndex].ref_key) {\n                    const nextTargetObj = commitBranchIteartion(item, dataIndex - 1);\n                    item = nextTargetObj;\n                    ifFinded = true;\n                }\n            });\n            if (!ifFinded) {\n                const nextTargetObj = commitBranchIteartion(lineOfElements[dataIndex], dataIndex - 1);\n                targetObj.children.push(nextTargetObj);\n            }\n        }\n        return targetObj;\n    }\n    for (let i = 0; i \u003c positionsObj.length; i++) {\n        if (!positionsObj[i].data.ref_key) {\n            continue;\n        }\n        await createElementTree(positionsObj[i]);\n        resultObj = commitBranchIteartion(resultObj, lineOfElements.length - 1);\n    }\n    Context.data.json_data = JSON.stringify(resultObj);\n}\nasync function errorHandle() {\n    if (!Context.data.error) {\n        Context.data.error = \"Неизвестная ошибка выполнения сценария\";\n    }\n}\n","gatewayPairs":{},"hasTranslations":false}
