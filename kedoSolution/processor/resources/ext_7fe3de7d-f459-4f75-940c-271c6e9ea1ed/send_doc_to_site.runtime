{"scripts":"const accessToken = Namespace.params.data.api_token;\nconst userId = Namespace.params.data.user_id;\nconst headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": `Basic ${accessToken}`\n};\nconst baseUrl = \"https://ekd-integration.trudvsem.ru\";\nconst invalidFieldsRegexp = /\\[(?\u003cvalue\u003e.*)\\]/;\nasync function logError(response, error) {\n    const errorCode = response.status;\n    let responseText = await response.text();\n    Context.data.error = responseText;\n    if (!response) {\n        throw new Error(error);\n    }\n    ;\n    switch (errorCode) {\n        case 400:\n            let errMessage = \"\";\n            if (response.url.includes(\"storeSign\")) {\n                errMessage = \"Неподдерживаемый формат подписи.\";\n                Context.data.error = errMessage;\n                throw new Error(\"Неподдерживаемый формат подписи.\");\n            }\n            const regMatch = responseText.match(invalidFieldsRegexp);\n            if (!!regMatch \u0026\u0026 regMatch.length \u003e 0) {\n                const invalidFields = regMatch[1];\n                errMessage = invalidFields;\n                Context.data.error = `Не заданы обязательные поля: ${errMessage}.`;\n            }\n            ;\n            throw new Error(Context.data.error);\n        case 401:\n            throw new Error(\"Неверный api-ключ.\");\n        case 403:\n            throw new Error(\"Отсутствуют права на создание или изменение документов.\");\n        case 404:\n            throw new Error(\"Не найден работодатель, соответствующий пользователю.\");\n        case 415:\n            throw new Error(\"Документ не соответствует формату PDF/A-1 или в запросе передан тип данных, отличающийся от 'application/json'\");\n    }\n    ;\n}\n;\nasync function serialize() {\n    Context.data.api_token = accessToken;\n    Context.data.user_id = userId;\n    try {\n        const doc = await Context.data.doc.fetch();\n        let snils = Context.data.snils;\n        if (snils.includes(\"-\") || snils.includes(\" \")) {\n            snils = snils.replace(/-/g, \"\").replace(/\\s/g, \"\");\n        }\n        ;\n        let signature = \"\";\n        let fetchedDoc;\n        if (!!doc.data.__sourceRef) {\n            fetchedDoc = await doc.data.__sourceRef.fetch();\n        }\n        else {\n            fetchedDoc = doc;\n        }\n        ;\n        const fileBuffer = await fetch(await fetchedDoc.data.__file.getDownloadUrl()).then(async (resp) =\u003e resp.arrayBuffer());\n        const file = arrayBufferToBase64(fileBuffer);\n        Context.data.debug = file;\n        const fileName = await fetchedDoc.data.__file.fetch().then((r) =\u003e r.data.__name);\n        const name = fileName;\n        try {\n            const signHistory = await fetchedDoc.getSignHistory();\n            signature = signHistory[0].signs[0].sign;\n        }\n        catch (err) {\n            throw new Error(`Ошибка ${err.message}: у документа отсутствуют подписи.`);\n        }\n        ;\n        const docDataObj = {\n            userId,\n            name,\n            fileName,\n            file\n        };\n        const signDataObj = {\n            userId,\n            signatureFormat: \"CADESBES\",\n            signature,\n            signatureFileName: `${fileName}.sig`\n        };\n        const sendDocDataObj = {\n            userId,\n            snils\n        };\n        let jsonData = {\n            docData: docDataObj,\n            signData: signDataObj,\n            sendDocData: sendDocDataObj\n        };\n        Context.data.json_data_obj = JSON.stringify(jsonData);\n    }\n    catch (err) {\n        Context.data.error = err.message;\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function sendDoc() {\n    try {\n        const body = JSON.stringify(JSON.parse(Context.data.json_data_obj).docData);\n        const response = await fetch(`${baseUrl}/docs`, {\n            method: \"POST\",\n            headers,\n            body\n        });\n        if (!response.ok) {\n            await logError(response);\n        }\n        ;\n        const responseText = await response.text();\n        const responseJson = JSON.parse(responseText);\n        Context.data.doc_id = responseJson.documentId;\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function storeSign() {\n    try {\n        const body = JSON.stringify(JSON.parse(Context.data.json_data_obj).signData);\n        const docId = Context.data.doc_id;\n        const response = await fetch(`${baseUrl}/docs/${docId}/storeSign`, {\n            method: \"POST\",\n            headers,\n            body\n        });\n        if (!response.ok) {\n            await logError(response);\n        }\n        ;\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function sendDocForSigning() {\n    try {\n        const body = JSON.stringify(JSON.parse(Context.data.json_data_obj).sendDocData);\n        const docId = Context.data.doc_id;\n        const response = await fetch(`${baseUrl}/docs/${docId}/send`, {\n            method: \"POST\",\n            headers,\n            body\n        });\n        if (!response.ok) {\n            await logError(response);\n        }\n        ;\n        const inviteLink = (await response.json()).inviteLink;\n        Context.data.invite_link = inviteLink;\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nasync function getFileWithSigns() {\n    try {\n        const docId = Context.data.doc_id;\n        const response = await fetch(`${baseUrl}/docs/${docId}/signedFile?userId=${userId}`, {\n            headers: {\n                \"Authorization\": `Basic ${accessToken}`\n            }\n        });\n        if (!response.ok) {\n            await logError(response);\n        }\n        ;\n        const responseJson = await response.json();\n        const fileName = responseJson.fileName;\n        const zipFileBase64 = responseJson.file;\n        const zipFileBuffer = base64ToArrayBuffer(zipFileBase64);\n        const zipFile = await Context.fields.zip_file.create(fileName, zipFileBuffer);\n        Context.data.zip_file = zipFile;\n    }\n    catch (err) {\n        throw new Error(err.message);\n    }\n    ;\n}\n;\nfunction base64ToArrayBuffer(base64) {\n    const binary_string = atob(base64);\n    const len = binary_string.length;\n    let bytes = new Uint8Array(len);\n    for (let i = 0; i \u003c len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    ;\n    return bytes.buffer;\n}\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    let bytes = new Uint8Array(buffer);\n    let len = bytes.byteLength;\n    for (let i = 0; i \u003c len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n;\n","gatewayPairs":{},"hasTranslations":false}
