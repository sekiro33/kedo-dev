{"scripts":"const namespaceCode = [\n    \"kedo\",\n    \"kedo_ext\",\n    \"personnel_documents\",\n    \"absences\",\n    \"time_tracking\",\n    \"absences_ext\",\n    \"business_trips\",\n    \"business_trips_ext\"\n];\nconst filterElements = (from, size) =\u003e {\n    return {\n        \"active\": true,\n        \"filter\": {\n            \"eq\": [\n                {\n                    \"field\": \"kedo_status\"\n                },\n                null\n            ]\n        },\n        \"from\": from,\n        \"size\": size\n    };\n};\nconst filterStatuses = (from, size) =\u003e {\n    return {\n        \"active\": true,\n        \"from\": from,\n        \"size\": size,\n    };\n};\nasync function getToken() {\n    const token = await Context.fields.settings_app.app.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.code.eq(\"api_key\")))\n        .first();\n    if (!token || !token.data.value) {\n        throw new Error(\"Отсутствует токен\");\n    }\n    const domen = System.getBaseUrl();\n    Context.data.domen = domen;\n    Context.data.api_key = token.data.value;\n}\nasync function getAppElements(namespace, code, from, size) {\n    const request = await fetch(`${Context.data.domen}/pub/v1/app/${namespace}/${code}/list`, {\n        method: \"POST\",\n        body: JSON.stringify(filterElements(from, size)),\n        headers: {\n            Authorization: `Bearer ${Context.data.api_key}`\n        }\n    });\n    if (request.status == 429) {\n        throw new Error('Нет доступных запросов');\n    }\n    if (!request.ok) {\n        return [];\n    }\n    const data = await request.json();\n    return data.result.result;\n}\nasync function getTotalElementsCount(namespace, code) {\n    const request = await fetch(`${Context.data.domen}/pub/v1/app/${namespace}/${code}/list`, {\n        method: \"POST\",\n        body: JSON.stringify(filterElements(0, 1)),\n        headers: {\n            Authorization: `Bearer ${Context.data.api_key}`\n        }\n    });\n    if (request.status == 429) {\n        throw new Error('Нет доступных запросов');\n    }\n    if (!request.ok) {\n        return 0;\n    }\n    const data = await request.json();\n    return data.result.total;\n}\nasync function receivingStatuses() {\n    const CHUNK_SIZE = 20;\n    let elma_apps = JSON.parse(Context.data.apps_json);\n    for (let i = Context.data.iteration; i \u003c elma_apps.length; i += CHUNK_SIZE) {\n        const chunk = elma_apps.slice(i, i + CHUNK_SIZE);\n        await Promise.all(chunk.map(async (app) =\u003e {\n            const res = await fetch(`${System.getBaseUrl()}/pub/v1/app/${app.namespace}/${app.code}/settings/status`, {\n                method: \"GET\",\n                headers: {\n                    Authorization: `Bearer ${Context.data.api_key}`\n                }\n            });\n            if (res.status == 429) {\n                throw new Error('Нет доступных запросов');\n            }\n            if (res.ok) {\n                const data = await res.json();\n                app.statuses = data.statusItems;\n                Context.data.iteration += CHUNK_SIZE;\n                Context.data.apps_json = JSON.stringify(elma_apps);\n            }\n        }));\n    }\n    Context.data.iteration = 0;\n}\nasync function updateApp(namespace, code, id, kedo_status_id) {\n    const res = await fetch(`${Context.data.domen}/pub/v1/app/${namespace}/${code}/${id}/update`, {\n        method: \"POST\",\n        body: JSON.stringify({\n            \"context\": {\n                \"kedo_status\": [kedo_status_id]\n            }\n        }),\n        headers: {\n            Authorization: `Bearer ${Context.data.api_key}`\n        }\n    });\n    if (res.status == 429) {\n        throw new Error('Нет доступных запросов');\n    }\n}\nasync function mirgationStatuses() {\n    const CHUNK_SIZE = 20;\n    let elements = JSON.parse(Context.data.elements_json);\n    const statuses = await Namespace.app.statuses.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(1000)\n        .all();\n    for (let i = Context.data.iteration; i \u003c elements.length; i += CHUNK_SIZE) {\n        const chunk = elements.slice(i, i + CHUNK_SIZE);\n        await Promise.all(chunk.map(app =\u003e {\n            let kedo_status = statuses.find(f =\u003e f.data.code == app.status_code);\n            if (kedo_status \u0026\u0026 app.code == \"trip_requests\" \u0026\u0026 app.status_code == \"signed\") {\n                kedo_status = statuses.find(f =\u003e f.data.code == \"agreed_signed\");\n            }\n            if (!kedo_status) {\n                if (app.status_code == \"application_prepare\" || app.status_code == \"signing_sz\" ||\n                    app.status_code == \"signing_consent\" || app.status_code == \"signing_consent\" ||\n                    app.status_code == \"in_preparation\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"signing_application\");\n                }\n                if (app.status_code == \"agrement\" || app.status_code == \"approving\" ||\n                    app.status_code == \"under_consideration\" || app.status_code == \"not_agreed\" ||\n                    app.status_code == \"on_approval\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"approval\");\n                }\n                if (app.status_code == \"correct\" || app.status_code == \"application_correction\" ||\n                    app.status_code == \"order_correction\" || app.status_code == \"editing\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"correction\");\n                }\n                if (app.status_code == \"staff_signing\" || app.status_code == \"sign_in_process\" ||\n                    app.status_code == \"sign_by_hr\" || app.status_code == \"sign_by_employer\" ||\n                    app.status_code == \"sign_by_employee\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"signing\");\n                }\n                if (app.status_code == \"agreed\" || app.status_code == \"\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"agreed_signed\");\n                }\n                if (app.status_code == \"documents_preparation\" || app.status_code == \"\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"order_prepare\");\n                }\n                if (app.status_code == \"ok\" || app.status_code == \"assigned\" || app.status_code == \"done\" ||\n                    app.status_code == \"giving\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"issued\");\n                }\n                if (app.status_code == \"cancel\" || app.status_code == \"removed\" || app.status_code == \"rejected\" ||\n                    app.status_code == \"refusal\" || app.status_code == \"denied\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"cancelled\");\n                }\n                if (app.status_code == \"design_in_paper\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"paper_prepare\");\n                }\n                if (app.status_code == \"signed_in_paper\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"paper_signed\");\n                }\n                if (app.status_code == \"recall\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"withdrawal\");\n                }\n                if (app.status_code == \"ongoing\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"in_progress\");\n                }\n                if (app.status_code == \"end\" || app.status_code == \"finished\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"completed\");\n                }\n                if (app.status_code == \"waiting_to_pass\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"waiting_start\");\n                }\n                if (app.status_code == \"transfer\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"pending\");\n                }\n                if (app.status_code == \"signing_employee\" || app.status_code == \"familiarization\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"staff_doc_signing\");\n                }\n                if (app.status_code == \"signing_chief\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"chief_doc_signing\");\n                }\n                if (app.status_code == \"acquaintance\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"at_look\");\n                }\n                if (app.status_code == \"introduction\") {\n                    kedo_status = statuses.find(f =\u003e f.data.code == \"acquainted\");\n                }\n            }\n            if (!kedo_status) {\n                return;\n            }\n            return updateApp(app.namespace, app.code, app.__id, kedo_status.id);\n        }));\n        Context.data.iteration += CHUNK_SIZE;\n    }\n}\nasync function receivingApps() {\n    let elma_apps = [];\n    await Promise.all(namespaceCode.map(async (namespace) =\u003e {\n        const res = await fetch(`${System.getBaseUrl()}/pub/v1/scheme/namespaces/${namespace}/apps`, {\n            method: \"GET\",\n            headers: {\n                Authorization: `Bearer ${Context.data.api_key}`\n            }\n        });\n        if (res.ok) {\n            const data = await res.json();\n            data.result.result.map((app) =\u003e elma_apps.push(app));\n            Context.data.apps_json = JSON.stringify(elma_apps);\n        }\n    }));\n}\nasync function searchElements() {\n    const CHUNK_SIZE = 20;\n    let elements = [];\n    if (Context.data.elements_json \u0026\u0026 Context.data.elements_json.length \u003e 0) {\n        elements = JSON.parse(Context.data.elements_json);\n    }\n    const elma_apps = JSON.parse(Context.data.apps_json);\n    for (let index = Context.data.iteration; index \u003c elma_apps.length; index++) {\n        const app = elma_apps[index];\n        if (!app.statuses || app.statuses.length == 0)\n            continue;\n        const total_elements_count = await getTotalElementsCount(app.namespace, app.code);\n        if (total_elements_count \u003c= 0) {\n            continue;\n        }\n        let promises = [];\n        for (let i = 0; i \u003c total_elements_count; i += CHUNK_SIZE) {\n            promises.push(getAppElements(app.namespace, app.code, i, i + CHUNK_SIZE)\n                .then(data =\u003e {\n                const statuses = app.statuses;\n                const updated_elements = data.map((elem) =\u003e {\n                    const status = statuses.find(s =\u003e { var _a; return s.id == ((_a = elem.__status) === null || _a === void 0 ? void 0 : _a.status); });\n                    elem.code = app.code;\n                    elem.namespace = app.namespace;\n                    if (!status) {\n                        return elem;\n                    }\n                    elem.status_code = status.code;\n                    return elem;\n                });\n                elements.push(...updated_elements);\n            }));\n            if (promises.length \u003e 5) {\n                await Promise.all(promises);\n            }\n        }\n        await Promise.all(promises);\n        Context.data.elements_json = JSON.stringify(elements);\n        Context.data.iteration += 1;\n    }\n    Context.data.iteration = 0;\n}\n","gatewayPairs":{},"hasTranslations":false}
