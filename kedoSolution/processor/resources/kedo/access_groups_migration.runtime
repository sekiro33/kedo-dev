{"scripts":"class MyRole {\n    constructor(group, type, code) {\n        this.code = code;\n        this.group = group;\n        this.type = type;\n    }\n    getUsers() {\n        if (this.type == \"group\") {\n            return this.group.users();\n        }\n        else if (this.type == \"orgstruct\") {\n            return System.users.search().where(i =\u003e i.osIds.has(this.group)).size(10000).all();\n        }\n        else\n            return new Promise(() =\u003e this.group);\n    }\n    json() {\n        return {\n            code: this.code,\n            type: this.type\n        };\n    }\n}\nconst chunkSize = Context.data.chunk_size;\nconst namespaces = [\n    \"kedo\",\n    \"kedo_ext\",\n    \"personnel_documents\",\n    \"absences\",\n    \"time_tracking\",\n    \"absences_ext\",\n    \"business_trips\",\n    \"business_trips_ext\"\n];\nconst solutionsNames = [\n    \"kedo\",\n    \"otpuska\",\n    \"komandirovki\"\n];\nlet allDocs;\nlet allDocsSubarray;\nlet docCodes;\nconst size = 20;\nasync function getSolutions() {\n    const token = await Context.fields.settings_app.app.search().where(f =\u003e f.code.eq(\"api_key\")).first().then(r =\u003e r.data.value);\n    const domen = await Context.fields.settings_app.app.search().where(f =\u003e f.code.eq(\"domen\")).first().then(r =\u003e r.data.value);\n    if (!token || !domen) {\n        throw new Error(\"Проверьте заполненность настроек Домен и Api-токен для методов в модуле в приложении Меню настроек.\");\n    }\n    ;\n    Context.data.domen = domen;\n    Context.data.token = token;\n    const fullUrl = `https://${domen}/pub/v1/scheme/solutions`;\n    const response = await fetch(fullUrl, {\n        headers: {\n            Authorization: `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        throw new Error(await response.text());\n    }\n    ;\n    const responseJson = await response.json();\n    if (responseJson.result.result.length \u003c 1) {\n        throw new Error(\"Не найдено решений\");\n    }\n    ;\n    const solutions = responseJson.result.result.filter((solution) =\u003e solutionsNames.indexOf(solution.code) != -1).map((solution) =\u003e solution.code);\n    const allNamespaces = await getAppNamespaces(solutions);\n    allDocs = await getDocs(allNamespaces);\n    Context.data.alldocs_json = JSON.stringify(allDocs);\n    Context.data.number_chunks = Math.ceil(allDocs.length / size);\n    Context.data.iteration = 0;\n}\n;\nasync function getDocs(solutions) {\n    try {\n        let allDocs = [];\n        let promises = [];\n        for (let code of solutions) {\n            const appsUrl = `https://${Context.data.domen}/pub/v1/scheme/namespaces/${code}/apps`;\n            promises.push(fetch(appsUrl, {\n                headers: {\n                    Authorization: `Bearer ${Context.data.token}`\n                }\n            }).then(async (response) =\u003e {\n                if (!response.ok) {\n                    throw new Error(await response.text());\n                }\n                ;\n                const responseJson = await response.json();\n                const apps = responseJson.result.result;\n                if (apps.length \u003c 1) {\n                    Context.data.debug += `Не найдено приложений в ${code}`;\n                }\n                ;\n                const docs = apps.filter((app) =\u003e {\n                    return namespaces.indexOf(app.namespace) != -1 \u0026\u0026 app.type.toLowerCase() === \"document\";\n                });\n                allDocs.push(...docs);\n            }));\n        }\n        ;\n        await Promise.all(promises);\n        const mappedDocs = allDocs.map((doc) =\u003e {\n            return {\n                ns: doc.namespace,\n                code: doc.code\n            };\n        });\n        mappedDocs.push({ ns: \"kedo\", code: \"staff\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"transfer_application\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"execution_duties\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"category_assignment\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"employees_personal_data\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"medical_request\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"docs_lna\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"medical_examination\" });\n        mappedDocs.push({ ns: \"kedo\", code: \"structural_subdivision\" });\n        const checkAbsencesResponse = await fetch(`https://${Context.data.domen}/pub/v1/scheme/namespaces/absences/apps/vacations`, {\n            headers: {\n                Authorization: `Bearer ${Context.data.token}`\n            }\n        });\n        const checkBusinessTripsResponse = await fetch(`https://${Context.data.domen}/pub/v1/scheme/namespaces/business_trips/apps/businesstrip_requests`, {\n            headers: {\n                Authorization: `Bearer ${Context.data.token}`\n            }\n        });\n        if (checkAbsencesResponse.ok) {\n            mappedDocs.push({ ns: \"absences\", code: \"vacations\" });\n            mappedDocs.push({ ns: \"time_tracking\", code: \"overtime_work\" });\n        }\n        ;\n        if (checkBusinessTripsResponse.ok) {\n            mappedDocs.push({ ns: \"business_trips\", code: \"businesstrip_requests\" });\n        }\n        ;\n        return mappedDocs;\n    }\n    catch (err) {\n        throw new Error(`error at getDocs: ${err.message}`);\n    }\n}\n;\nasync function getAppNamespaces(solutions) {\n    try {\n        let allNamespaces = [];\n        for (let code of solutions) {\n            const fullUrl = `https://${Context.data.domen}/pub/v1/scheme/solutions/${code}`;\n            const response = await fetch(fullUrl, {\n                headers: {\n                    Authorization: `Bearer ${Context.data.token}`\n                }\n            });\n            if (!response.ok) {\n                throw new Error(await response.text());\n            }\n            ;\n            const responseJson = await response.json();\n            const content = responseJson.solution.content;\n            if (content.length \u003c 1) {\n                Context.data.debug += `no apps in namespace ${code}`;\n                continue;\n            }\n            ;\n            const mappedNamespaces = content.filter((ns) =\u003e namespaces.indexOf(ns.code) != -1).map((ns) =\u003e ns.code);\n            allNamespaces.push(...mappedNamespaces);\n        }\n        ;\n        return allNamespaces;\n    }\n    catch (err) {\n        throw new Error(`error at getAppNamespaces: ${err.message}`);\n    }\n}\n;\nasync function checkAppsScheme() {\n    const i = Context.data.iteration;\n    let allDocs = JSON.parse(Context.data.alldocs_json);\n    const allDocsSubarray = allDocs.slice((i * size), (i * size) + size);\n    try {\n        const domen = Context.data.domen;\n        const token = Context.data.token;\n        const promises = [];\n        allDocsSubarray.forEach(doc =\u003e {\n            promises.push(fetch(`https://${domen}/pub/v1/scheme/namespaces/${doc.ns}/apps/${doc.code}`, {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }).then(async (resp) =\u003e {\n                const respJson = await resp.json();\n                if (!respJson.success) {\n                    throw new Error(`error at ${JSON.stringify(doc)}: ${respJson.error}`);\n                }\n                ;\n                if (!respJson.application.fields.find((field) =\u003e field.code === \"access_group\")) {\n                    return \"\";\n                }\n                ;\n                return doc.code;\n            }).catch(err =\u003e {\n                throw new Error(`error at checkAppsScheme/for: ${err.message}`);\n            }));\n        });\n        const subDocCodes = await Promise.all(promises).then(resp =\u003e resp.filter(item =\u003e item));\n        if (!Context.data.doccodes_json || Context.data.doccodes_json.length \u003c 1) {\n            Context.data.doccodes_json = JSON.stringify(subDocCodes);\n        }\n        else {\n            let docCodes = JSON.parse(Context.data.doccodes_json);\n            docCodes = docCodes.concat(subDocCodes);\n            Context.data.doccodes_json = JSON.stringify(docCodes);\n        }\n    }\n    catch (err) {\n        throw new Error(`error at checkAppsScheme: ${err.message}`);\n    }\n    ;\n}\n;\nasync function getAllItems(docMeta) {\n    const domen = Context.data.domen;\n    const token = Context.data.token;\n    let allDocs = [];\n    let searchFulfilled = false;\n    let itemsCount = 0;\n    while (!searchFulfilled) {\n        const response = await fetch(`https://${domen}/pub/v1/app/${docMeta.ns}/${docMeta.code}/list`, {\n            method: \"POST\",\n            headers: {\n                Authorization: `Bearer ${token}`\n            },\n            body: JSON.stringify({\n                active: true,\n                from: itemsCount,\n                size: chunkSize,\n            })\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        ;\n        const respJson = await response.json();\n        const result = respJson.result.result;\n        if (result.length \u003c 1) {\n            searchFulfilled = true;\n            break;\n        }\n        ;\n        if (itemsCount \u003c respJson.result.total) {\n            itemsCount += result.length;\n        }\n        else {\n            searchFulfilled = true;\n            break;\n        }\n        ;\n        allDocs.push(result.map((item) =\u003e {\n            return {\n                id: item.__id,\n                ns: docMeta.ns,\n                code: docMeta.code,\n                staffId: item.kedo_staff ? item.kedo_staff[0] : item.staff ? item.staff[0] : docMeta.code === \"structural_subdivision\" || docMeta.code === \"vacation_schedule\" ? item.organization[0] : item.__id\n            };\n        }));\n    }\n    ;\n    let flatDocs = [].concat.apply([], allDocs);\n    return flatDocs;\n}\n;\nasync function splitDocs() {\n    const docs = JSON.parse(Context.data.alldocs_json);\n    const allStaff = await Context.fields.staff_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allOrgs = await Context.fields.organization_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allOrgRights = await Context.fields.org_rights_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const docCodes = JSON.parse(Context.data.doccodes_json);\n    const filteredDocs = docs.filter(doc =\u003e docCodes.indexOf(doc.code) !== -1);\n    let promises = [];\n    for (let doc of filteredDocs) {\n        promises.push(getAllItems(doc));\n    }\n    ;\n    let allDocsFiltred = [].concat.apply([], await Promise.all(promises));\n    Context.data.debug = JSON.stringify(allDocsFiltred);\n    allDocsFiltred = allDocsFiltred.filter(item =\u003e {\n        const staff = allStaff.find(s =\u003e s.id === item.staffId);\n        if (!staff \u0026\u0026 !item.staffId) {\n            return false;\n        }\n        ;\n        let organization;\n        let orgRights;\n        if (item.code == \"staff\" \u0026\u0026 staff \u0026\u0026 staff.data.employment_table \u0026\u0026 staff.data.employment_table.length \u003e 1) {\n            const allStaffOrgs = staff.data.employment_table.filter(row =\u003e row.organization).map(row =\u003e row.organization.id);\n            const orgsWithAccessRights = allOrgs.filter(org =\u003e allStaffOrgs.indexOf(org.id) != -1 \u0026\u0026 org.data.access_settings_organization);\n            const orgRightsIds = orgsWithAccessRights.map(org =\u003e org.data.access_settings_organization.id);\n            const accessSettingsWithFields = allOrgRights.filter(right =\u003e orgRightsIds.indexOf(right.id) != -1 \u0026\u0026 right.data[item.code]);\n            item.orgRightsId = accessSettingsWithFields.map(right =\u003e right.id);\n            item.isArray = true;\n            return true;\n        }\n        ;\n        if (item.code === \"structural_subdivision\" \u0026\u0026 !staff) {\n            organization = allOrgs.find(org =\u003e org.id === item.staffId);\n        }\n        else if (staff) {\n            if (!staff.data.organization) {\n                return false;\n            }\n            ;\n            organization = allOrgs.find(org =\u003e org.id === staff.data.organization.id);\n        }\n        ;\n        if (!organization || !organization.data.access_settings_organization) {\n            Context.data.debug += `no org for ${item.code} ${item.id}`;\n            return false;\n        }\n        ;\n        orgRights = allOrgRights.find(right =\u003e right.id === organization.data.access_settings_organization.id);\n        if (!orgRights) {\n            Context.data.debug += `no org rights for organization ${organization.data.__name}`;\n            return false;\n        }\n        ;\n        item.orgRightsId = orgRights.id;\n        const fieldExists = orgRights.fields[item.code];\n        if (!fieldExists) {\n            Context.data.debug += `no field ${item.code} for ${orgRights.data.__name}`;\n            return false;\n        }\n        ;\n        const roleField = orgRights.data[item.code];\n        if (!roleField || roleField.length \u003c 1) {\n            Context.data.debug += `empty field ${item.code} for ${orgRights.data.__name}`;\n            return false;\n        }\n        ;\n        return true;\n    });\n    let chunks = [];\n    for (let i = 0; i \u003c allDocsFiltred.length; i += chunkSize) {\n        const chunk = allDocsFiltred.slice(i, i + chunkSize);\n        chunks.push(chunk);\n    }\n    ;\n    if (chunks.length \u003e 0) {\n        Context.data.chunks = chunks;\n        Context.data.chunks_exists = true;\n        Context.data.iteration = 0;\n    }\n}\n;\nasync function migrateDocRights() {\n    const allOrgRights = await Context.fields.org_rights_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const domen = Context.data.domen;\n    const token = Context.data.token;\n    const promises = [];\n    let chunk = Context.data.chunks[Context.data.iteration];\n    for (let doc of chunk) {\n        if (doc.isArray) {\n            const orgRights = allOrgRights.filter(right =\u003e doc.orgRightsId.indexOf(right.id) != -1);\n            const roleFields = orgRights.map(right =\u003e {\n                return {\n                    type: \"group\",\n                    code: right.data[doc.code][0].code\n                };\n            });\n            promises.push(fetch(`https://${domen}/pub/v1/app/${doc.ns}/${doc.code}/${doc.id}/update`, {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${token}`\n                },\n                body: JSON.stringify({\n                    context: {\n                        access_group: roleFields\n                    }\n                })\n            }));\n        }\n        else {\n            const orgRights = allOrgRights.find(right =\u003e right.id === doc.orgRightsId);\n            const roleField = orgRights.data[doc.code];\n            promises.push(fetch(`https://${domen}/pub/v1/app/${doc.ns}/${doc.code}/${doc.id}/update`, {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${token}`\n                },\n                body: JSON.stringify({\n                    context: {\n                        access_group: [\n                            {\n                                type: \"group\",\n                                code: roleField[0].code\n                            }\n                        ]\n                    }\n                })\n            }));\n        }\n    }\n    ;\n    await Promise.all(promises);\n    Context.data.iteration++;\n    if (chunk.length \u003c chunkSize) {\n        Context.data.all_objects_processed = true;\n        Context.data.debug += `items processed: ${[].concat.apply([], Context.data.chunks).length}`;\n    }\n    ;\n}\n;\nasync function timeout() {\n    Context.data.iteration += 1;\n    Context.data.timer = new Datetime().add(new Duration(5, 'seconds'));\n}\n","gatewayPairs":{},"hasTranslations":false}
