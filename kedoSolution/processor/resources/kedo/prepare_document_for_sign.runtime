{"scripts":"const namespaces = [\n    \"kedo\",\n    \"personnel_documents\",\n    \"absences\",\n    \"business_trips\",\n    \"time_tracking\"\n];\nconst otherDocumentsCode = \"other_documents\";\nconst otherDocumentsNs = \"personnel_documents\";\nasync function check_file_format() {\n    const file = await Context.data.file.fetch();\n    const file_name = file.data.__name;\n    if (file_name.endsWith('.pdf')) {\n        return 1;\n    }\n    else if (file_name.endsWith('.docx') || file_name.endsWith('.xlsx')) {\n        return 2;\n    }\n    else {\n        Context.data.incorrect_file_type = true;\n        return -1;\n    }\n    ;\n}\n;\nasync function create_document() {\n    if (Context.data.document_type) {\n        const doc_type = await Context.data.document_type.fetch();\n        let doc;\n        if (doc_type.data.app_code) {\n            doc = await (await create_app_document(doc_type.data.app_code)).create();\n        }\n        else {\n            doc = await (await create_app_document(\"other_documents\")).create();\n        }\n        doc.data.__name = Context.data.app_name;\n        doc.data.line_file_name = Context.data.app_name;\n        doc.data.__file = Context.data.file;\n        doc.data.staff = Context.data.signatory_app;\n        doc.data.kedo_staff = Context.data.signatory_app;\n        doc.data.responsible = (await Context.data.__createdBy.fetch()).data.__name;\n        doc.data.responsible_user = Context.data.__createdBy;\n        await doc.save();\n        Context.data.document_id = doc.id;\n    }\n}\nasync function create_app_document(doc_type) {\n    return Namespace.factory.Global.ns.personnel_documents.app[doc_type]\n        || Namespace.factory.Global.ns.kedo.app[doc_type]\n        || Namespace.factory.Global.ns.absences.app[doc_type]\n        || Namespace.factory.Global.ns.business_trips.app[doc_type]\n        || Namespace.factory.Global.ns.time_tracking.app[doc_type];\n}\nasync function set_document() {\n    const personnelDocument = await Context.fields.personnel_document.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.eq(Context.data.document_id)))\n        .first();\n    Context.data.personnel_document = personnelDocument;\n    const documentForEmployment = await Context.fields.documents_for_employment.app.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__id.eq(Context.data.document_id)))\n        .first();\n    Context.data.documents_for_employment = documentForEmployment;\n    if (!personnelDocument \u0026\u0026 !documentForEmployment) {\n        throw new Error('Не найден кадровый документ');\n    }\n    ;\n}\n;\nasync function run_sign_process() {\n    let document;\n    if (Context.data.personnel_document) {\n        document = await Context.data.personnel_document.fetch();\n    }\n    if (Context.data.documents_for_employment) {\n        document = await Context.data.documents_for_employment.fetch();\n    }\n    const source = document.data.__sourceRef;\n    const sign_proccess = Namespace.processes.signing_process;\n    if (Context.data.signatory_staffs_organization \u0026\u0026 Context.data.whom_send \u0026\u0026 Context.data.whom_send.code === 'all_staffs') {\n        const staffs = await Context.fields.signatory_staffs.app.search()\n            .size(10000)\n            .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__status.eq(Context.fields.signatory_staffs.app.fields.__status.variants.signed_documents), f.organization.link(Context.data.signatory_staffs_organization)))\n            .all();\n        Context.data.signatory_staffs = staffs;\n    }\n    const context = {\n        personel_document: Context.data.personnel_document ? [Context.data.personnel_document.id] : [],\n        document_for_employment: Context.data.documents_for_employment ? [Context.data.documents_for_employment.id] : [],\n        staff_chief_kedo: Context.data.staff_chief_app ? [Context.data.staff_chief_app.id] : [],\n        signatory_staffs: Context.data.signatory_staffs ? Context.data.signatory_staffs.map(f =\u003e f.id) : [],\n        staff: [Context.data.signatory_app.id],\n        chief_sign_required: Context.data.chief_sign_required,\n        limit: Context.data.limit ? Context.data.limit.format() : new Datetime().addDate(0, 0, 1).format(),\n        __item: {\n            id: source.id,\n            code: source.code,\n            namespace: source.namespace\n        },\n        sign_type: [{\n                name: Context.data.sign_type.name,\n                code: Context.data.sign_type.code\n            }],\n    };\n    Context.data.debug = JSON.stringify(context);\n    await sign_proccess.run(context);\n}\nasync function create_file_name() {\n    const file = await Context.data.file.fetch();\n    const file_name = file.data.__name.replace(/\\.[^.$]+$/, '');\n    Context.data.file_name = file_name;\n}\nasync function create_app_name() {\n    if (Context.data.app_name) {\n        return;\n    }\n    Context.data.app_name = Context.data.file_name;\n}\nasync function timer_5() {\n    let currentTime = new Datetime();\n    const needTime = currentTime.add(new Duration(5, 'seconds'));\n    while (!currentTime.after(needTime)) {\n        currentTime = new Datetime();\n    }\n}\nasync function setDocFromFile() {\n    let doc;\n    if (Context.data.documents_for_employment) {\n        doc = await Context.data.documents_for_employment.fetch();\n    }\n    else {\n        doc = await Context.data.personnel_document.fetch();\n    }\n    ;\n    const source = await doc.data.__sourceRef.fetch();\n    Context.data.file = source.data.__file;\n}\n;\nasync function getDocsNamespaces() {\n    let apps = [];\n    const tokenSetting = await Namespace.app.settings.search().where(f =\u003e f.code.eq(\"api_key\")).first();\n    if (!tokenSetting || !tokenSetting.data.value) {\n        throw new Error(\"Проверьте наличие и заполненность настройки 'Api-ключ для методов в модуле' в Меню настроек\");\n    }\n    ;\n    const token = tokenSetting.data.value;\n    Context.data.token = token;\n    const baseUrl = System.getBaseUrl();\n    for (let ns of namespaces) {\n        let res;\n        try {\n            res = await fetch(`${baseUrl}/pub/v1/scheme/namespaces/${ns}/apps`, {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            });\n            if (!res.ok) {\n                continue;\n            }\n            ;\n            const responseJson = await res.json();\n            apps.push(...responseJson.result.result);\n        }\n        catch (_a) {\n            throw new Error(await res.text());\n        }\n        ;\n    }\n    ;\n    try {\n        const jsonData = JSON.parse(Context.data.goskey_docs_json);\n        for (let item of jsonData.files) {\n            const appType = apps.find((app) =\u003e app.code === item.doc_type);\n            if (!appType) {\n                item.doc_type = otherDocumentsCode;\n                item.doc_ns = otherDocumentsNs;\n            }\n            else {\n                item.doc_ns = appType.namespace;\n            }\n            ;\n        }\n        ;\n        Context.data.goskey_docs_json = JSON.stringify(jsonData);\n    }\n    catch (err) {\n        throw new Error(`error at parse: ${err.message}`);\n    }\n}\n;\nasync function createDocsByFiles() {\n    const jsonData = JSON.parse(Context.data.goskey_docs_json);\n    const staff = await Context.data.signatory_app.fetch();\n    const responsible = await Context.data.__createdBy.fetch();\n    const responsibleName = responsible.data.__name;\n    const baseUrl = System.getBaseUrl();\n    const token = Context.data.token;\n    let refItems = [];\n    for (let item of jsonData.files) {\n        let context = {\n            responsible_user: [\n                responsible.id\n            ],\n            responsible: responsibleName,\n            staff: [\n                staff.id\n            ],\n            __name: item.doc_name,\n            line_file_name: item.doc_name,\n            __file: [\n                item.file_id\n            ]\n        };\n        let createFileResponse;\n        try {\n            createFileResponse = await fetch(`${baseUrl}/pub/v1/app/${item.doc_ns}/${item.doc_type}/create`, {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${token}`\n                },\n                body: JSON.stringify({\n                    context: {\n                        responsible_user: [\n                            responsible.id\n                        ],\n                        responsible: responsibleName,\n                        staff: [\n                            staff.id\n                        ],\n                        __name: item.doc_name,\n                        line_file_name: item.doc_name,\n                        __file: [\n                            item.file_id\n                        ]\n                    }\n                })\n            });\n            if (!createFileResponse.ok) {\n                delete context[\"staff\"];\n                context.kedo_staff = [staff.id];\n                createFileResponse = await fetch(`${baseUrl}/pub/v1/app/${item.doc_ns}/${item.doc_type}/create`, {\n                    method: \"POST\",\n                    headers: {\n                        Authorization: `Bearer ${token}`\n                    },\n                    body: JSON.stringify(context)\n                });\n            }\n            ;\n            const responseJson = await createFileResponse.json();\n            Context.data.debug = JSON.stringify(responseJson);\n            refItems.push(new RefItem(item.doc_ns, item.doc_type, responseJson.item.__id));\n        }\n        catch (err) {\n            throw new Error(`Ошибка при создании документа ${item.doc_name}`);\n        }\n        ;\n    }\n    ;\n    Context.data.goskey_docs = refItems;\n}\n;\nasync function getCurrentFile() {\n    try {\n        const file = await Context.data.goskey_files[Context.data.iteration++].fetch();\n        const fileName = file.data.__name.replace(/\\.[^.$]+$/, '');\n        Context.data.file = file;\n        Context.data.incorrect_file_type = false;\n        Context.data.file_name = fileName;\n    }\n    catch (_a) {\n        Context.data.all_files_processed = true;\n    }\n}\n;\nasync function refreshFileLink() {\n    const docsJson = JSON.parse(Context.data.goskey_docs_json);\n    if (Context.data.incorrect_file_type) {\n        docsJson.files.filter(item =\u003e item.file_id !== Context.data.file.id);\n        Context.data.goskey_docs_json = JSON.stringify(docsJson);\n        return;\n    }\n    ;\n    const currentItem = docsJson.files.find(item =\u003e item.file_id === Context.data.file.id);\n    Context.data.debug += ` ${Context.data.file.id} `;\n    currentItem.file_id = Context.data.processed_file.id;\n    Context.data.goskey_docs_json = JSON.stringify(docsJson);\n}\n;\nasync function runGoskeyProcess() {\n    const staff = await Context.data.signatory_app.fetch();\n    const snils = staff.data.snils;\n    const goskeyFiles = Context.data.goskey_docs.map(item =\u003e {\n        return {\n            namespace: item.namespace,\n            code: item.code,\n            id: item.id\n        };\n    });\n    const signExpiration = Context.data.limit ? Context.data.limit.format() : new Datetime().addDate(0, 0, 1).format();\n    const packageName = Context.data.package_name;\n    const userId = staff.data.ext_user.id;\n    const signType = Context.data.goskey_sign_type;\n    const baseUrl = System.getBaseUrl();\n    const token = Context.data.token;\n    let runProcessResponse;\n    try {\n        runProcessResponse = await fetch(`${baseUrl}/pub/v1/bpm/template/ext_7fb0a0d0-fc8d-452e-843f-6a7f2f28a8bf/send_docs_to_goskey/run`, {\n            method: \"POST\",\n            headers: {\n                Authorization: `Bearer ${token}`\n            },\n            body: JSON.stringify({\n                context: {\n                    snils,\n                    docs_for_sign: goskeyFiles,\n                    user: [\n                        userId\n                    ],\n                    sign_expiration: signExpiration,\n                    docs_description: packageName,\n                    sign_type: [\n                        {\n                            name: signType.name,\n                            code: signType.code,\n                        }\n                    ]\n                }\n            })\n        });\n        if (!runProcessResponse.ok) {\n            throw new Error(`Ошибка при запуске процесса: ${await runProcessResponse.text()}`);\n        }\n        ;\n    }\n    catch (err) {\n        Context.data.debug = await runProcessResponse.text();\n    }\n}\n;\nasync function getSignatoryApp() {\n    if (!Context.data.signatories || Context.data.signatories.length == 0) {\n        return;\n    }\n    let staffs = await Namespace.app.staff.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ext_user.in(Context.data.signatories)))\n        .size(Context.data.signatories.length)\n        .all();\n    staffs = staffs.filter(s =\u003e { var _a; return s.id != ((_a = Context.data.signatory_app) === null || _a === void 0 ? void 0 : _a.id); });\n    if (staffs.length != 0) {\n        Context.data.staff_chief_app = staffs[0];\n    }\n}\n","gatewayPairs":{},"hasTranslations":false}
