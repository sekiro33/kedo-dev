{"scripts":"async function parseJson() {\n    Context.data.max_nesting_fact = 0;\n    let countOfIterations = 40;\n    const savedIds = [];\n    if (Context.data.maximum_nesting_in_staffing) {\n        countOfIterations = Context.data.maximum_nesting_in_staffing;\n    }\n    let count = 0;\n    class Element {\n        constructor(data) {\n            this._id = data.data.__id ? data.data.__id : null;\n            this._description = data.data.__name ? data.data.__name : null;\n            this._ref_key = data.data.ref_key ? data.data.ref_key : null;\n            this._owner_key = data.data.owner_key ? data.data.owner_key : null;\n            this._parent_key = data.data.subdivision ? data.data.subdivision.id : null;\n            this._division_key = data.data.division_key ? data.data.division_key : null;\n            this._position_key = data.data.position_key ? data.data.position_key : null;\n            this._org_id = data.data.organization ? data.data.organization.id : null;\n            this._element_template = {\n                description: \"\",\n                id: \"\",\n                ref_key: \"\",\n                owner_key: \"\",\n                parent_key: \"\",\n                division_key: \"\",\n                position_key: \"\",\n                org_id: \"\",\n                children: null,\n            };\n        }\n        getElement() {\n            const element = Object.assign(this._element_template);\n            element.id = this._id;\n            element.description = this._description;\n            element.ref_key = this._ref_key;\n            element.owner_key = this._owner_key;\n            element.parent_key = this._parent_key;\n            element.division_key = this._division_key;\n            element.position_key = this._position_key;\n            element.org_id = this._org_id;\n            element.is_subdiv = false;\n            return element;\n        }\n    }\n    const positionsObj = await Namespace.app.position.search().where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).where((f, g) =\u003e g.or(f.is_closed.eq(false), f.is_closed.eq(null))).size(10000).all();\n    const subdivisions = await Namespace.app.structural_subdivision.search().where(f =\u003e f.__deletedAt.eq(null)).where((f, g) =\u003e g.or(f.is_closed.eq(false), f.is_closed.eq(null))).size(10000).all();\n    const organisations = await Namespace.app.organization.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    let resultObj = { children: null };\n    let lineOfElements = [];\n    async function checkElementParent(element) {\n        if (count \u003e countOfIterations) {\n            Context.data.error += 'Превышен лимит вложенности штатного расписания ';\n            return;\n        }\n        if (element.parent_key != null) {\n            if (element.parent_key !== \"00000000-0000-0000-0000-000000000000\") {\n                let elementParentData;\n                try {\n                    elementParentData = subdivisions.find(x =\u003e x.data.__id == element.parent_key);\n                }\n                catch (err) {\n                    Context.data.error += 'Ошибка при поиске приложения подразделения ';\n                    throw new Error(err);\n                }\n                if (elementParentData) {\n                    const elementClass = new Element(elementParentData);\n                    const parentElement = elementClass.getElement();\n                    lineOfElements.push(parentElement);\n                    count++;\n                    if (count \u003e Context.data.max_nesting_fact) {\n                        Context.data.max_nesting_fact = count;\n                    }\n                    await checkElementParent(parentElement);\n                }\n            }\n        }\n        else {\n            let elementOwnerData;\n            try {\n                elementOwnerData = organisations.find(x =\u003e x.data.__id == element.org_id);\n            }\n            catch (err) {\n                throw new Error(err);\n            }\n            if (elementOwnerData) {\n                const elementClass = new Element(elementOwnerData);\n                const ownerElement = elementClass.getElement();\n                lineOfElements.push(ownerElement);\n            }\n        }\n    }\n    async function createElementTree(data) {\n        lineOfElements = [];\n        const elementClass = new Element(data);\n        const element = elementClass.getElement();\n        lineOfElements.push(element);\n        count = 0;\n        await checkElementParent(element);\n    }\n    function commitBranchIteartion(targetObj, dataIndex) {\n        if (dataIndex === -1) {\n            return targetObj;\n        }\n        if (targetObj.children === null) {\n            const nextTargetObj = commitBranchIteartion(lineOfElements[dataIndex], dataIndex - 1);\n            targetObj.children = [];\n            targetObj.children.push(nextTargetObj);\n        }\n        else {\n            let ifFinded = false;\n            targetObj.children.forEach((item) =\u003e {\n                if (item.ref_key === lineOfElements[dataIndex].ref_key) {\n                    const nextTargetObj = commitBranchIteartion(item, dataIndex - 1);\n                    item = nextTargetObj;\n                    ifFinded = true;\n                }\n            });\n            if (!ifFinded) {\n                const nextTargetObj = commitBranchIteartion(lineOfElements[dataIndex], dataIndex - 1);\n                targetObj.children.push(nextTargetObj);\n            }\n        }\n        return targetObj;\n    }\n    let promises = [];\n    for (let i = 0; i \u003c organisations.length; i++) {\n        if (!organisations[i].data.ref_key) {\n            organisations[i].data.ref_key = organisations[i].data.__id;\n            promises.push(organisations[i].save());\n        }\n    }\n    await Promise.all(promises);\n    promises = [];\n    for (let i = 0; i \u003c positionsObj.length; i++) {\n        Context.data.debug += ` ${i} `;\n        let positionItem = positionsObj[i];\n        if (!positionItem.data.ref_key) {\n            positionItem.data.ref_key = positionItem.data.__id;\n            await positionItem.save();\n        }\n        await createElementTree(positionsObj[i]);\n        resultObj = commitBranchIteartion(resultObj, lineOfElements.length - 1);\n        Context.data.debug += ` done `;\n    }\n    const processedDivIDs = [];\n    function createTreeForEmptySubdiv(subdivision, tree) {\n        var _a;\n        const element = new Element(subdivision);\n        const resultObjString = JSON.stringify(resultObj);\n        processedDivIDs.push(subdivision.data.__id);\n        if (!tree) {\n            tree = element.getElement();\n        }\n        else {\n            const elementObj = element.getElement();\n            elementObj.is_subdiv = true;\n            elementObj.children = [tree];\n            tree = elementObj;\n        }\n        if (!!subdivision.data.subdivision) {\n            const parentSubdivId = subdivision.data.subdivision.id;\n            Context.data.debug += `SUBDIV ID ${parentSubdivId}`;\n            if (resultObjString.includes(parentSubdivId)) {\n                return [tree, parentSubdivId];\n            }\n            const parentSubdiv = subdivisions.find((item) =\u003e {\n                return item.data.__id === parentSubdivId;\n            });\n            if (!!parentSubdiv)\n                return createTreeForEmptySubdiv(parentSubdiv, tree);\n        }\n        else {\n            const orgId = (_a = subdivision.data.organization) === null || _a === void 0 ? void 0 : _a.id;\n            if (!orgId) {\n                return [null, \"\"];\n            }\n            if (resultObjString.includes(orgId)) {\n                return [tree, orgId];\n            }\n            else {\n                Context.data.debug += ` Couldnt find org of subdivision ${subdivision.data.__id} in resultObj`;\n                return [null, \"\"];\n            }\n        }\n        return [null, \"\"];\n    }\n    function addChildByParentId(targetObj, parentId, child) {\n        if (!targetObj.children || targetObj.children.length === 0) {\n            return;\n        }\n        for (let i = 0; i \u003c targetObj.children.length; i++) {\n            const element = targetObj.children[i];\n            if (element.id === parentId) {\n                if (Array.isArray(element.children)) {\n                    element.children.push(child);\n                }\n                else {\n                    element.children = [child];\n                }\n                return;\n            }\n            addChildByParentId(element, parentId, child);\n        }\n        return;\n    }\n    if (!Context.data.error) {\n        const jsonObj = Application.create();\n        jsonObj.data.__name = \"Объект штатного расписания от \" + new Datetime().format();\n        jsonObj.data.json_staffing_data = JSON.stringify(resultObj);\n        await jsonObj.save();\n    }\n}\nasync function errorHandle() {\n    if (!Context.data.error) {\n        Context.data.error = \"Неизвестная ошибка выполнения сценария\";\n    }\n}\n","gatewayPairs":{},"hasTranslations":false}
