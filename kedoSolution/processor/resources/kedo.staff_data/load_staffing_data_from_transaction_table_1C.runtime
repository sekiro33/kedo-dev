{"scripts":"async function loadPositionsAndSubdividions() {\n    Context.data.debug += \" in load \";\n    const allDivisions = await Namespace.app.structural_subdivision.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const allPositions = await Namespace.app.position.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const searchData = await Namespace.app.posted_1c_data.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.table_name.eq(\"Catalog_ШтатноеРасписание\")))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .size(10000).all();\n    const sortedApps = searchData.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const baseArray = [];\n    const latestData = baseArray.concat(...(sortedApps.filter(item =\u003e item.data.table_name === \"Catalog_ШтатноеРасписание\" \u0026\u0026 !!item.data.table_data).map(item =\u003e JSON.parse(item.data.table_data))));\n    let data1C = [];\n    if (!!searchData) {\n        data1C = latestData.map((item) =\u003e item.data);\n    }\n    else {\n        Context.data.debug += \" return \";\n        return;\n    }\n    try {\n        let promises = [];\n        const employmentType = Namespace.app.position.fields.employment_type.variants.main_workplace;\n        const workRelationsTypeApps = await Namespace.app.type_employment_relationship.search()\n            .where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n        const workRelationsType = workRelationsTypeApps.find(item =\u003e {\n            return item.data.__name.includes(\"Бессрочный\");\n        });\n        const workSchedules = await Namespace.app.work_schedules.search()\n            .where((f, g) =\u003e g.and(f.__deletedAt.eq(null))).size(10000).all();\n        Context.data.debug += `length is ${data1C.length}`;\n        const positionRefArr = [];\n        for (let i = 0; i \u003c data1C.length; i++) {\n            const data = data1C[i];\n            Context.data.debug += data['Должность'];\n            if (data['Должность'] === \"00000000-0000-0000-0000-000000000000\" || !!(positionRefArr.find((ref) =\u003e ref === data[\"Ref\"]))) {\n                continue;\n            }\n            let app;\n            app = allPositions.find(f =\u003e f.data.ref_key === data[\"Ref\"]);\n            const isClosed = data[\"Закрыта\"];\n            if (!app \u0026\u0026 isClosed)\n                continue;\n            if (!app) {\n                app = Namespace.app.position.create();\n            }\n            app.data.is_closed = false;\n            if (isClosed) {\n                app.data.is_closed = true;\n            }\n            if (!!data[\"ГрафикРаботыСотрудников\"]) {\n                const workSchedule = workSchedules.find(item =\u003e item.data.id_1c === data[\"ГрафикРаботыСотрудников\"][\"data\"]);\n                app.data.work_schedules = workSchedule;\n            }\n            app.data.__name = data[\"Description\"];\n            app.data.ref_key = data[\"Ref\"];\n            app.data.owner_key = data[\"Owner\"][\"data\"];\n            app.data.parent_key = data[\"Parent\"];\n            app.data.position_key = data[\"Должность\"];\n            app.data.remote_work = false;\n            app.data.employment_type = employmentType;\n            app.data.type_employment_relationship = workRelationsType;\n            const salaryValue = data[\"ОкладТариф\"];\n            app.data.salary = new Money(salaryValue, 'RUB');\n            const date = data[\"ДатаУтверждения\"].split('T')[0].split('-');\n            const year = date[0];\n            const month = date[1];\n            const day = date[2];\n            app.data.approval_date = new TDate(year, month, day);\n            app.data.quantity = Number(data[\"КоличествоСтавок\"]);\n            positionRefArr.push(data[\"Ref\"]);\n            promises.push(app.save());\n            if (promises.length \u003e 30) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n        await Promise.all(promises);\n        promises = [];\n        const divisionRefArr = [];\n        for (let i = 0; i \u003c data1C.length; i++) {\n            const data = data1C[i];\n            if (data['Должность'] !== \"00000000-0000-0000-0000-000000000000\" || !!(divisionRefArr.find((ref) =\u003e ref === data[\"Ref\"]))) {\n                continue;\n            }\n            let app;\n            app = allDivisions.find(f =\u003e f.data.ref_key === data[\"Ref\"]);\n            const isClosed = data[\"Закрыта\"];\n            if (!app \u0026\u0026 isClosed)\n                continue;\n            if (!app) {\n                app = Namespace.app.structural_subdivision.create();\n            }\n            app.data.is_closed = false;\n            if (isClosed) {\n                app.data.is_closed = true;\n            }\n            app.data.__name = data[\"Description\"];\n            app.data.ref_key = data[\"Ref\"];\n            app.data.subdiv_key = data[\"Подразделение\"];\n            app.data.owner_key = data[\"Owner\"][\"data\"];\n            app.data.parent_key = data[\"Parent\"];\n            app.data.position_key = data[\"Должность\"];\n            divisionRefArr.push(data[\"Ref\"]);\n            promises.push(app.save());\n            if (promises.length \u003e 30) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n        Context.data.debug += `done length ${data1C.length}`;\n        await Promise.all(promises);\n    }\n    catch (e) {\n        Context.data.debug += `An error occured: name ${e.name}, message ${e.message}`;\n    }\n    let promises = [];\n    for (let app of searchData) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= 20) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function loadOrgs() {\n    var _a, _b, _c, _d;\n    const searchData = await Namespace.app.posted_1c_data.search()\n        .where((f) =\u003e f.__deletedAt.eq(null))\n        .where((f, g) =\u003e g.or(f.table_name.eq(\"Catalog_Организации\"), f.table_name.eq(\"InformationRegister_СведенияОбОтветственныхЛицах\")))\n        .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n        .size(10000).all();\n    if (!searchData) {\n        return;\n    }\n    const sortedApps = searchData.sort((a, b) =\u003e {\n        const aDate = a.data.__createdAt.asDate();\n        const bDate = b.data.__createdAt.asDate();\n        return aDate - bDate;\n    });\n    const latestData = parseData(sortedApps, \"Catalog_Организации\");\n    let data1C = [];\n    if (!!latestData) {\n        data1C = latestData.map((item) =\u003e item.data);\n    }\n    else {\n        return;\n    }\n    const loadedOrgsIds = [];\n    for (let i = 0; i \u003c data1C.length; i++) {\n        const ownerData = data1C[i];\n        if (!!(loadedOrgsIds.find((ref) =\u003e ref === ownerData.Ref))) {\n            continue;\n        }\n        let appEntity;\n        let appOrganization;\n        appOrganization = await Namespace.app.organization.search()\n            .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ref_key.eq(ownerData.Ref)))\n            .first();\n        if (appOrganization \u0026\u0026 appOrganization.data.entity) {\n            appEntity = await appOrganization.data.entity.fetch();\n        }\n        else {\n            appOrganization = await Namespace.app.organization.search()\n                .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.inn.eq(ownerData[\"ИНН\"])))\n                .first();\n            if (!appOrganization) {\n                appOrganization = Namespace.app.organization.create();\n            }\n            else {\n                if (appOrganization.data.entity)\n                    appEntity = await appOrganization.data.entity.fetch();\n            }\n        }\n        if (!appEntity) {\n            appEntity = await Context.fields.app_legal_entity.app.search()\n                .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.__name.eq(ownerData[\"Description\"])))\n                .first();\n        }\n        if (!appEntity) {\n            appEntity = Context.fields.app_legal_entity.app.create();\n        }\n        if (appEntity) {\n            appEntity.data.__name = ownerData[\"Description\"];\n            appEntity.data._full_legal_name = ownerData[\"НаименованиеПолное\"];\n            if (!appEntity.data._inn) {\n                appEntity.data._inn = ownerData[\"ИНН\"];\n            }\n            if (!appEntity.data._ogrn) {\n                appEntity.data._ogrn = ownerData[\"ОГРН\"];\n            }\n            if (!appEntity.data._email || appEntity.data._email.length === 0) {\n                const email = (_a = ownerData[\"КонтактнаяИнформация\"]) === null || _a === void 0 ? void 0 : _a.find((info) =\u003e info[\"Тип\"] === \"АдресЭлектроннойПочты\");\n                if (email) {\n                    appEntity.data._email = [{\n                            email: email[\"АдресЭП\"],\n                            type: EmailType.Work,\n                        }];\n                }\n            }\n            try {\n                if (!appEntity.data._phone) {\n                    const phone = (_b = ownerData[\"КонтактнаяИнформация\"]) === null || _b === void 0 ? void 0 : _b.find((info) =\u003e info[\"Тип\"] === \"Телефон\");\n                    appEntity.data._phone = {\n                        tel: phone[\"Представление\"].replace(/\\D+/g, \"\"),\n                        type: PhoneType.Main,\n                    };\n                }\n            }\n            catch (e) {\n            }\n            try {\n                const legalAddressType = \"6b0a2669-1bb5-4c9a-9466-54433ac0a955\";\n                const actualAddressType = \"afa527f2-8b59-4c20-95ae-d0d5a08111ee\";\n                if (!appEntity.data._legal_address) {\n                    const addressField = (_c = ownerData[\"КонтактнаяИнформация\"]) === null || _c === void 0 ? void 0 : _c.find((info) =\u003e info[\"Тип\"] === \"Адрес\" \u0026\u0026 info[\"Вид\"] === legalAddressType);\n                    if (addressField) {\n                        appEntity.data._legal_address = addressField[\"Представление\"];\n                    }\n                }\n                if (!appEntity.data._actual_address) {\n                    const addressField = (_d = ownerData[\"КонтактнаяИнформация\"]) === null || _d === void 0 ? void 0 : _d.find((info) =\u003e info[\"Тип\"] === \"Адрес\" \u0026\u0026 info[\"Вид\"] === actualAddressType);\n                    if (addressField) {\n                        appEntity.data._actual_address = addressField[\"Представление\"];\n                    }\n                }\n            }\n            catch (e) { }\n            await appEntity.save();\n        }\n        appOrganization.data.entity = appEntity;\n        appOrganization.data.ref_key = ownerData.Ref;\n        appOrganization.data.owner_key = '';\n        appOrganization.data.parent_key = '';\n        appOrganization.data.position_key = '';\n        appOrganization.data.inn = ownerData[\"ИНН\"];\n        appOrganization.data.base_1c = ownerData[\"ИмяБазы\"];\n        if (ownerData.Ref !== ownerData[\"ГоловнаяОрганизация\"]) {\n            const app = await Namespace.app.organization.search()\n                .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ref_key.eq(ownerData[\"ГоловнаяОрганизация\"])))\n                .first();\n            if (app) {\n                appOrganization.data.head_org = app;\n            }\n        }\n        loadedOrgsIds.push(ownerData.Ref);\n        await appOrganization.save();\n    }\n    let promises = [];\n    for (let app of searchData) {\n        app.data.is_processed = true;\n        promises.push(app.save());\n        if (promises.length \u003e= 20) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\nasync function fillAppsLinks() {\n    const allSubdivisions = await Namespace.app.structural_subdivision.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    const allPositions = await Namespace.app.position.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    Context.data.debug += `pos ${allPositions.length} subdiv  ${allSubdivisions.length}`;\n    for (const subdivisionParent of allSubdivisions) {\n        const subdivisionsChild = allSubdivisions.filter(f =\u003e f.data.parent_key === subdivisionParent.data.ref_key || f.data.parent_key === subdivisionParent.data.subdiv_key);\n        for (let subdivisionChild of subdivisionsChild) {\n            subdivisionChild.data.subdivision = subdivisionParent;\n            try {\n                await subdivisionChild.save();\n            }\n            catch (e) {\n                Context.data.debug += `SUBDIV ${subdivisionParent.data.__name} An error occured: name ${e.name}, message ${e.message}`;\n            }\n        }\n    }\n}\nasync function fillPosLinks() {\n    const allSubdivisions = await Namespace.app.structural_subdivision.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    const allPositions = await Namespace.app.position.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    Context.data.debug += `pos ${allPositions.length} subdiv  ${allSubdivisions.length}`;\n    let promises = [];\n    for (const subdivisionParent of allSubdivisions) {\n        const positionsChild = allPositions.filter(f =\u003e f.data.parent_key === subdivisionParent.data.ref_key || f.data.parent_key === subdivisionParent.data.subdiv_key);\n        for (let positionChild of positionsChild) {\n            positionChild.data.subdivision = subdivisionParent;\n            promises.push(positionChild.save());\n            if (promises.length \u003e 30) {\n                try {\n                    await Promise.all(promises);\n                }\n                catch (e) {\n                    Context.data.debug += `SUBDIV ${subdivisionParent.data.__name} An error occured: name ${e.name}, message ${e.message}`;\n                }\n                promises = [];\n            }\n        }\n        await Promise.all(promises);\n    }\n}\nasync function fillOrgHeadPositions() {\n    try {\n        const tables = await Namespace.app.posted_1c_data.search()\n            .where(f =\u003e f.__deletedAt.eq(null))\n            .where((f, g) =\u003e g.or(f.table_name.eq(\"InformationRegister_ПозицииРуководителейПодразделений\"), f.table_name.eq(\"Catalog_СтруктураПредприятия\")))\n            .where((f, g) =\u003e g.or(f.is_processed.eq(false), f.is_processed.eq(null)))\n            .size(10000).all();\n        const sortedApps = tables.length \u003e= 2 ? tables.sort((a, b) =\u003e {\n            const aDate = a.data.__createdAt.asDate();\n            const bDate = b.data.__createdAt.asDate();\n            return aDate - bDate;\n        }) : tables;\n        const baseArray = [];\n        const headPositions = baseArray.concat(...(sortedApps.filter(item =\u003e item.data.table_name === \"InformationRegister_ПозицииРуководителейПодразделений\" \u0026\u0026 !!item.data.table_data).map(item =\u003e JSON.parse(item.data.table_data))));\n        const sdStructure = baseArray.concat(...(sortedApps.filter(item =\u003e item.data.table_name === \"Catalog_СтруктураПредприятия\" \u0026\u0026 !!item.data.table_data).map(item =\u003e JSON.parse(item.data.table_data))));\n        if (!!sdStructure \u0026\u0026 !!headPositions \u0026\u0026 sdStructure.length \u003e 0 \u0026\u0026 headPositions.length \u003e 0) {\n            const headData = headPositions.map((item) =\u003e item.data[\"Record\"]);\n            const sdData = sdStructure.map((item) =\u003e item.data);\n            const subdivisions = await Namespace.app.structural_subdivision.search()\n                .where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n            const positions = await Namespace.app.position.search()\n                .where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n            for (let subdivision of headData) {\n                const posRef = subdivision[0][\"ПозицияШтатногоРасписания\"];\n                const sdStructureRef = subdivision[0][\"Подразделение\"];\n                const struct = sdData.find((item) =\u003e item.Ref === sdStructureRef);\n                if (!struct)\n                    continue;\n                const sdRef = struct[\"Источник\"].data;\n                Context.data.debug += `found pos and sd ${posRef} ${sdRef}`;\n                const foundSubdivision = subdivisions.find(item =\u003e {\n                    return item.data.subdiv_key === sdRef;\n                });\n                const foundPosition = positions.find(item =\u003e {\n                    return item.data.ref_key === posRef;\n                });\n                if (!!foundPosition \u0026\u0026 !!foundSubdivision) {\n                    Context.data.debug += `success!!`;\n                    foundSubdivision.data.position = foundPosition;\n                    await foundSubdivision.save();\n                }\n            }\n        }\n        let promises = [];\n        for (let app of tables) {\n            app.data.is_processed = true;\n            promises.push(app.save());\n            if (promises.length \u003e= 20) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n        await Promise.all(promises);\n    }\n    catch (e) {\n        Context.data.debug += ` name ${e.name}, message ${e.message} `;\n    }\n}\nasync function linkFix() {\n    const positions = await Namespace.app.position.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.subdivision.eq(null))).size(10000).all();\n    if (!positions || positions.length === 0) {\n        return;\n    }\n    const positionParentKeys = positions.filter(item =\u003e !!item.data.parent_key).map(item =\u003e item.data.parent_key);\n    const subdivs = await Namespace.app.structural_subdivision.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null), f.ref_key.in(positionParentKeys))).size(10000).all();\n    Context.data.debug += \" length \" + positions.length;\n    for (let i = 0; i \u003c positions.length; i++) {\n        const curPos = positions[i];\n        const parentKey = curPos.data.parent_key;\n        if (!parentKey)\n            continue;\n        const subdiv = subdivs.find(div =\u003e div.data.ref_key === parentKey);\n        curPos.data.subdivision = subdiv;\n        await curPos.save();\n    }\n}\nasync function fillOrgLinks() {\n    const allOrganizations = await Namespace.app.organization.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    const allSubdivisions = await Namespace.app.structural_subdivision.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    const allPositions = await Namespace.app.position.search()\n        .where((f, g) =\u003e g.and(f.__deletedAt.eq(null)))\n        .size(10000)\n        .all();\n    let promises = [];\n    for (const organiaztion of allOrganizations) {\n        try {\n            const subdivisions = allSubdivisions.filter(f =\u003e f.data.owner_key === organiaztion.data.ref_key);\n            const positions = allPositions.filter(f =\u003e f.data.owner_key === organiaztion.data.ref_key);\n            for (let subdivision of subdivisions) {\n                subdivision.data.organization = organiaztion;\n                promises.push(subdivision.save());\n                if (promises.length \u003e 30) {\n                    await Promise.all(promises);\n                    promises = [];\n                }\n            }\n            await Promise.all(promises);\n            for (let position of positions) {\n                position.data.organization = organiaztion;\n                promises.push(position.save());\n                if (promises.length \u003e 30) {\n                    await Promise.all(promises);\n                    promises = [];\n                }\n            }\n            await Promise.all(promises);\n        }\n        catch (e) {\n            Context.data.debug += `ORG ${organiaztion.data.__name} An error occured: name ${e.name}, message ${e.message}`;\n        }\n    }\n}\nconst parseData = (data, tableName) =\u003e {\n    const result = [];\n    data.forEach(item =\u003e {\n        if (item.data.table_name === tableName \u0026\u0026 !!item.data.table_data) {\n            let tableData = JSON.parse(item.data.table_data);\n            for (let tableElement of tableData) {\n                tableElement.data[\"ИмяБазы\"] = item.data.base_1c_name;\n            }\n            result.push(...tableData);\n        }\n    });\n    return result;\n};\n","gatewayPairs":{},"hasTranslations":false}
