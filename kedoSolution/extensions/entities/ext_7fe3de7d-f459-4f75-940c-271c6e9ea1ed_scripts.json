{
  "__id": "7fe3de7d-f459-4f75-940c-271c6e9ea1ed",
  "scripts": "// /**\n// Здесь вы можете написать скрипты для сложной серверной обработки контекста во время выполнения процесса.\n// Для написания скриптов используйте TypeScript (https://www.typescriptlang.org).\n// Документация TS SDK доступна на сайте https://tssdk.elma365.com.\n// **/\n\nenum InfoType {\n    ORGANIZATION = \"organization\",\n    USER = \"user\",\n};\n\n//Интерфейс ответа от контура. Ключ - ид документа в нашей системе, значение - b64 с файлом для прикрепления внутри.\ninterface IKonturDocsResponse {\n    [key: string]: string\n}\n\nasync function getAwaitingTable(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method\n    if (method === \"GET\") {\n        return await handleGetAwaitingTable(req)\n    } else if (method === \"POST\") {\n        return await handlePostAwaitingTable(req)\n    } else {\n        const response = new HttpResponse()\n        response.status(405)\n            .content(\"Unsupported method\")\n        return response\n    }\n}\n\nasync function handlePostAwaitingTable(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const response = new HttpResponse()\n\n    const personalGuid = req.query?.guid\n    const base1c = req.query?.sourceName\n\n    try {\n        const body = req.body!.toString()\n        const jsonBody = JSON.parse(body)\n\n        await fetch(`https://webhook.site/cf39975e-ad34-4715-b7e6-b1901f6bc196`, {\n            method: \"POST\",\n            body: JSON.stringify(jsonBody),\n        })\n\n        const jsonBodyArray = jsonBody[\"Array\"]\n        const receivedStatus = Namespace.params.fields.awaiting_docs_table_1c.app.fields.__status.variants.received\n\n        for (let i = 0; i \u003c jsonBodyArray.length; i++) {\n            let docRecieved: boolean = false\n            let targetDoc: ApplicationItem\u003cApplication$kedo$awaiting_documents_table_1c$Data, Application$kedo$awaiting_documents_table_1c$Params\u003e | undefined\n\n            const\n                result = jsonBodyArray[i][\"result\"],\n                guid_Elma = jsonBodyArray[i][\"guid_Elma\"],\n                guid_1c = jsonBodyArray[i][\"guid_1c\"],\n                personal_guid_1c = jsonBodyArray[i][\"personIds\"],\n                error_description = jsonBodyArray[i][\"error_description\"],\n                print_forms = jsonBodyArray[i][\"print_forms\"],\n                docType = jsonBodyArray[i][\"documentType\"],\n                employees = jsonBodyArray[i][\"employeeIds\"],\n                docNumber = jsonBodyArray[i][\"docNumber\"],\n                docDate = jsonBodyArray[i][\"docDate\"],\n                objectData = JSON.stringify(jsonBodyArray[i][\"objectData\"])\n\n            if (guid_Elma) {\n                targetDoc = await Namespace.params.fields.awaiting_docs_table_1c.app.search()\n                    .where((f, g) =\u003e g.and(\n                        f.__deletedAt.eq(null),\n                        f.__id.eq(guid_Elma)\n                    )).first()\n                if (targetDoc) {\n                    targetDoc.data.processed_elma = false;\n                    targetDoc.data.update_time = new Datetime();\n                    targetDoc.data.document_number = docNumber;\n                    targetDoc.data.document_date = docDate ? new Datetime(docDate, \"YYYY-MM-DDTHH:mm:ss\") : undefined;\n                    targetDoc.data.document_1c_data = objectData;\n                }\n            } else {\n                targetDoc = Namespace.params.fields.awaiting_docs_table_1c.app.create()\n                const elmaAccounting = Namespace.params.fields.awaiting_docs_table_1c.app.fields.accounting_systems.variants.zup_1c\n                targetDoc.data.__name = docType.split(\"_\")[1]\n                if (base1c \u0026\u0026 !Array.isArray(base1c)) {\n                    targetDoc.data.base_1c_name = base1c\n                }\n                targetDoc.data.accounting_systems = elmaAccounting\n                targetDoc.data.document_odata_name = docType\n                targetDoc.data.document_number = docNumber;\n                targetDoc.data.document_date = docDate ? new Datetime(docDate, \"YYYY-MM-DDTHH:mm:ss\") : undefined;\n                targetDoc.data.document_1c_data = objectData;\n                targetDoc.data.personal_guid_1c = JSON.stringify(personal_guid_1c)\n                targetDoc.data.id_1c = JSON.stringify(employees);\n                targetDoc.data.is_external = true;\n                targetDoc.data.processed_elma = false;\n                targetDoc.data.update_time = new Datetime();\n            }\n\n            if (!targetDoc) {\n                return bodyError(response, `Couldn't find element with passed guid \"${guid_Elma}\"`, 500)\n            }\n\n            if (Array.isArray(print_forms)) {\n                const files: FileItem[] = []\n                const fileTypes: string[] = []\n\n                const isSigned = print_forms[0]?.Data[\"ПодписьВерна\"]\n                targetDoc.data.is_signed_1c = !!isSigned\n\n                const print_forms_table = targetDoc.data.print_forms_table!;\n\n                for (let i = 0; i \u003c print_forms.length; i++) {\n                    const item = print_forms[i];\n                    const fileExtension = item.Data.type;\n                    const fileName = item.PrintFormName;\n                    const fileString = item.Data.data.replace(/\\r\\n/g, '');//.replace(/\\\\r\\\\n/g, '')\n                    const fileArrayBuffer = await getArrayBufferFromBase64(fileString);\n                    const newFile = await targetDoc.fields.print_forms.create(`${fileName}.${fileExtension.toLowerCase()}`, fileArrayBuffer)\n\n                    let row = print_forms_table.find((f: any) =\u003e f.id_1c == item.PrintFormID);\n                    if (!row) row = print_forms_table.insert();\n\n                    row.print_form = newFile;\n                    row.id_1c = item.PrintFormID;\n\n                    if (item[\"Signature\"]) {\n                        const sign_data = await handleSignature(item[\"Signature\"]);\n\n                        if (sign_data) {\n                            row.sign_file = sign_data.sign;\n                            row.stamp = sign_data.stamp;\n                            row.signatory_id_1c = item[\"ELMASignatory\"];\n                        }\n                    }\n\n                    files.push(newFile)\n                    fileTypes.push(item.PrintFormID)\n                }\n                // логика по созданию элемента приложения при смене статуса, временно забракована\n                // for (let file of files) {\n                //     try {\n                //         let externalGuid = JSON.parse(targetDoc.data.personal_guid_1c)[0];\n                //         if (!externalGuid) {\n                //             continue;\n                //         };\n                //         let newDoc = Namespace.params.fields.docs_1c.app.create();\n                //         newDoc.data.__file = file;\n                //         newDoc.data.staff_1c_id = externalGuid;\n\n                //         await newDoc.save();\n                //     } catch (e){\n                //         response\n                //             .status(500)\n                //             .set('Content-Type', 'application/json')\n                //             .json({\n                //                 success: false,\n                //                 error: {\n                //                     name: e.name,\n                //                     message: e.message\n                //                 }\n                //             })\n                //         break;\n                //     }\n                // }\n                targetDoc.data.print_forms = files;\n                targetDoc.data.print_forms_id = JSON.stringify(fileTypes)\n            }\n            if (!!personalGuid) {\n                const guid = Array.isArray(personalGuid) ? personalGuid[0] : personalGuid\n                targetDoc.data.last_action_author = guid\n            }\n            if (typeof result === \"boolean\") {\n                if (result === true) {\n                    docRecieved = true\n                    targetDoc.data.id_document_created_1c = true;\n                    targetDoc.data.doc_id_1c = guid_1c;\n                } else {\n                    docRecieved = false\n                    targetDoc.data.id_document_created_1c = false\n                    targetDoc.data.error = error_description;\n                }\n            } else {\n                docRecieved = false\n            }\n\n            await targetDoc.save()\n            if (docRecieved) {\n                await targetDoc.setStatus(receivedStatus)\n            }\n        }\n\n        response.status(201)\n\n\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message,\n                    stack: e.stack,\n                }\n            })\n    }\n    return response\n}\n\ninterface ISignature {\n    \"Подпись\": string,\n    \"Отпечаток\": string,\n    \"РасширениеФайлаПодписи\" : string,\n}\n\nasync function handleSignature(signature: ISignature): Promise\u003c{ sign: FileItem, stamp: string } | undefined\u003e {\n    if (!signature[\"Подпись\"]) return;\n\n    const sign_base64 = signature[\"Подпись\"].replace(/\\r\\n/g, '');\n    const sign_file = await System.files.createTemporary(`sign.${signature[\"РасширениеФайлаПодписи\"]}`, base64ToArrayBuffer(sign_base64));\n\n    return {\n        sign: sign_file,\n        stamp: signature[\"Отпечаток\"]\n    };\n}\n\nfunction base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (var i = 0; i \u003c binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nfunction str2ab(str: string): ArrayBuffer {\n    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n    var bufView = new Uint16Array(buf);\n    for (var i = 0, strLen = str.length; i \u003c strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\n\nfunction bodyError(response: HttpResponse, message: string, status: number): HttpResponse {\n    return response.status(status).content(message)\n}\n\nasync function handleGetAwaitingTable(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const response = new HttpResponse()\n    const personalGuid = req.query?.guid\n    const base1c = undefined//req.query?.sourceName\n    try {\n        const readyStatus = Namespace.params.fields.awaiting_docs_table_1c.app.fields.__status.variants.ready\n        const sentStatus = Namespace.params.fields.awaiting_docs_table_1c.app.fields.__status.variants.sent\n        const accounting1c = Namespace.params.fields.awaiting_docs_table_1c.app.fields.accounting_systems.variants.zup_1c\n        let awaitingDocs: ApplicationItem\u003cApplication$kedo$awaiting_documents_table_1c$Data, Application$kedo$awaiting_documents_table_1c$Params\u003e[]\n\n        if (!base1c || Array.isArray(base1c)) {\n            awaitingDocs = await Namespace.params.fields.awaiting_docs_table_1c.app.search()\n                .where((f, g) =\u003e g.and(\n                    f.__deletedAt.eq(null)\n                )).size(10000).all()\n        } else {\n            awaitingDocs = await Namespace.params.fields.awaiting_docs_table_1c.app.search()\n                .where((f, g) =\u003e g.and(\n                    f.__deletedAt.eq(null),\n                    f.base_1c_name.eq(base1c)\n                )).size(10000).all()\n        }\n\n        awaitingDocs = awaitingDocs.filter(item =\u003e {\n            let result = true\n            if (!!item.data.accounting_systems \u0026\u0026 !!item.data.document_creation_data) {\n                result = item.data.accounting_systems.code === accounting1c.code\n            }\n            return result \u0026\u0026 item.data.__status!.name === readyStatus.name\n        })\n\n\n        const resultJSON = {\n            success: true,\n            data: awaitingDocs.map(item =\u003e {\n                return {\n                    id: item.data.__id,\n                    documentName: item.data.document_odata_name,\n                    documentData: JSON.parse(item.data.document_creation_data!),\n                    employeesId: JSON.parse(item.data.personal_guid_1c!),\n                    isCorrection: !!item.data.isCorrection,\n                    creationDate: item.data.__createdAt.format('YYYY-MM-DDTHH:mm:ss'),\n                    addInfo: item.data.additional_info ?? \"\",\n                }\n            })\n        }\n\n        response\n            .status(200)\n            .content('application/json')\n            .json(resultJSON)\n\n        // for(let i = 0; i \u003c awaitingDocs.length; i++) {\n        //     await awaitingDocs[i].setStatus(sentStatus)\n        // }\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message\n                }\n            })\n    }\n    return response\n}\n\nasync function get_table_data(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method\n\n    if (method !== \"POST\") {\n        const response = new HttpResponse()\n        response.status(405)\n            .content(\"Unsupported method\")\n        return response\n    }\n\n    const response = new HttpResponse()\n    try {\n        const personalGuid = req.query?.guid\n        const base1c = req.query?.sourceName\n\n        const body = req.body!.toString()\n        const jsonBody = JSON.parse(body)\n\n        if (!jsonBody[\"type\"] || !jsonBody[\"data\"]) {\n            response.status(400)\n                .content(\"No required body fields. {\\\"type\\\", \\\"data\\\"} body expected\")\n            return response\n        }\n\n        const newApp = Namespace.params.fields.posted_data.app.create()\n\n        newApp.data.table_name = jsonBody[\"type\"]\n        newApp.data.table_data = JSON.stringify(jsonBody[\"data\"])\n\n\n        if (base1c \u0026\u0026 !Array.isArray(base1c)) {\n            newApp.data.base_1c_name = base1c\n        }\n\n\n        if (!!personalGuid) {\n            const guid = Array.isArray(personalGuid) ? personalGuid[0] : personalGuid\n            newApp.data.last_action_author = guid\n        }\n\n        //newApp.data.last_action_author = \n        await newApp.save()\n\n        response\n            .status(201)\n            .json({\n                success: true\n            })\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message,\n                    stackTrace: e.stack\n                }\n            })\n    }\n\n    return response\n}\n\n\n\nasync function getArrayBufferFromBase64(base64: string): Promise\u003cArrayBuffer\u003e {\n    var binary_string = atob(base64);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n    for (var i = 0; i \u003c len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nasync function getting_docs_kontur(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method\n    if (method === \"GET\") {\n        return await getAwaitingTableForKontur(req)\n    } else if (method === \"POST\") {\n        return await handlePostAwaitingTable(req)\n    } else {\n        const response = new HttpResponse()\n        response.status(405)\n            .content(\"Unsupported method\")\n        return response\n    }\n\n\n\n}\n\nasync function getAwaitingTableForKontur(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const response = new HttpResponse()\n    try {\n        const awaitingDocs = await Namespace.params.fields.awaiting_docs_table_1c.app.search()\n            .where((f, g) =\u003e g.and(\n                f.__deletedAt.eq(null),\n                f.accounting_systems.eq(Namespace.params.fields.awaiting_docs_table_1c.app.fields.accounting_systems.variants.kontur_gov), //Документы Контура\n                f.__status.eq(Namespace.params.fields.awaiting_docs_table_1c.app.fields.__status.variants.ready)                           //Ожидающие отправки\n            )).all()\n        const resultJSON = {\n            success: true,\n            data: awaitingDocs.filter(filterItem =\u003e {\n                return !!filterItem.data.document_creation_data\n            }).map(item =\u003e {\n                return {\n                    id: item.data.__id,\n                    documentName: item.data.document_odata_name,\n                    documentData: JSON.parse(item.data.document_creation_data!),\n                    employeesId: JSON.parse(item.data.personal_guid_1c!)\n                }\n            })\n        }\n\n        response\n            .status(200)\n            .content('application/json')\n            .json(resultJSON)\n\n        changeDocsStatusToSent(awaitingDocs);\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message\n                }\n            })\n    }\n    return response\n}\n\nasync function handleKonturDocsResponse(req: FetchRequest) {\n    const response = new HttpResponse()\n    try {\n        if (!req.body) {\n            throw new Error('No or empty body provided')\n        }\n        const parsedJSON: IKonturDocsResponse = JSON.parse(req.body as string);\n        const parsedJSONKeys = Object.keys(parsedJSON);\n        for (let docID of parsedJSONKeys) {\n            const b64doc = parsedJSON[docID];\n            let elmaDoc = await Namespace.params.fields.awaiting_docs_table_1c.app.search()\n                .where((f, g) =\u003e g.and(\n                    f.__deletedAt.eq(null),\n                    f.__id.eq(docID),\n                    f.accounting_systems.eq(Namespace.params.fields.awaiting_docs_table_1c.app.fields.accounting_systems.variants.kontur_gov), //Документы Контура\n                    f.__status.eq(Namespace.params.fields.awaiting_docs_table_1c.app.fields.__status.variants.sent)                           //Отправленные\n                )).first();\n            if (elmaDoc) {\n                const file = await elmaDoc.fields.file.create('Название файла', await getArrayBufferFromBase64(b64doc))\n                elmaDoc.data.file = file;\n                await elmaDoc.save();\n                await elmaDoc.setStatus(elmaDoc.fields.__status.variants.received);\n            }\n        }\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message\n                }\n            })\n    }\n    return response\n}\n\n/**\n * Асинхронно изменяет статус указанных документов на \"Отправлено\"\n */\nasync function changeDocsStatusToSent(awaitingDocs: ApplicationItem\u003cApplication$kedo$awaiting_documents_table_1c$Data, Application$kedo$awaiting_documents_table_1c$Params\u003e[]) {\n    let promises: Promise\u003cboolean\u003e[] = [];\n    const PROMISE_STACK_SIZE = 5;\n    for (let awaitingDoc of awaitingDocs) {\n        promises.push(awaitingDoc.setStatus(awaitingDoc.fields.__status.variants.sent));\n        if (promises.length \u003e= PROMISE_STACK_SIZE) {\n            await Promise.all(promises);\n            promises = [];\n        }\n    }\n    await Promise.all(promises);\n}\n\n\nasync function checkEmployeeExists(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const response = new HttpResponse()\n    try {\n        const personalGuid = req.query?.guid\n        const base1c = req.query?.sourceName\n        if (!!personalGuid) {\n            const guid = Array.isArray(personalGuid) ? personalGuid[0] : personalGuid\n            let employee: ApplicationItem\u003cApplication$kedo$staff$Data, Application$kedo$staff$Params\u003e | undefined\n            if (base1c \u0026\u0026 !Array.isArray(base1c)) {\n                employee = await Namespace.params.fields.employee_app.app.search()\n                    .where((f, g) =\u003e g.and(\n                        f.__deletedAt.eq(null),\n                        f.individual_id_1c.eq(guid),\n                        f.base_1c_name.eq(base1c)\n                    ))\n                    .first()\n            } else {\n                employee = await Namespace.params.fields.employee_app.app.search()\n                    .where((f, g) =\u003e g.and(\n                        f.__deletedAt.eq(null),\n                        f.individual_id_1c.eq(guid)\n                    ))\n                    .first()\n            }\n            response\n                .status(200)\n                .set('Content-Type', 'application/json')\n                .json({\n                    employeeExists: !!employee\n                })\n        } else {\n            response.status(400)\n                .content(\"No required parameters: guid\")\n            return response\n        }\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message\n                }\n            })\n    }\n    return response\n}\n\nasync function handleGetAwaitingTableStatuses(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const response = new HttpResponse()\n    try {\n        const base1c = req.query?.sourceName\n        let awaitingDocs: ApplicationItem\u003cApplication$kedo$awaiting_documents_table_1c$Data, Application$kedo$awaiting_documents_table_1c$Params\u003e[]\n        if (base1c \u0026\u0026 !Array.isArray(base1c)) {\n            awaitingDocs = await Namespace.params.fields.awaiting_docs_table_1c.app.search()\n                .where((f, g) =\u003e g.and(\n                    f.__deletedAt.eq(null),\n                    f.status_1c.neq(null),\n                    f.doc_id_1c.neq(null),\n                    f.base_1c_name.eq(base1c)\n                )).all()\n        } else {\n            awaitingDocs = await Namespace.params.fields.awaiting_docs_table_1c.app.search()\n                .where((f, g) =\u003e g.and(\n                    f.__deletedAt.eq(null),\n                    f.status_1c.neq(null),\n                    f.doc_id_1c.neq(null)\n                )).all()\n        }\n        const parsedDocs = awaitingDocs.map(item =\u003e {\n            return {\n                DocId: item.data.doc_id_1c,\n                StateId: item.data.status_1c\n            }\n        })\n\n        const resultJSON = {\n            success: true,\n            array: parsedDocs\n        }\n\n        response\n            .status(200)\n            .content('application/json')\n            .json(resultJSON)\n\n\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message\n                }\n            })\n    }\n    return response\n\n\n}\n\nasync function getDocsStatuses(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method\n    if (method === \"GET\") {\n        return await handleGetAwaitingTableStatuses(req)\n    } else {\n        const response = new HttpResponse()\n        response.status(405)\n            .content(\"Unsupported method\")\n        return response\n    }\n}\n\nasync function handlePayslip(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method\n    if (method === \"GET\") {\n        return await getPayslip(req)\n    } else if (method === \"POST\") {\n        return await postPayslip(req)\n    } else {\n        const response = new HttpResponse()\n        response.status(405)\n            .content(\"Unsupported method\")\n        return response\n    }\n}\n\ninterface IPayslipRequestData {\n    Type: string,\n    BinaryData: string,\n    id: string,\n}\n\ninterface IPayslipRequest {\n    success: boolean,\n    data: IPayslipRequestData[],\n}\n\ntype PayslipApp = ApplicationItem\u003cApplication$kedo$payslip_requests_1c$Data, Application$kedo$payslip_requests_1c$Params\u003e\n\nasync function postPayslip(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const response = new HttpResponse()\n\n    try {\n        // Пока не реализовано.\n        const base1c = undefined//req.query?.sourceName\n\n        const body = req.body!.toString()\n        const jsonBody: IPayslipRequest = JSON.parse(body)\n        const recievedData = jsonBody.data;\n\n        const sentStatus = Namespace.params.fields.payslip_app.app.fields.__status.variants.sent;\n        const receivedStatus = Namespace.params.fields.payslip_app.app.fields.__status.variants.payslip_ready;\n\n        let payslipApps: PayslipApp[] = [];\n\n        const payslip_ids = recievedData.map(f =\u003e f.id);\n\n        payslipApps = await Namespace.params.fields.payslip_app.app.search().where((f, g) =\u003e g.and(\n            f.__deletedAt.eq(null),\n            f.__id.in(payslip_ids),\n            //f.__status.eq(sentStatus)\n        )).size(1000).all();\n\n        const handledApps: PayslipApp[] = [];\n\n        for (const data of recievedData) {\n            const\n                guid_elma = data.id,\n                printFormType = data.Type,\n                binaryData = data.BinaryData;\n\n            const payslip_app = payslipApps.find(f =\u003e f.data.__id === guid_elma);\n\n            if (!payslip_app) {\n                return bodyError(response, `Couldn't find element with passed guid \"${guid_elma}\"`, 500);\n            }\n\n            const files: FileItem[] = []\n            const fileExtension = printFormType;\n            const fileName = \"Расчетный листок\";\n            const fileString = binaryData.replace(/\\\\r\\\\n/g, '')\n            const fileArrayBuffer = await getArrayBufferFromBase64(fileString);\n\n            if (fileArrayBuffer.byteLength == 0) {\n                payslip_app.data.print_forms = undefined;\n            } else {\n                const newFile = await payslip_app.fields.print_forms.create(`${fileName}.${fileExtension.toLowerCase()}`, fileArrayBuffer)\n                files.push(newFile)\n                payslip_app.data.print_forms = files;\n                payslip_app.data.base_1c_name = `Запрос обработан ${new Datetime().format()}`;\n            }\n\n            handledApps.push(payslip_app);\n        }\n\n        const chunkSize = 100;\n\n        for (let i = 0; i \u003c handledApps.length; i += chunkSize) {\n            const chunck = handledApps.slice(i, i + chunkSize);\n            await Promise.all(chunck.map(f =\u003e f.setStatus(receivedStatus)));\n            await Promise.all(chunck.map(f =\u003e f.save()));\n        }\n\n        response.status(201)\n\n        // if (base1c \u0026\u0026 !Array.isArray(base1c)) {\n        //     payslipApps = await Namespace.params.fields.payslip_app.app.search()\n        //         .where((f, g) =\u003e g.and(\n        //             f.__deletedAt.eq(null),\n        //             f.__status.eq(sentStatus),\n        //             f.base_1c_name.eq(base1c)\n        //         ))\n        //         .size(10000)\n        //         .all();\n        // } else {\n        //     payslipApps = await Namespace.params.fields.payslip_app.app.search()\n        //         .where((f, g) =\u003e g.and(\n        //             f.__deletedAt.eq(null),\n        //             f.__status.eq(sentStatus)\n        //         ))\n        //         .size(10000)\n        //         .all();\n        // }\n\n        // for (let i = 0; i \u003c recievedData.length; i++) {\n        //     const\n        //         guid_Elma = recievedData[i][\"id\"],\n        //         formType = recievedData[i][\"Type\"],\n        //         binaryData = recievedData[i][\"BinaryData\"]\n\n        //     /*const targetDoc = await Namespace.params.fields.payslip_app.app.search()\n        //         .where((f, g) =\u003e g.and(\n        //             f.__deletedAt.eq(null),\n        //             f.__id.eq(guid_Elma)\n        //         )).first()*/\n\n        //     const payslipApp = payslipApps.find(doc =\u003e doc.data.__id === guid_Elma);\n\n        //     if (!payslipApp) {\n        //         return bodyError(response, `Couldn't find element with passed guid \"${guid_Elma}\"`, 500)\n        //     }\n\n        //     const files: FileItem[] = []\n        //     const fileExtension = formType;\n        //     const fileName = \"Расчетный листок\";\n        //     const fileString = binaryData.replace(/\\\\r\\\\n/g, '')\n        //     const fileArrayBuffer = await getArrayBufferFromBase64(fileString);\n\n        //     let isFileCreated = false\n        //     if (fileArrayBuffer.byteLength \u003e 0) {\n        //         const newFile = await targetDoc.fields.print_forms.create(`${fileName}.${fileExtension.toLowerCase()}`, fileArrayBuffer)\n        //         files.push(newFile)\n        //         isFileCreated = true\n        //     }\n\n        //     targetDoc.data.print_forms = files\n\n        //     if (isFileCreated) {\n        //         docs.push(targetDoc);\n        //     }\n\n        //     //await targetDoc.save()\n        //     //await targetDoc.setStatus(receivedStatus)\n        // }\n    } catch (e: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: e.name,\n                    message: e.message\n                }\n            })\n    }\n\n    return response\n}\n\nasync function getPayslip(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const response = new HttpResponse();\n\n    try {\n        //Вернуть после доработок по разным базам ЗУП. \n        //const base_1c = req.query?.sourceName;\n        const base_1c = undefined;\n        const page_size = req.query \u0026\u0026 req.query.pageSize \u0026\u0026 !Number.isNaN(req.query.pageSize) ? Number(req.query.pageSize) : 10;\n\n        const readyStatus = Namespace.params.fields.payslip_app.app.fields.__status.variants.ready;\n        let awaitingDocs: ApplicationItem\u003cApplication$kedo$payslip_requests_1c$Data, Application$kedo$payslip_requests_1c$Params\u003e[];\n\n        if (base_1c \u0026\u0026 !Array.isArray(base_1c)) {\n            awaitingDocs = await Namespace.params.fields.payslip_app.app.search()\n                .where((f, g) =\u003e g.and(\n                    f.__deletedAt.eq(null),\n                    f.__status.eq(readyStatus),\n                    //f.base_1c_name.eq(base1c)\n                ))\n                .size(page_size)\n                .all()\n        } else {\n            awaitingDocs = await Namespace.params.fields.payslip_app.app.search()\n                .where((f, g) =\u003e g.and(\n                    f.__deletedAt.eq(null),\n                    f.__status.eq(readyStatus)\n                ))\n                .size(page_size)\n                .all()\n        }\n\n        const resultJSON = {\n            success: true,\n            data: awaitingDocs.map(item =\u003e {\n                return {\n                    id: item.data.__id,\n                    startDate: item.data.start_date?.format('YYYY-MM-DD'),\n                    endDate: item.data.end_date?.format('YYYY-MM-DD'),\n                    employeeId: item.data.personal_id\n                }\n            })\n        }\n\n        response\n            .status(200)\n            .content('application/json')\n            .json(resultJSON);\n\n    } catch (error: any) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message\n                },\n            })\n    }\n\n    return response;\n}\n\nasync function change_hr_department_and_accounting(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    if (!req.body) {\n        return;\n    };\n\n    const orgId = JSON.parse(req.body as string).org_id;\n    const accountingIds = JSON.parse(\u003cstring\u003ereq.body).accounting_ids || [];\n    const hrIds = JSON.parse(\u003cstring\u003ereq.body).hr_ids || [];\n    const specialIds = JSON.parse(\u003cstring\u003ereq.body).special_ids || [];\n    const signatoriesIds = JSON.parse(\u003cstring\u003ereq.body).signatories_ids || [];\n    const signatoriesCode = \"0b7cab5e-31ef-4bd8-8f91-b5689111cf7a\";\n    const hrDepartmentCode = \"abdecf4b-b6ba-419f-bac7-c1455d2a6159\";\n    const accountingCode = \"dfede5be-5011-4ec9-b535-8c9ca3fc4d19\";\n    const specialAccessCode = \"0798a43a-8ed9-4b30-8dfe-e16559fb7695\";\n    const allOrganizations = await Namespace.params.fields.org_app.app.search().where(f =\u003e f.__deletedAt.eq(null)).size(10000).all();\n    const hrDepartmentGroup = await System.userGroups.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.code.eq(hrDepartmentCode)\n    )).first();\n    const signatoriesGroup = await System.userGroups.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.code.eq(signatoriesCode)\n    )).first();\n    const accountingGroup = await System.userGroups.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.code.eq(accountingCode)\n    )).first();\n    const specialAccessGroup = await System.userGroups.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.code.eq(specialAccessCode)\n    )).first();\n    const allStaff = await Namespace.params.fields.employee_app.app.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null)\n    )).size(10000).all();\n\n    let allUids: string[] = [];\n\n    try {\n        const organizationHrs = await System.userGroups.search().where((f, g) =\u003e g.and(\n            f.__deletedAt.eq(null),\n            f.namespace.eq(\"kedo\"),\n            f.__name.like(\"Отдел кадров\"),\n            f.description.eq(orgId)\n        )).first();\n        const organizationSignatories = await System.userGroups.search().where((f, g) =\u003e g.and(\n            f.__deletedAt.eq(null),\n            f.namespace.eq(\"kedo\"),\n            f.__name.like(\"Подписанты\"),\n            f.description.eq(orgId)\n        )).first();\n        const organizationAccounting = await System.userGroups.search().where((f, g) =\u003e g.and(\n            f.__deletedAt.eq(null),\n            f.__name.like(\"Бухгалтерия\"),\n            f.description.eq(orgId),\n            f.namespace.eq(\"kedo\")\n        )).first();\n        const organizationSpecials = await System.userGroups.search().where((f, g) =\u003e g.and(\n            f.__deletedAt.eq(null),\n            f.__name.like(\"Ответственные за КЭДО\"),\n            f.description.eq(orgId),\n            f.namespace.eq(\"kedo\")\n        )).first();\n\n        const nonEmptySpecials = allOrganizations.filter(org =\u003e org.data.special_access_new \u0026\u0026 org.data.special_access_new.length \u003e 0);\n        allUids = [].concat.apply([], [].concat.apply(nonEmptySpecials.map(org =\u003e org.data.special_access_new!.map(staff =\u003e {\n            const staffApp = allStaff.find(s =\u003e s.id === staff.id);\n            if (staffApp \u0026\u0026 staffApp.data.ext_user) {\n                return staffApp.data.ext_user.id\n            };\n        }))));\n        if (allUids \u0026\u0026 allUids.length \u003e 0) {\n            allUids = allUids.filter(id =\u003e id);\n        }\n        if (specialIds) {\n            allUids.push(...specialIds);\n        };\n        if (organizationSpecials \u0026\u0026 specialIds) {\n            organizationSpecials.data.subOrgunitIds = [...specialIds];\n            await organizationSpecials.save();\n        };\n\n        specialAccessGroup!.data.subOrgunitIds = allUids\n        await specialAccessGroup!.save();\n        const nonEmptySignatroies = allOrganizations.filter(org =\u003e org.data.signatories \u0026\u0026 org.data.signatories.length \u003e 0);\n        allUids = [].concat.apply([], [].concat.apply(nonEmptySignatroies.map(org =\u003e org.data.signatories!.map(staff =\u003e {\n            const staffApp = allStaff.find(s =\u003e s.id === staff.id);\n            if (staffApp \u0026\u0026 staffApp.data.ext_user) {\n                return staffApp.data.ext_user.id\n            };\n        }))));\n        if (allUids \u0026\u0026 allUids.length \u003e 0) {\n            allUids = allUids.filter(id =\u003e id);\n        }\n        if (signatoriesIds) {\n            allUids.push(...signatoriesIds);\n        };\n        if (organizationSignatories \u0026\u0026 signatoriesIds) {\n            organizationSignatories.data.subOrgunitIds = [...signatoriesIds];\n            await organizationSignatories.save();\n        };\n\n        signatoriesGroup!.data.subOrgunitIds = allUids\n        await signatoriesGroup!.save();\n\n        const nonEmptyAccounting = allOrganizations.filter(org =\u003e org.data.accounting \u0026\u0026 org.data.accounting.length \u003e 0);\n        allUids = [].concat.apply([], [].concat.apply(nonEmptyAccounting.map(org =\u003e org.data.accounting!.map(staff =\u003e {\n            const staffApp = allStaff.find(s =\u003e s.id === staff.id);\n            if (staffApp \u0026\u0026 staffApp.data.ext_user) {\n                return staffApp.data.ext_user.id;\n            };\n        }))));\n        if (allUids \u0026\u0026 allUids.length \u003e 0) {\n            allUids = allUids.filter(id =\u003e id);\n        };\n        if (accountingIds) {\n            allUids.push(...accountingIds);\n        }\n        if (organizationAccounting \u0026\u0026 accountingIds) {\n            organizationAccounting.data.subOrgunitIds = [...accountingIds]\n            await organizationAccounting.save();\n        };\n\n        accountingGroup!.data.subOrgunitIds = allUids;\n        await accountingGroup!.save();\n\n        const nonEmptyHr = allOrganizations.filter(org =\u003e org.data.hr_department \u0026\u0026 org.data.hr_department.length \u003e 0);\n        allUids = [].concat.apply([], [].concat.apply(nonEmptyHr.map(org =\u003e org.data.hr_department!.map(staff =\u003e {\n            const staffApp = allStaff.find(s =\u003e s.id === staff.id);\n            if (staffApp \u0026\u0026 staffApp.data.ext_user) {\n                return staffApp.data.ext_user.id;\n            };\n        }))));\n        if (allUids \u0026\u0026 allUids.length \u003e 0) {\n            allUids = allUids.filter(id =\u003e id);\n        }\n\n        if (hrIds) {\n            allUids.push(...hrIds)\n        }\n        if (organizationHrs \u0026\u0026 hrIds) {\n            organizationHrs.data.subOrgunitIds = [...hrIds]\n            await organizationHrs.save();\n        };\n\n        hrDepartmentGroup!.data.subOrgunitIds = allUids;\n        await hrDepartmentGroup!.save();\n        await checkInnerUsers(hrDepartmentGroup!, accountingGroup!, specialAccessGroup!, orgId);\n    } catch (err) {\n        return;\n    };\n};\n\nasync function checkInnerUsers(hrGroup: UserGroupItem, accountingGroup: UserGroupItem, specialAccessGroup: UserGroupItem, orgId: string): Promise\u003cvoid\u003e {\n    const org = await Namespace.params.fields.org_app.app.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.__id.eq(orgId)\n    )).first()\n    if (!org || org.data.access_settings_organization) {\n        return;\n    };\n\n    const accessSettingsId = org.data.access_settings_organization!.id;\n    const orgRights = await Namespace.params.fields.access_settings_organization_app.app.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.__id.eq(accessSettingsId)\n    )).first();\n    if (!orgRights) {\n        return;\n    };\n    const innerUsersField = orgRights.data.inner_org_staff;\n    if (!innerUsersField || innerUsersField.length \u003c 1) {\n        return;\n    };\n\n    const innerUsersRights = await System.userGroups.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.__id.eq(innerUsersField[0].code)\n    )).first();\n    if (!innerUsersRights) {\n        return;\n    };\n    const innerUsersIds = innerUsersRights.data.subOrgunitIds;\n    if (!innerUsersIds || innerUsersIds.length \u003c 1) {\n        return;\n    };\n    const groupsIds: string[] = [].concat.apply([], [accountingGroup.data.subOrgunitIds, hrGroup.data.subOrgunitIds]).filter((item: any) =\u003e item != null);\n    if (groupsIds \u0026\u0026 groupsIds.length \u003e 0) {\n        const idsToDelete = innerUsersIds.filter(id =\u003e groupsIds.indexOf(id) != -1);\n        for (let id of innerUsersRights!.data.subOrgunitIds!) {\n            if (idsToDelete.indexOf(id) != -1) {\n                delete innerUsersRights.data.subOrgunitIds![innerUsersRights.data.subOrgunitIds!.indexOf(id)];\n            };\n        };\n        await innerUsersRights.save();\n    };\n};\n\ninterface IRelatedDocuments {\n    namespace: string,\n    code: string,\n    documents: IDocument[],\n}\n\ninterface IDocument {\n    namespace: string,\n    code: string,\n    related_field_code: string,\n}\n\nconst related_documents: IRelatedDocuments[] = [\n    {\n        \"namespace\": \"business_trips\",\n        \"code\": \"businesstrip_requests\",\n        \"documents\": [\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"trip_requests\",\n                \"related_field_code\": \"businesstrip_requests\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"business_trip_consent\",\n                \"related_field_code\": \"business_trip\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"business_trip_change_service_note\",\n                \"related_field_code\": \"business_trip\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"service_note_accountable_funds\",\n                \"related_field_code\": \"business_trip\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"order_for_a_business_trip\",\n                \"related_field_code\": \"business_trip\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"avansovyi_otchet\",\n                \"related_field_code\": \"businesstrip_requests\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"service_assignments\",\n                \"related_field_code\": \"businesstrip_requests\"\n            }\n        ]\n    },\n    {\n        \"namespace\": \"time_tracking\",\n        \"code\": \"overtime_work\",\n        \"documents\": [\n            {\n                \"namespace\": \"time_tracking\",\n                \"code\": \"overtime_requests\",\n                \"related_field_code\": \"overtime_work\"\n            },\n            {\n                \"namespace\": \"time_tracking\",\n                \"code\": \"overtimeWorkOrders\",\n                \"related_field_code\": \"overtime_work\"\n            },\n            {\n                \"namespace\": \"time_tracking\",\n                \"code\": \"overtimeWorkNotifications\",\n                \"related_field_code\": \"overtime_work\"\n            },\n            {\n                \"namespace\": \"time_tracking\",\n                \"code\": \"overtimeWorkConsent\",\n                \"related_field_code\": \"overtime_work\"\n            },\n            {\n                \"namespace\": \"time_tracking\",\n                \"code\": \"overtime_order\",\n                \"related_field_code\": \"overtime_work\"\n            }\n        ]\n    },\n    {\n        \"namespace\": \"absences\",\n        \"code\": \"vacations\",\n        \"documents\": [\n            {\n                \"namespace\": \"absences\",\n                \"code\": \"vacation_docs\",\n                \"related_field_code\": \"vacation\"\n            },\n            {\n                \"namespace\": \"absences\",\n                \"code\": \"vacation_orders\",\n                \"related_field_code\": \"vacation\"\n            },\n            {\n                \"namespace\": \"absences\",\n                \"code\": \"memo_recall_vacation\",\n                \"related_field_code\": \"vacation\"\n            },\n            {\n                \"namespace\": \"absences\",\n                \"code\": \"consent_recall_vacation\",\n                \"related_field_code\": \"vacation\"\n            }\n        ]\n    },\n    {\n        \"namespace\": \"kedo\",\n        \"code\": \"staff\",\n        \"documents\": [\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"application_for_financial_assistance\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"benefit_application\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"application_for_the_transfer_of_salary_to_the_current_account\",\n                \"related_field_code\": \"staffstaff\"\n            },\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"free_from\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"certificate\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"other_documents\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"absences\",\n                \"code\": \"vacation_docs\",\n                \"related_field_code\": \"kedo_staff\"\n            },\n            {\n                \"namespace\": \"absences\",\n                \"code\": \"vacation_orders\",\n                \"related_field_code\": \"kedo_staff\"\n            },\n            {\n                \"namespace\": \"time_tracking\",\n                \"code\": \"overtime_work\",\n                \"related_field_code\": \"kedo_staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"additional_agreement\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"employees_personal_data\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"trip_requests\",\n                \"related_field_code\": \"kedo_staff\"\n            },\n            {\n                \"namespace\": \"business_trips\",\n                \"code\": \"order_for_a_business_trip\",\n                \"related_field_code\": \"kedo_staff\"\n            },\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"combination\",\n                \"related_field_code\": \"substitute\"\n            },\n            {\n                \"namespace\": \"personnel_documents\",\n                \"code\": \"combination_additional_agreement\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"letter_of_resignation\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"electronic_interaction_agreement\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"labor_contract\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"admission_order\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"information_about_labor_activity\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"job_application\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"additional_agreement_to_the_contract\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"consent_processing_personal_data\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"transfer_application\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"order_for_transfer\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"transfer_approve\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"additional_transfer_agreement\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"dismissal_app\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"letter_of_resignation\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"dismissal_order\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"recall_dismissal\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"category_assignment\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"application_category_assignment\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"employees_personal_data\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"passport_data_application\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"passport_data_change_order\",\n                \"related_field_code\": \"staff\"\n            },\n            {\n                \"namespace\": \"kedo\",\n                \"code\": \"child_personal_data_consent\",\n                \"related_field_code\": \"staff\"\n            }\n        ]\n    }\n]\n\nasync function fill_related_documents(req: HttpApiRequest): Promise\u003cHttpResponse | void\u003e {\n    await Namespace.storage.setItem(\"related_documents\", JSON.stringify(related_documents));\n\n    return new HttpResponse()\n        .status(201)\n        .json({\n            status: \"success\"\n        });\n}\n\nasync function getStaffSignInfo(req: HttpApiRequest): Promise\u003cHttpResponse | void\u003e {\n    if (!req.body) {\n        return;\n    };\n\n    const bodyJson = JSON.parse(\u003cstring\u003ereq.body);\n\n    if (!bodyJson.p1) {\n        return;\n    };\n\n    const infoType = bodyJson.p2;\n\n    const userId = bodyJson.p1;\n    const user = await System.users.search().where((f, g) =\u003e g.and(\n        f.__deletedAt.eq(null),\n        f.__id.eq(userId)\n    )).first();\n\n    if (user) {\n        const staff = await Namespace.params.fields.employee_app.app.search().where((f, g) =\u003e g.and(\n            f.__deletedAt.eq(null),\n            f.ext_user.eq(user)\n        )).first();\n        if (staff \u0026\u0026 staff.data.organization) {\n            if (infoType === InfoType.USER) {\n                return new HttpResponse(200).content(staff.data.__name);\n            };\n            const organization = await staff.data.organization.fetch();\n            return new HttpResponse(200).content(organization.data.__name)\n            // await fetch(\"https://webhook.site/724f38cf-219a-4db8-8284-4769e50a7ae4\", {\n            //     method: \"POST\",\n            //     body: organization.data.__name\n            // })\n        }\n    }\n}\n",
  "handlers": [
    {
      "__name": "Получение документов ожидающий создание в 1С",
      "description": "",
      "auth": "external",
      "method": "GET,POST",
      "code": "awaiting_docs_table",
      "func": "getAwaitingTable",
      "async": false
    },
    {
      "__name": "Получение таблиц из 1С",
      "description": "",
      "auth": "external",
      "method": "POST",
      "code": "data_table",
      "func": "get_table_data",
      "async": false
    },
    {
      "__name": "Получение документов ожидающих создание в Контур.Гособлако",
      "description": "",
      "auth": "external",
      "method": "GET,POST",
      "code": "getting_docs",
      "func": "getting_docs_kontur",
      "async": false
    },
    {
      "__name": "Проверка существования сотрудника",
      "description": "",
      "auth": "external",
      "method": "GET",
      "code": "check_employee",
      "func": "checkEmployeeExists",
      "async": false
    },
    {
      "__name": "Получить статусы документов",
      "description": "",
      "auth": "external",
      "method": "GET",
      "code": "awaiting_docs_table/status",
      "func": "getDocsStatuses",
      "async": false
    },
    {
      "__name": "Расчетные листки",
      "description": "",
      "auth": "external",
      "method": "GET,POST",
      "code": "payslip_table",
      "func": "handlePayslip",
      "async": false
    },
    {
      "__name": "Добавления пользователей в группу после изменения поля в организации",
      "description": "",
      "auth": "internal",
      "method": "POST",
      "code": "change_hr_department_and_accounting",
      "func": "change_hr_department_and_accounting",
      "async": false
    },
    {
      "__name": "Получение организации и имени пользователя",
      "description": "",
      "auth": "internal",
      "method": "POST",
      "code": "get_staff_sign_info",
      "func": "getStaffSignInfo",
      "async": false
    }
  ],
  "draft": false,
  "allowGlobal": false
}
