{
  "__id": "3c26e96d-9ba5-486d-a26e-47918e61fad3",
  "scripts": "/**\nЗдесь вы можете написать скрипты для сложной серверной обработки контекста во время выполнения процесса.\nДля написания скриптов используйте TypeScript (https://www.typescriptlang.org).\nДокументация TS SDK доступна на сайте https://tssdk.elma365.com.\n**/\n\nconst DATE_FORMAT_1C = \"YYYY-MM-DD\";\nconst DATETIME_FORMAT_1C = \"YYYY-MM-DDTHH:mm:ss\";\n\n/** Создание файла */\nasync function createFile(name: string | undefined, extension: string, base64: string | undefined): Promise\u003cFileItem | undefined\u003e {\n    if (!name) {\n        name = \"Без имени\";\n    }\n\n    if (!base64) {\n        return;\n    }\n\n    base64 = base64.replace(/\\\\r\\\\n/g, '');\n\n    const array_buffer = getArrayBufferFromBase64(base64);\n\n    if (array_buffer.byteLength == 0) {\n        return;\n    }\n\n    const file = await System.files.createTemporary(`${name}.${extension}`, array_buffer);\n\n    return file;\n}\n\nfunction getArrayBufferFromBase64(base64: string): ArrayBuffer {\n    var binary_string = atob(base64);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n    for (var i = 0; i \u003c len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\n\ntype PayslipApp = ApplicationItem\u003cApplication$kedo$payslip_requests_1c$Data, Application$kedo$payslip_requests_1c$Params\u003e;\ntype IntegrationApp = ApplicationItem\u003cApplication$kedo$awaiting_documents_table_1c$Data, Application$kedo$awaiting_documents_table_1c$Params\u003e;\ntype PostedData1CApp = ApplicationItem\u003cApplication$kedo$posted_1c_data$Data, Application$kedo$posted_1c_data$Params\u003e;\n\nconst PayslipStatuses = Namespace.params.fields.payslip_requests.app.fields.__status.variants;\nconst IntegrationAppStatuses = Namespace.params.fields.integration_app.app.fields.__status.variants;\nconst AccountingSystem = Namespace.params.fields.integration_app.app.fields.accounting_systems.variants;\n\ninterface PayslipResponseData {\n    id: string,\n    startDate: string,\n    endDate: string,\n    employeeId: string,\n}\n\ninterface PayslipRequestData {\n    Type: string,\n    BinaryData?: string,\n    id: string,\n}\n\ninterface PayslipResponse {\n    success: true,\n    data?: PayslipResponseData[],\n}\n\ninterface PayslipRequest {\n    success: boolean,\n    data?: PayslipRequestData[],\n}\n\ninterface IntegrationAppRequestData {\n    Array: {\n        result: boolean,\n        guid_Elma: string,\n        guid_1c: string,\n        employeeIds: string[],\n        personIds: string[],\n        documentType: string,\n        docNumber: string,\n        docDate: string,\n        objectData: any,\n        print_forms: PrintForm[],\n    }[]\n}\n\ninterface PrintForm {\n    PrintFormID: string,\n    PrintFormName: string,\n    Data: {\n        type: string,\n        data: string,\n    },\n    Signature: Signature,\n    ELMASignatory: string,\n}\n\ninterface Signature {\n    \"Подпись\": string,\n    \"УстановившийПодпись\": {\n        \"Представление\": string,\n        \"Идентификатор\": string,\n    },\n    \"Комментарий\"?: string,\n    \"ИмяФайлаПодписи\"?: string,\n    \"ДатаПодписи\": string,\n    \"ДатаПроверкиПодписи\": string,\n    \"ПодписьВерна\": boolean,\n    \"Сертификат\": string,\n    \"Отпечаток\": string,\n    \"КомуВыданСертификат\": string,\n    \"ТипПодписи\": string,\n    \"СрокДействияПоследнейМеткиВремени\"?: string,\n    \"ДатаПодписиИзМетки\"?: string,\n    \"НеподтвержденнаяДатаПодписи\": string,\n    \"РасширениеФайлаПодписи\": string,\n}\n\ninterface SignData1C {\n    sign: FileItem,\n    stamp: string,\n}\n\ninterface IntegrationAppResponseData {\n    id: string,\n    documentName: string,\n    documentData: any,\n    employeesId: string[],\n    isCorrection: boolean,\n    creationDate: string,\n    addInfo?: string,\n}\n\ninterface IntegrationAppResponse {\n    success: boolean,\n    data?: IntegrationAppResponseData[],\n}\n\ninterface IntegrationAppRequest {\n    success: boolean,\n    data?: IntegrationAppRequestData,\n}\n\ninterface PostedData1CRequest {\n    type: string,\n    data: string,\n}\n\n\nasync function handlePayslip(req: HttpApiRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method;\n\n    switch (method) {\n        case \"GET\": {\n            return getPayslip(req);\n        }\n\n        case \"POST\": {\n            return postPayslip(req);\n        }\n\n        default: {\n            return new HttpResponse()\n                .status(405)\n                .content(\"Unsupoorted method\");\n        }\n    }\n}\n\nasync function getPayslip(req: HttpApiRequest): Promise\u003cHttpResponse\u003e {\n    const response = new HttpResponse();\n\n    try {\n        // Вернуть после доработок по разным базам ЗУП. \n        // const base_1c = req.query?.sourceName;\n        const base_1c = undefined;\n        const size = req.query \u0026\u0026 req.query.pageSize \u0026\u0026 !Number.isNaN(req.query.pageSize) ? Number(req.query.pageSize) : 10;\n\n        const payslip_requests = await Namespace.params.fields.payslip_requests.app.search()\n            .where((f, g) =\u003e g.and(\n                f.__deletedAt.eq(null),\n                f.__status.eq(PayslipStatuses.ready),\n                f.start_date.neq(null),\n                f.end_date.neq(null),\n                f.personal_id.neq(null),\n                // Вернуть после доработок по разным базам ЗУП. \n                //f.base_1c_name.eq(base_1c)\n            ))\n            .size(size)\n            .all();\n\n        const payslip_response = {\n            success: true,\n            data: payslip_requests.map(payslip =\u003e {\n                return \u003cPayslipResponseData\u003e{\n                    id: payslip.data.__id,\n                    startDate: payslip.data.start_date?.format(DATE_FORMAT_1C) ?? \"\",\n                    endDate: payslip.data.end_date?.format(DATE_FORMAT_1C) ?? \"\",\n                    employeeId: payslip.data.personal_id ?? \"\",\n                }\n            })\n        };\n\n        response\n            .status(200)\n            .content(\"application/json\")\n            .json(payslip_response);\n\n    } catch (error) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack,\n                },\n            });\n    }\n\n    return response;\n}\n\nasync function postPayslip(req: HttpApiRequest): Promise\u003cHttpResponse\u003e {\n    const response = new HttpResponse();\n\n    try {\n        // Вернуть после доработок по разным базам ЗУП. \n        // const base_1c = req.query?.sourceName;\n        const base_1c = undefined;\n\n        const body = req.body?.toString();\n        const request: PayslipRequest = body ? JSON.parse(body) : undefined;\n\n        if (!request) {\n            throw new Error(\"Payslip request is undefined\");\n        }\n\n        const payslip_ids = (request.data ?? []).map(f =\u003e f.id);\n\n        const payslips = await Namespace.params.fields.payslip_requests.app.search()\n            .where((f, g) =\u003e g.and(\n                f.__deletedAt.eq(null),\n                f.__id.in(payslip_ids)\n            ))\n            .size(payslip_ids.length)\n            .all();\n\n        let promises: Promise\u003cvoid\u003e[] = [];\n\n        for (const payslip_request of (request.data ?? [])) {\n            const\n                guid_elma = payslip_request.id,\n                print_form_type = payslip_request.Type,\n                binary_data = payslip_request.BinaryData;\n\n            const payslip = payslips.find(f =\u003e f.data.__id === guid_elma);\n\n            if (!payslip) {\n                continue;\n            }\n\n            promises.push((async () =\u003e {\n                const payslip_file = await createFile(`Расчетный лист`, print_form_type, binary_data);\n\n                if (!payslip_file) {\n                    return;\n                }\n\n                payslip.data.print_forms = [payslip_file];\n\n                await payslip.save();\n                await payslip.setStatus(PayslipStatuses.payslip_ready);\n\n            })());\n\n            if (promises.length \u003e 10) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n\n        response.status(201);\n    } catch (error) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack,\n                },\n            });\n    }\n\n    return response;\n}\n\nasync function handleIntegrationApp(req: HttpApiRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method;\n\n    switch (method) {\n        case \"GET\": {\n            return getIntegrationApps(req);\n        }\n\n        case \"POST\": {\n            return postIntegrationApps(req);\n        }\n\n        default: {\n            return new HttpResponse()\n                .status(405)\n                .content(\"Unsupported method\");\n        }\n    }\n}\n\nasync function getIntegrationApps(req: HttpApiRequest): Promise\u003cHttpResponse\u003e {\n    const response = new HttpResponse();\n\n    try {\n        // Вернуть после доработок по разным базам ЗУП.\n        // const base_1c = req.query?.sourceName;\n        const base1c = undefined;\n\n        const integration_apps = await Namespace.params.fields.integration_app.app.search()\n            .where((f, g) =\u003e g.and(\n                f.__deletedAt.eq(null),\n                f.__status.eq(IntegrationAppStatuses.ready),\n                f.accounting_systems.eq(AccountingSystem.zup_1c),\n                f.document_creation_data.neq(null),\n            ))\n            .size(100)\n            .all();\n\n        const integration_apps_response: IntegrationAppResponse = {\n            success: true,\n            data: integration_apps.map(integration_app =\u003e {\n                return {\n                    id: integration_app.data.__id,\n                    documentName: integration_app.data.document_odata_name ?? \"\",\n                    documentData: integration_app.data.document_creation_data ? JSON.parse(integration_app.data.document_creation_data) : {},\n                    employeesId: integration_app.data.personal_guid_1c ? JSON.parse(integration_app.data.personal_guid_1c) : [],\n                    isCorrection: !!integration_app.data.isCorrection,\n                    creationDate: integration_app.data.__createdAt.format(DATETIME_FORMAT_1C),\n                    addInfo: integration_app.data.additional_info ?? \"\",\n                }\n            })\n        };\n\n        response\n            .status(200)\n            .content('application/json')\n            .json(integration_apps_response)\n    } catch (error) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack,\n                },\n            });\n    }\n\n    return response;\n}\n\nasync function postIntegrationApps(req: HttpApiRequest): Promise\u003cHttpResponse\u003e {\n    const response = new HttpResponse();\n\n    try {\n        // Вернуть после доработок по разным базам ЗУП. \n        // const base_1c = req.query?.sourceName;\n        const base_1c = undefined;\n\n        const body = req.body?.toString();\n        const request: IntegrationAppRequest = body ? JSON.parse(body) : undefined;\n\n        if (!request) {\n            throw new Error(\"Integration app request is undefined\");\n        }\n\n        const documents = request.data?.Array ?? [];\n\n        let promises: Promise\u003cvoid\u003e[] = [];\n\n        const integration_app_ids = documents\n            .filter(f =\u003e f.guid_Elma != undefined)\n            .map(f =\u003e f.guid_Elma);\n\n        const integration_apps = await Namespace.params.fields.integration_app.app.search()\n            .where((f, g) =\u003e g.and(\n                f.__deletedAt.eq(null),\n                f.__id.in(integration_app_ids)\n            ))\n            .size(integration_app_ids.length)\n            .all();\n\n        for (const document of documents) {\n            let integration_app: IntegrationApp | undefined;\n\n            if (document.guid_Elma) {\n                integration_app = integration_apps.find(f =\u003e f.id == document.guid_Elma);\n\n                if (!integration_app) {\n                    throw new Error(`Не удалось найти приложение интеграции с ID = ${document.guid_Elma}`)\n                }\n\n                integration_app.data.processed_elma = false;\n                integration_app.data.update_time = new Datetime();\n                integration_app.data.document_number = document.docNumber;\n                integration_app.data.document_date = document.docDate ? new Datetime(document.docDate, DATETIME_FORMAT_1C) : undefined;\n                integration_app.data.document_1c_data = document.objectData;\n            } else {\n                integration_app = Namespace.params.fields.integration_app.app.create();\n\n                integration_app.data.__name = document.documentType.split(\"_\")[1];\n                integration_app.data.accounting_systems = AccountingSystem.zup_1c;\n                integration_app.data.document_odata_name = document.documentType\n                integration_app.data.document_number = document.docNumber;\n                integration_app.data.document_date = document.docDate ? new Datetime(document.docDate, DATETIME_FORMAT_1C) : undefined;\n                integration_app.data.document_1c_data = document.objectData;\n                integration_app.data.personal_guid_1c = JSON.stringify(document.personIds)\n                integration_app.data.id_1c = JSON.stringify(document.employeeIds);\n                integration_app.data.is_external = true;\n                integration_app.data.processed_elma = false;\n                integration_app.data.update_time = new Datetime();\n\n                if (base_1c \u0026\u0026 !Array.isArray(base_1c)) {\n                    integration_app.data.base_1c_name = base_1c;\n                }\n            }\n\n            const print_forms_table = integration_app.data.print_forms_table ?? integration_app.fields.print_forms_table.create();\n\n            if (Array.isArray(document.print_forms) \u0026\u0026 document.print_forms.length \u003e 0) {\n                for (const print_form of document.print_forms) {\n                    const file = await createFile(print_form.PrintFormName, print_form.Data.type, print_form.Data.data);\n\n                    if (!file) {\n                        continue;\n                    }\n\n                    let row = print_forms_table.find(f =\u003e f.id_1c === print_form.PrintFormID);\n                    if (!row) row = print_forms_table.insert();\n\n                    row.print_form = file;\n                    row.id_1c = print_form.PrintFormID;\n\n                    if (print_form.Signature) {\n                        const sign_data = await handleSignature(print_form.Signature);\n\n                        if (sign_data) {\n                            row.sign_file = sign_data.sign;\n                            row.stamp = sign_data.stamp;\n                            row.signatory_id_1c = print_form.ELMASignatory;\n                        }\n                    }\n                }\n            }\n\n            promises.push(integration_app.save());\n\n            if (promises.length \u003e 10) {\n                await Promise.all(promises);\n                promises = [];\n            }\n        }\n\n        await Promise.all(promises);\n\n        response.status(201);\n\n    } catch (error) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack,\n                },\n            });\n    }\n\n    return response;\n}\n\nasync function handleSignature(signature: Signature): Promise\u003cSignData1C | undefined\u003e {\n    if (!signature[\"Подпись\"]) return;\n\n    const sign_file = await createFile(signature[\"ИмяФайлаПодписи\"], signature[\"РасширениеФайлаПодписи\"], signature[\"Подпись\"]);\n\n    if (!sign_file) {\n        return;\n    }\n\n    return {\n        sign: sign_file,\n        stamp: signature[\"Отпечаток\"],\n    }\n}\n\nasync function handleDocumentsStatus(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method;\n\n    switch (method) {\n        case \"GET\": {\n            return getDocumentsStatus(req);\n        }\n\n        default: {\n            return new HttpResponse()\n                .status(405)\n                .content(\"Unsupported method\");\n        }\n    }\n}\n\nasync function getDocumentsStatus(req: FetchRequest): Promise\u003cHttpResponse\u003e {\n    const response = new HttpResponse();\n\n    try {\n        const base_1c = req.query?.sourceName;\n\n        const integration_apps = await Namespace.params.fields.integration_app.app.search()\n            .where((f, g) =\u003e g.and(\n                f.__deletedAt.eq(null),\n                f.status_1c.neq(null),\n                f.doc_id_1c.neq(null),\n                // f.base_1c_name.eq(base_1c)\n            ))\n            .size(1000)\n            .all();\n\n        const integration_apps_response = {\n            success: true,\n            array: integration_apps.map(integration_app =\u003e {\n                return {\n                    DocId: integration_app.data.doc_id_1c,\n                    StateId: integration_app.data.status_1c,\n                }\n            }),\n        };\n\n        response\n            .status(201)\n            .content('application/json')\n            .json(integration_apps_response);\n    } catch (error) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack,\n                }\n            })\n    }\n\n    return response;\n}\n\nasync function handleTableData(req: FetchRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method;\n\n    switch (method) {\n        case \"POST\": {\n            return postTableData(req);\n        }\n\n        default: {\n            return new HttpResponse()\n                .status(405)\n                .content(\"Unsupported method\");\n        }\n    }\n}\n\nasync function postTableData(req: FetchRequest): Promise\u003cHttpResponse\u003e {\n    const response = new HttpResponse();\n\n    try {\n        const base_1c = req.query?.sourceName;\n        const personal_guid = req.query?.guid;\n\n        const body = req.body?.toString();\n        const request: PostedData1CRequest = body ? JSON.parse(body) : undefined;\n\n        if (!request) {\n            throw new Error(\"Request body is undefined\");\n        }\n\n        const posted_data: PostedData1CApp = Namespace.params.fields.data_1c.app.create();\n\n        posted_data.data.table_name = request.type;\n        posted_data.data.table_data = JSON.stringify(request.data);\n\n        if (base_1c \u0026\u0026 !Array.isArray(base_1c)) {\n            posted_data.data.base_1c_name = base_1c;\n        }\n\n        if (personal_guid) {\n            const guid = Array.isArray(personal_guid) ? personal_guid[0] : personal_guid;\n            posted_data.data.last_action_author = guid;\n        }\n\n        await posted_data.save();\n\n        response\n            .status(201)\n            .json({\n                success: true\n            });\n\n    } catch (error) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack,\n                },\n            });\n    }\n\n    return response;\n}\n\nasync function handleCheckEmployee(req: HttpApiRequest): Promise\u003cHttpResponse | void\u003e {\n    const method = req.method;\n\n    switch (method) {\n        case \"GET\": {\n            return checkEmployee(req);\n        }\n\n        default: {\n            return new HttpResponse()\n                .status(405)\n                .content(\"Unsupported method\");\n        }\n    }\n}\n\n\nasync function checkEmployee(req: HttpApiRequest): Promise\u003cHttpResponse\u003e {\n    const response = new HttpResponse();\n    \n    // Узнать необходимость этого метода\n    try {\n        // const personal_guid = req.query?.guid;\n        // const base1c = req.query?.sourceName;\n\n        // if (!personal_guid) {\n        //     response\n        //         .status(400)\n        //         .content(\"No required parameters: guid\");\n        // } else {\n        //     const guid = Array.isArray(personal_guid) ? personal_guid[0] : personal_guid;\n        //     const staff = await \n        // }\n\n        // if (!!personal_guid) {\n        //     const guid = Array.isArray(personal_guid) ? personal_guid[0] : personal_guid\n        //     let employee: ApplicationItem\u003cApplication$kedo$staff$Data, Application$kedo$staff$Params\u003e | undefined\n        //     if (base1c \u0026\u0026 !Array.isArray(base1c)) {\n        //         employee = await Namespace.params.fields.employee_app.app.search()\n        //             .where((f, g) =\u003e g.and(\n        //                 f.__deletedAt.eq(null),\n        //                 f.individual_id_1c.eq(guid),\n        //                 f.base_1c_name.eq(base1c)\n        //             ))\n        //             .first()\n        //     } else {\n        //         employee = await Namespace.params.fields.employee_app.app.search()\n        //             .where((f, g) =\u003e g.and(\n        //                 f.__deletedAt.eq(null),\n        //                 f.individual_id_1c.eq(guid)\n        //             ))\n        //             .first()\n        //     }\n        //     response\n        //         .status(200)\n        //         .set('Content-Type', 'application/json')\n        //         .json({\n        //             employeeExists: !!employee\n        //         })\n        // } else {\n        //     response.status(400)\n        //         .content(\"No required parameters: guid\")\n        //     return response\n        // }\n\n        return response.status(400);\n\n    } catch (error) {\n        response\n            .status(500)\n            .set('Content-Type', 'application/json')\n            .json({\n                success: false,\n                error: {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack,\n                }\n            });\n    }\n\n    return response;\n}\n",
  "handlers": [
    {
      "__name": "Расчетные листы",
      "description": "",
      "auth": "external",
      "method": "GET,POST",
      "code": "payslip_table",
      "func": "handlePayslip",
      "async": false
    },
    {
      "__name": "Приложения интеграции",
      "description": "",
      "auth": "external",
      "method": "GET,POST",
      "code": "awaiting_docs_table",
      "func": "handleIntegrationApp",
      "async": false
    },
    {
      "__name": "Получение данных из 1С",
      "description": "",
      "auth": "external",
      "method": "POST",
      "code": "data_table",
      "func": "handleTableData",
      "async": false
    },
    {
      "__name": "Получить статусы документов",
      "description": "",
      "auth": "external",
      "method": "GET",
      "code": "awaiting_docs_table/status",
      "func": "handleDocumentsStatus",
      "async": false
    },
    {
      "__name": "Проверить существование сотрудника",
      "description": "",
      "auth": "external",
      "method": "GET",
      "code": "check_employee",
      "func": "handleCheckEmployee",
      "async": false
    }
  ],
  "draft": false,
  "allowGlobal": false
}
